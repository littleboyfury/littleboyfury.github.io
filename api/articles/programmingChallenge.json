{"title":"programming challenge","uid":"f2b153f889628df8257fd406071bc211","slug":"programmingChallenge","date":"2022-05-14T16:00:00.000Z","updated":"2022-09-28T07:19:23.110Z","comments":true,"path":"api/articles/programmingChallenge.json","keywords":null,"cover":"https://skyfuryblog.oss-cn-guangzhou.aliyuncs.com/img/1652684941333.png","content":"<h1 id=\"编程挑战\"><a href=\"#编程挑战\" class=\"headerlink\" title=\"编程挑战\"></a>编程挑战</h1><h2 id=\"实现链式调用1\"><a href=\"#实现链式调用1\" class=\"headerlink\" title=\"实现链式调用1\"></a>实现链式调用1</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 实现 arrange(&#39;William&#39;).wait(5).do(&#39;commit&#39;).wait(5).do(&#39;push&#39;).execute();\nclass Arrange &#123;\n  constructor(value) &#123;\n    this.value &#x3D; value\n  &#125;\n\n  wait(delay) &#123;\n    &#x2F;&#x2F; push 一个函数，返回 Promise 的一个定时器，使用 Promise 可以保证执行顺序\n    this.queue.push(() &#x3D;&gt; new Promise(resolve &#x3D;&gt; &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n        resolve(&#39;delay &#39; + delay)\n      &#125;, delay)\n    &#125;))\n\n    &#x2F;&#x2F; 返回实例对象\n    return this\n  &#125;\n\n  do(action) &#123;\n    &#x2F;&#x2F; push 一个函数，返回 Promise 的值\n    this.queue.push(() &#x3D;&gt; &#123;\n      return new Promise(resolve &#x3D;&gt; resolve(action))\n    &#125;)\n    &#x2F;&#x2F; 返回实例对象\n    return this\n  &#125;\n\n  &#x2F;**\n   * 同步调用，利用 async-await 进行等待\n   *&#x2F;\n  async execute() &#123;\n    for (const fn of this.queue) &#123;\n      const res &#x3D; await fn()\n      console.log(res)\n    &#125;\n    console.log(this.value)\n  &#125;\n\n  &#x2F;**\n   * 异步调用，利用 Promise.then 进行递归等待，保证顺序执行\n   *&#x2F;\n  syncExecute() &#123;\n    if (this.queue.length) &#123;\n      &#x2F;&#x2F; 推出数组第一个开始执行\n      this.queue.shift()()\n        .then(res &#x3D;&gt; &#123;\n          console.log(res)\n          &#x2F;&#x2F; 递归执行下一个指令\n          this.syncExecute()\n        &#125;)\n    &#125; else &#123;\n      console.log(this.value)\n    &#125;\n  &#125;\n&#125;\n\nfunction arrange(value): Arrange &#123;\n  return new Arrange(value)\n&#125;\n\narrange(&#39;William&#39;)\n  .wait(1000)\n  .do(&#39;commit&#39;)\n  .do(&#39;push2&#39;)\n  .wait(1000)\n  .do(&#39;push3&#39;)\n  .wait(1000)\n  .do(&#39;push4&#39;)\n  .wait(1000)\n  .do(&#39;push5&#39;)\n  .execute()\n&#x2F;&#x2F; .syncExecute()\n\n&#x2F;&#x2F; 结果\n&#x2F;&#x2F; delay 1000\n&#x2F;&#x2F; commit\n&#x2F;&#x2F; push2\n&#x2F;&#x2F; delay 1000\n&#x2F;&#x2F; push3\n&#x2F;&#x2F; delay 1000\n&#x2F;&#x2F; push4\n&#x2F;&#x2F; delay 1000\n&#x2F;&#x2F; push5\n&#x2F;&#x2F; William</code></pre>\n\n<h2 id=\"实现链式调用2\"><a href=\"#实现链式调用2\" class=\"headerlink\" title=\"实现链式调用2\"></a>实现链式调用2</h2><p>实现变量 u 以满足以下条件：</p>\n<ol>\n<li>支持链式调用；</li>\n<li>执行 setTimeout 后，代码将会阻塞停滞，在指定时间以后继续执行。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">u.console(&#39;breakfast&#39;) &#x2F;&#x2F; 在控制台输出 &#39;breakfast&#39;\n  .setTimeout(3000)    &#x2F;&#x2F; 延迟 3s\n  .console(&#39;lunch&#39;)    &#x2F;&#x2F; 在控制台输出 &#39;lunch&#39;\n  .setTimeout(3000)    &#x2F;&#x2F; 延迟 3s\n  .console(&#39;dinner&#39;)   &#x2F;&#x2F; 在控制台输出 &#39;dinner&#39;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class U &#123;\n  constructor() &#123;\n    this.tasks &#x3D; []\n    this.next()\n  &#125;\n\n  console(data) &#123;\n    this.tasks.push(() &#x3D;&gt; &#123;\n      console.log(data)\n      this.next()\n    &#125;)\n    return this\n  &#125;\n\n  setTimeout(time) &#123;\n    this.tasks.push(() &#x3D;&gt; &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n        this.next()\n      &#125;, time)\n    &#125;)\n\n    return this\n  &#125;\n\n  next() &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      const fn &#x3D; this.tasks.shift()\n      fn &amp;&amp; fn()\n    &#125;, 0)\n  &#125;\n&#125;\n\n\nnew U().console(&#39;breakfast&#39;)\n  .setTimeout(3000)\n  .console(&#39;lunch&#39;)\n  .setTimeout(3000)\n  .console(&#39;dinner&#39;)\n</code></pre>\n\n<h2 id=\"实现柯里化\"><a href=\"#实现柯里化\" class=\"headerlink\" title=\"实现柯里化\"></a>实现柯里化</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 实现函数柯里化\nfunction curry(fn) &#123;\n  &#x2F;&#x2F; 闭包缓存 fn\n  return function curryFn(...args) &#123;\n    &#x2F;&#x2F; 闭包缓存 args\n    if (fn.length &gt; args.length) &#123;\n      &#x2F;&#x2F; 如果参数小于函数参数，继续返回柯里化函数\n      return function () &#123;\n        &#x2F;&#x2F; 递归调用\n        return curryFn(...args.concat(Array.from(arguments)))\n      &#125;\n    &#125;\n    return fn(...args)\n  &#125;\n&#125;\n\nfunction add(a, b, c, d) &#123;\n  return a + b + c + d\n&#125;\n\nconst curried &#x3D; curry(add)\n\nconst fn1 &#x3D; curried(1)\nconst fn2 &#x3D; fn1(2)\nconst fn3 &#x3D; fn2(3)\nconsole.log(fn3(4))\nconsole.log(fn3(4, 5))\nconsole.log(fn3(4))\n\n&#x2F;&#x2F; 10\n&#x2F;&#x2F; 10\n&#x2F;&#x2F; 10</code></pre>\n\n<h2 id=\"实现-Scheduler-类\"><a href=\"#实现-Scheduler-类\" class=\"headerlink\" title=\"实现 Scheduler 类\"></a>实现 Scheduler 类</h2><p>实现 Scheduler 类，使得下面的输出成立</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const timeout &#x3D; (time, value) &#x3D;&gt; new Promise(resolve &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; resolve(value), time)\n&#125;)\nconst scheduler &#x3D; new Scheduler(2)\nconst addTask &#x3D; (time, order, value?) &#x3D;&gt; &#123;\n  return scheduler.add(() &#x3D;&gt; timeout(time, value))\n    .then((value) &#x3D;&gt; &#123;\n      console.log(order)\n      return value\n    &#125;)\n&#125;\n\naddTask(1000, &#39;1&#39;, &#39;value111111&#39;).then(value &#x3D;&gt; console.log(value))\naddTask(500, &#39;2&#39;)\naddTask(300, &#39;3&#39;, &#39;311111&#39;).then(value &#x3D;&gt; console.log(value))\naddTask(400, &#39;4&#39;)\n&#x2F;&#x2F; output: 2 3 1 4</code></pre>\n\n<ul>\n<li>使用 async-await 实现</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Scheduler &#123;\n  &#x2F;&#x2F; 并发数\n  concurrency: number\n  &#x2F;&#x2F; 当前运行数量\n  currentConcurrency: number &#x3D; 0\n  &#x2F;&#x2F; 阻塞队列\n  queue: Array&lt;any&gt; &#x3D; []\n\n  constructor(concurrency: number) &#123;\n    &#x2F;&#x2F; 最大并发数量\n    this.concurrency &#x3D; concurrency\n  &#125;\n\n  async add(callback: () &#x3D;&gt; any) &#123;\n    &#x2F;&#x2F; 如果超过了最大并发数量\n    if (this.currentConcurrency &gt;&#x3D; this.concurrency) &#123;\n      &#x2F;&#x2F; 阻塞在这里\n      await new Promise(resolve &#x3D;&gt; this.queue.push(resolve))\n    &#125;\n    &#x2F;&#x2F; 增加当前运行数\n    this.currentConcurrency++\n    &#x2F;&#x2F; 运行当前函数\n    const res &#x3D; await callback()\n    &#x2F;&#x2F; 减少当前运行数\n    this.currentConcurrency--\n\n    &#x2F;&#x2F; 判断队列中是否还有多余任务\n    if (this.queue.length) &#123;\n      &#x2F;&#x2F; 解除阻塞\n      this.queue.shift()()\n    &#125;\n    &#x2F;&#x2F; 返回执行结果\n    return res\n  &#125;\n&#125;\n\nconst timeout &#x3D; (time, value) &#x3D;&gt; new Promise(resolve &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; resolve(value), time)\n&#125;)\nconst scheduler &#x3D; new Scheduler(2)\nconst addTask &#x3D; (time, order, value?) &#x3D;&gt; &#123;\n  return scheduler.add(() &#x3D;&gt; timeout(time, value))\n    .then((value) &#x3D;&gt; &#123;\n      console.log(order)\n      return value\n    &#125;)\n&#125;\n\naddTask(1000, &#39;1&#39;, &#39;value111111&#39;).then(value &#x3D;&gt; console.log(value))\naddTask(500, &#39;2&#39;)\naddTask(300, &#39;3&#39;, &#39;311111&#39;).then(value &#x3D;&gt; console.log(value))\naddTask(400, &#39;4&#39;)\n&#x2F;&#x2F; output: 2 3 1 4</code></pre>\n\n<ul>\n<li>使用 Promise 实现</li>\n</ul>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Scheduler &#123;\n  &#x2F;&#x2F; 并发数\n  concurrency: number\n  &#x2F;&#x2F; 当前运行数量\n  currentConcurrency: number &#x3D; 0\n  &#x2F;&#x2F; 阻塞队列\n  queue: Array&lt;any&gt; &#x3D; []\n\n  constructor(concurrency: number) &#123;\n    &#x2F;&#x2F; 最大并发数量\n    this.concurrency &#x3D; concurrency\n  &#125;\n\n  addSync(callback: () &#x3D;&gt; Promise&lt;any&gt;) &#123;\n    &#x2F;&#x2F; 返回一个 promise 对象\n    return new Promise(resolve &#x3D;&gt; &#123;\n      if (this.currentConcurrency &gt;&#x3D; this.concurrency) &#123;\n        &#x2F;&#x2F; 使用 promise 进行阻塞，因为没有调用 resolve1 方法\n        new Promise(resolve1 &#x3D;&gt; &#123;\n          this.queue.push(resolve1)\n        &#125;)\n          .then(() &#x3D;&gt; &#123;\n            &#x2F;&#x2F; 解除后则可以运行任务\n            this.runJob(resolve, callback)\n          &#125;)\n      &#125; else &#123;\n        &#x2F;&#x2F; 运行任务\n        this.runJob(resolve, callback)\n      &#125;\n    &#125;)\n  &#125;\n\n  runJob(resolve, callback: () &#x3D;&gt; Promise&lt;any&gt;) &#123;\n    &#x2F;&#x2F; 开始运行任务\n    this.currentConcurrency++\n    callback()\n      .then(res &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 任务执行完毕\n        this.currentConcurrency--\n        if (this.queue.length) &#123;\n          &#x2F;&#x2F; 解除后面的任务\n          this.queue.shift()()\n        &#125;\n        &#x2F;&#x2F; 返回结果\n        resolve(res)\n      &#125;)\n  &#125;\n&#125;\n\nconst timeout &#x3D; (time, value) &#x3D;&gt; new Promise(resolve &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; resolve(value), time)\n&#125;)\nconst scheduler &#x3D; new Scheduler(2)\n\nconst addTaskSync &#x3D; (time, order, value?) &#x3D;&gt; &#123;\n  return scheduler.addSync(() &#x3D;&gt; timeout(time, value))\n    .then((value) &#x3D;&gt; &#123;\n      console.log(order)\n      return value\n    &#125;)\n&#125;\n\naddTaskSync(1000, &#39;1&#39;, &#39;value111111&#39;).then(value &#x3D;&gt; console.log(value))\naddTaskSync(500, &#39;2&#39;)\naddTaskSync(300, &#39;3&#39;, &#39;311111&#39;).then(value &#x3D;&gt; console.log(value))\naddTaskSync(400, &#39;4&#39;)\n&#x2F;&#x2F; output: 2 3 1 4</code></pre>\n\n","feature":true,"text":"编程挑战实现链式调用1&#x2F;&#x2F; 实现 arrange(&#39;William&#39;).wait(5).do(&#39;commit&#39;).wait(5).do(&#39;push&#39;).execute(); class Arrange &#123...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"教程","slug":"教程","count":5,"path":"api/categories/教程.json"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","count":14,"path":"api/tags/JAVASCRIPT.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BC%96%E7%A8%8B%E6%8C%91%E6%88%98\"><span class=\"toc-text\">编程挑战</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A81\"><span class=\"toc-text\">实现链式调用1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A82\"><span class=\"toc-text\">实现链式调用2</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%9F%AF%E9%87%8C%E5%8C%96\"><span class=\"toc-text\">实现柯里化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0-Scheduler-%E7%B1%BB\"><span class=\"toc-text\">实现 Scheduler 类</span></a></li></ol></li></ol>","author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}},"mapped":true,"prev_post":{"title":"TypeScript 系列","uid":"9aecd670d0e041c4ae0eeba9f323dfdf","slug":"typescriptSeries","date":"2022-05-17T16:00:00.000Z","updated":"2022-09-28T07:19:23.111Z","comments":true,"path":"api/articles/typescriptSeries.json","keywords":null,"cover":"https://skyfuryblog.oss-cn-guangzhou.aliyuncs.com/img/1652855718873.png","text":"TypeScript 系列TypeScript 类型TypeScriptType ","link":"","photos":[],"count_time":{"symbolsCount":41,"symbolsTime":"1 mins."},"categories":[{"name":"编程","slug":"编程","count":3,"path":"api/categories/编程.json"}],"tags":[{"name":"TYPESCRIPT","slug":"TYPESCRIPT","count":5,"path":"api/tags/TYPESCRIPT.json"}],"author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}},"feature":true},"next_post":{"title":"VueRouter 中重定向到动态的 path","uid":"c72fb498b1064492902648005ad6e6d9","slug":"vueRouter","date":"2022-05-12T16:00:00.000Z","updated":"2022-09-28T07:19:23.112Z","comments":true,"path":"api/articles/vueRouter.json","keywords":null,"cover":"https://skyfuryblog.oss-cn-guangzhou.aliyuncs.com/img/1652424063992.png","text":"VueRouter背景在 vue-router 中，重定向到某个页面采用下面的配置 const routes &#x3D; [ &#123; path: &#39;&#x2F;test&#39;, redirect: &#39;&#x2F;aaa&#39;, &#125;, ] ...","link":"","photos":[],"count_time":{"symbolsCount":801,"symbolsTime":"1 mins."},"categories":[{"name":"前端","slug":"前端","count":4,"path":"api/categories/前端.json"}],"tags":[{"name":"VUE","slug":"VUE","count":2,"path":"api/tags/VUE.json"},{"name":"VUE_ROUTER","slug":"VUE-ROUTER","count":1,"path":"api/tags/VUE-ROUTER.json"}],"author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}}}}