{"title":"webpack 自定义 loader","uid":"1f856bdf240a03a57edc41573ba4f1c6","slug":"webpack","date":"2022-10-25T16:00:00.000Z","updated":"2023-07-10T08:34:58.060Z","comments":true,"path":"api/articles/webpack.json","keywords":null,"cover":"https://skyfuryblog.oss-cn-guangzhou.aliyuncs.com/img/1666682400879.png","content":"<h1 id=\"webpack-自定义-loader\"><a href=\"#webpack-自定义-loader\" class=\"headerlink\" title=\"webpack 自定义 loader\"></a>webpack 自定义 loader</h1><h2 id=\"需求来源\"><a href=\"#需求来源\" class=\"headerlink\" title=\"需求来源\"></a>需求来源</h2><p>需要在客户端中写入日志，并且需要知道报错日志的原文件路径和行号，不采用 sentry 的方式（需要额外部署）</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>想法是在 logger 的最后两个参数中加入原始文件名和行号，所以这一步在 webpack 加载文件的时候就需要去解析文件，默认添加参数</p>\n<h2 id=\"自定义-loader\"><a href=\"#自定义-loader\" class=\"headerlink\" title=\"自定义 loader\"></a>自定义 loader</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const path &#x3D; require(&#39;path&#39;)\nconst traverse &#x3D; require(&#39;@babel&#x2F;traverse&#39;).default\nconst generate &#x3D; require(&#39;@babel&#x2F;generator&#39;).default\nconst parser &#x3D; require(&#39;@babel&#x2F;parser&#39;)\nconst t &#x3D; require(&#39;@babel&#x2F;types&#39;)\n\n&#x2F;**\n * 自己封装的方法\n * 使用方式：logger.log(...args)\n *&#x2F;\nconst loggers &#x3D; [\n  &#39;log&#39;,\n  &#39;error&#39;,\n  &#39;warn&#39;,\n  &#39;info&#39;,\n  &#39;debug&#39;\n]\n\nfunction loggerLoader(content) &#123;\n  &#x2F;&#x2F; 得到源文件的路径\n  const filename &#x3D; path.relative(this.rootContext, this.resourcePath)\n  &#x2F;&#x2F; 解析 AST\n  const ast &#x3D; parser.parse(content, &#123;\n    sourceType: &#39;module&#39;\n  &#125;)\n  &#x2F;&#x2F; 便利 AST\n  traverse(ast, &#123;\n    &#x2F;&#x2F; https:&#x2F;&#x2F;astexplorer.net&#x2F; 这里可以在这个网站中看见，遍历对应的 Expression\n    CallExpression(path) &#123;\n      const memberExpression &#x3D; path.get(&#39;MemberExpression&#39;)\n      &#x2F;&#x2F; 这里可以通过 debug 的方式一步步寻找自己想要的节点\n      if (memberExpression &amp;&amp; memberExpression.container &amp;&amp; memberExpression.container.callee) &#123;\n        const callee &#x3D; memberExpression.container.callee\n\n        if (callee.object &amp;&amp; callee.property) &#123;\n          &#x2F;&#x2F; 验证 logger.log \n          if (t.isIdentifier(callee.object, &#123;name: &#39;logger&#39;&#125;) &amp;&amp;\n            loggers.find(v &#x3D;&gt; t.isIdentifier(callee.property, &#123;name: v&#125;))) &#123;\n            &#x2F;&#x2F; 构造一个 string ，传入文件路径\n            const filenameNode &#x3D; t.stringLiteral(filename)\n            &#x2F;&#x2F; 构造一个 number ，传入开始行号\n            const lineNumStart &#x3D; t.numericLiteral(path.node.loc.start.line)\n            &#x2F;&#x2F; 构造一个 number ，传入结束行号\n            const lineNumEnd &#x3D; t.numericLiteral(path.node.loc.end.line)\n\n            &#x2F;&#x2F; 放入到参数末尾中\n            path.node.arguments.push(filenameNode)\n            path.node.arguments.push(lineNumStart)\n            path.node.arguments.push(lineNumEnd)\n          &#125;\n        &#125;\n      &#125;\n    &#125;\n  &#125;)\n\n  &#x2F;&#x2F; 重新生成代码，则所有的 logger.log 在最后都加上了三个参数 (...args, filename, lineNumStart, lineNumEnd)\n  return generate(ast, &#123;&#125;).code\n&#125;\n\n&#x2F;&#x2F; 默认导出\nmodule.exports &#x3D; loggerLoader</code></pre>\n\n<h2 id=\"封装-logger\"><a href=\"#封装-logger\" class=\"headerlink\" title=\"封装 logger\"></a>封装 logger</h2><p>采用了 winston 进行日志写入</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const &#123;\n  createLogger,\n  format,\n  transports\n&#125; &#x3D; require(&#39;winston&#39;)\nrequire(&#39;winston-daily-rotate-file&#39;)\nconst os &#x3D; require(&#39;os&#39;)\nconst path &#x3D; require(&#39;path&#39;)\n\n&#x2F;&#x2F; 构造 Symbol\nconst loggerSymbol &#x3D; Symbol(&#39;loggerSymbol&#39;)\n\n&#x2F;&#x2F; winston 中需要的方法名，其他可以自行加入\nconst LOGGERS &#x3D; [\n  &#39;error&#39;,\n  &#39;warn&#39;,\n  &#39;info&#39;,\n  &#39;debug&#39;\n]\n\nclass Logger &#123;\n  &#x2F;&#x2F; winston 实例\n  constructor(logger) &#123;\n    this.logger &#x3D; logger\n  &#125;\n\n  log(...args) &#123;\n    this.info(...args)\n  &#125;\n\n  info(...args) &#123;\n    this[loggerSymbol](&#39;log&#39;, ...args)\n    this.logger.info(...args)\n  &#125;\n\n  warn(...args) &#123;\n    this[loggerSymbol](&#39;warn&#39;, ...args)\n    this.logger.warn(...args)\n  &#125;\n\n  error(...args) &#123;\n    this[loggerSymbol](&#39;error&#39;, ...args)\n    this.logger.error(...args)\n  &#125;\n\n  debug(...args) &#123;\n    this[loggerSymbol](&#39;debug&#39;, ...args)\n    this.logger.debug(...args)\n  &#125;\n\n  [loggerSymbol](type, ...args) &#123;\n    &#x2F;&#x2F; 获取最后三个变量，则是原始文件路径，开始行号和结束行号\n    const fileInfoArgs &#x3D; args.splice(args.length - 3)\n    if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39;) &#123;\n      &#x2F;&#x2F; 按需答应\n      console[type](\n        &#96;[$&#123;fileInfoArgs[0]&#125;] [$&#123;fileInfoArgs[1]&#125;] [$&#123;fileInfoArgs[2]&#125;]&#96;,\n        ...args\n      )\n    &#125;\n  &#125;\n&#125;\n\nconst customFormat &#x3D; format.combine(\n  &#x2F;&#x2F; format.label(&#123; label: &#39;render&#39; &#125;),\n  format.timestamp(&#123;\n    format: &#39;YYYY-MM-DD HH:mm:ss&#39;\n  &#125;),\n  format.align(),\n  &#x2F;&#x2F; 构造打印日志的格式 \n  format.printf((info) &#x3D;&gt; &#123;\n    info.message &#x3D; info.message.substring(1)\n    &#x2F;&#x2F; webpack 编译传入的参数对象\n    const symbol &#x3D; Object.getOwnPropertySymbols(info).find(symbol &#x3D;&gt; symbol.description &#x3D;&#x3D;&#x3D; &#39;splat&#39;)\n    let message\n    if (symbol) &#123;\n      &#x2F;&#x2F; 通过 webpack loader 会传入文件所在的位置\n      const args &#x3D; info[symbol]\n      const len &#x3D; args.length\n      if (len &gt;&#x3D; 3) &#123;\n        &#x2F;&#x2F; 自定义日志格式，加入源文件路径，开始行号和结束行号\n        message &#x3D; &#96;[$&#123;[info.timestamp]&#125;] [$&#123;args[len - 3]&#125;] [$&#123;args[len - 2]&#125;] [$&#123;args[len - 1]&#125;] [$&#123;info.level&#125;] - $&#123;info.message&#125;&#96;\n      &#125;\n    &#125;\n    if (!message) &#123;\n      message &#x3D; &#96;[$&#123;[info.timestamp]&#125;] [$&#123;info.level&#125;] - $&#123;info.message&#125;&#96;\n    &#125;\n\n    return message\n  &#125;)\n)\n\nconst defaultOptions &#x3D; &#123;\n  format: customFormat,\n  datePattern: &#39;YYYY-MM-DD&#39;,\n  zippedArchive: true,\n  &#x2F;&#x2F; maxSize: &#39;1m&#39;,\n  maxFiles: &#39;14d&#39;\n&#125;\n\nlet filename &#x3D; &#39;logs&#x2F;%DATE%.log&#39;\nfilename &#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39; ? filename : path.join(os.tmpdir(), filename)\n\nconst logger &#x3D; createLogger(&#123;\n  &#x2F;&#x2F; format: customFormat,\n  transports: [\n    new transports.DailyRotateFile(&#123;\n      filename,\n      level: &#39;debug&#39;,\n      ...defaultOptions\n    &#125;)\n  ]\n&#125;)\n\nconst toMessage &#x3D; (arg) &#x3D;&gt; &#96;$&#123;arg&#125; &#96;\n\n&#x2F;&#x2F; 重写 winston 实例，对路径和行号参数进行处理，把原有的参数变为字符串\nLOGGERS.forEach(v &#x3D;&gt; &#123;\n  const fn &#x3D; logger[v]\n  if (fn) &#123;\n    logger[v] &#x3D; function (...args) &#123;\n      let message &#x3D; &#39;&#39;\n      const fileInfoArgs &#x3D; args.splice(args.length - 3)\n\n      args.forEach(arg &#x3D;&gt; &#123;\n        if (typeof arg &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;\n          message +&#x3D; toMessage(JSON.stringify(arg))\n        &#125; else &#123;\n          message +&#x3D; toMessage(arg)\n        &#125;\n      &#125;)\n\n      fn(message, ...fileInfoArgs)\n    &#125;\n  &#125;\n&#125;)\n\nconst hxLogger &#x3D; new Logger(logger)\n\nmodule.exports &#x3D; &#123;\n  logger: hxLogger,\n  loggerFilePath: filename\n&#125;</code></pre>\n\n<h2 id=\"webpack-配置\"><a href=\"#webpack-配置\" class=\"headerlink\" title=\"webpack 配置\"></a>webpack 配置</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; webpack 配置\nmodule.exports &#x3D; &#123;\n  module: &#123;\n    rules: [&#123;\n      test: &#x2F;\\.js$&#x2F;,\n      &#x2F;&#x2F; 制定自定义 loader 的路径\n      use: [path.join(__dirname, &#39;.&#x2F;console-loader.js&#39;)]\n    &#125;]\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 代码使用\nlogger.info(&#39;test&#39;)\nlogger.error(&#39;test&#39;)\nlogger.debug(&#39;test&#39;)\nlogger.warn(&#39;test&#39;)\nlogger.log(&#39;test&#39;)</code></pre>\n\n<h2 id=\"日志样例\"><a href=\"#日志样例\" class=\"headerlink\" title=\"日志样例\"></a>日志样例</h2><pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">[2022-10-25 13:11:59] [src&#x2F;renderer&#x2F;App.vue] [17] [17] [info] - IPV4 111.111.111.111\n[2022-10-25 13:11:59] [src&#x2F;renderer&#x2F;App.vue] [18] [18] [info] - mac 地址 11:11:11:11:11:11 \n[2022-10-25 13:11:59] [src&#x2F;renderer&#x2F;App.vue] [19] [19] [info] - 磁盘序列号 1111111111\n[2022-10-25 13:11:59] [src&#x2F;renderer&#x2F;App.vue] [20] [20] [info] - 系统序列号 111111111\n[2022-10-25 13:11:59] [src&#x2F;renderer&#x2F;App.vue] [21] [21] [info] - 系统驱动版本 12.6 \n[2022-10-25 13:11:59] [src&#x2F;renderer&#x2F;App.vue] [22] [22] [info] - 用户名 11111111</code></pre>\n\n<h2 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h2><p>vue 文件中的行号不是对应 script 标签中的行号，需要减去前面 template 占有的行号，基本可以满足对日志定位的需求</p>\n","feature":true,"text":"webpack 自定义 loader需求来源需要在客户端中写入日志，并且需要知道报错日志的原文件路径和行号，不采用 sentry 的方式（需要额外部署） 思路想法是在 logger 的最后两个参数中加入原始文件名和行号，所以这一步在 webpack 加载文件的时候就需要去解析文件...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[{"name":"前端","slug":"前端","count":3,"path":"api/categories/前端.json"}],"tags":[{"name":"VUE","slug":"VUE","count":2,"path":"api/tags/VUE.json"},{"name":"ELECTRON","slug":"ELECTRON","count":2,"path":"api/tags/ELECTRON.json"},{"name":"WEBPACK","slug":"WEBPACK","count":2,"path":"api/tags/WEBPACK.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#webpack-%E8%87%AA%E5%AE%9A%E4%B9%89-loader\"><span class=\"toc-text\">webpack 自定义 loader</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9C%80%E6%B1%82%E6%9D%A5%E6%BA%90\"><span class=\"toc-text\">需求来源</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89-loader\"><span class=\"toc-text\">自定义 loader</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%81%E8%A3%85-logger\"><span class=\"toc-text\">封装 logger</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#webpack-%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">webpack 配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%97%A5%E5%BF%97%E6%A0%B7%E4%BE%8B\"><span class=\"toc-text\">日志样例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E8%B6%B3\"><span class=\"toc-text\">不足</span></a></li></ol></li></ol>","author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"electron 常见问题","uid":"98a5ddadc5f84e73bebd47e1058c0877","slug":"electron","date":"2022-10-25T16:00:00.000Z","updated":"2023-07-10T08:34:58.060Z","comments":true,"path":"api/articles/electron.json","keywords":null,"cover":"https://skyfuryblog.oss-cn-guangzhou.aliyuncs.com/img/1666676246515.png","text":"Electron 常见问题Electron 使用 chokidar 导致编译后白屏的问题 问题出现场景： 配置的是 contextIsolation 为 false ，可以在 renderer 进程中去使用 node 的包，使用 chokidar 去监听文件变化，windows ...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"前端","slug":"前端","count":3,"path":"api/categories/前端.json"}],"tags":[{"name":"ELECTRON","slug":"ELECTRON","count":2,"path":"api/tags/ELECTRON.json"},{"name":"WEBPACK","slug":"WEBPACK","count":2,"path":"api/tags/WEBPACK.json"}],"author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}},"feature":true}}