{"title":"Electron 使用 cryptoJs 加密","uid":"39b4d57bd8b6b84b4666262778a8be78","slug":"cryptoJs","date":"2022-10-25T16:00:00.000Z","updated":"2023-07-10T08:34:58.059Z","comments":true,"path":"api/articles/cryptoJs.json","keywords":null,"cover":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211212224316297.png","content":"<h1 id=\"Electron-使用-cryptoJs-进行加密\"><a href=\"#Electron-使用-cryptoJs-进行加密\" class=\"headerlink\" title=\"Electron 使用 cryptoJs 进行加密\"></a>Electron 使用 cryptoJs 进行加密</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>由于 electron 开启了浏览器端可以直接使用 node 的包，所以导致了对文件加密时出现了多种类型的文件描述，node fs 读取的 Buffer 文件，浏览器的 Blob 文件</p>\n<h2 id=\"key-和-iv-构建\"><a href=\"#key-和-iv-构建\" class=\"headerlink\" title=\"key 和 iv 构建\"></a>key 和 iv 构建</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const key &#x3D; CryptoJS.enc.Utf8.parse(&#39;1111111111&#39;)\nconst iv &#x3D; CryptoJS.enc.Utf8.parse(&#39;11111111111&#39;)</code></pre>\n\n<h2 id=\"不同格式之间转换\"><a href=\"#不同格式之间转换\" class=\"headerlink\" title=\"不同格式之间转换\"></a>不同格式之间转换</h2><h3 id=\"Buffer-to-ArrayBuffer\"><a href=\"#Buffer-to-ArrayBuffer\" class=\"headerlink\" title=\"Buffer to ArrayBuffer\"></a>Buffer to ArrayBuffer</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function bufferToArrayBuffer(buffer) &#123;\n  const arrayBuffer &#x3D; new ArrayBuffer(buffer.length)\n  const res &#x3D; new Uint8Array(arrayBuffer)\n  for (let i &#x3D; 0; i &lt; buffer.length; ++i) &#123;\n    res[i] &#x3D; buffer[i]\n  &#125;\n  return arrayBuffer\n&#125;</code></pre>\n\n<h3 id=\"Blob-to-ArrayBuffer\"><a href=\"#Blob-to-ArrayBuffer\" class=\"headerlink\" title=\"Blob to ArrayBuffer\"></a>Blob to ArrayBuffer</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function blobToArrayBuffer(blob) &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    const file &#x3D; new FileReader()\n    file.onload &#x3D; function(result) &#123;\n      resolve(file.result)\n    &#125;\n    file.readAsArrayBuffer(blob)\n  &#125;)\n&#125;</code></pre>\n\n<h3 id=\"wordArray-To-ArrayBuffer\"><a href=\"#wordArray-To-ArrayBuffer\" class=\"headerlink\" title=\"wordArray To ArrayBuffer\"></a>wordArray To ArrayBuffer</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function wordArrayToArrayBuffer(wordArray) &#123;\n  const &#123; words &#125; &#x3D; wordArray\n  const &#123; sigBytes &#125; &#x3D; wordArray\n  const u8 &#x3D; new Uint8Array(sigBytes)\n  for (let i &#x3D; 0; i &lt; sigBytes; i +&#x3D; 1) &#123;\n    u8[i] &#x3D; (words[i &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - (i % 4) * 8)) &amp; 0xff\n  &#125;\n  return u8\n&#125;</code></pre>\n\n<h2 id=\"文件加密\"><a href=\"#文件加密\" class=\"headerlink\" title=\"文件加密\"></a>文件加密</h2><h3 id=\"对-WordArray-进行加密\"><a href=\"#对-WordArray-进行加密\" class=\"headerlink\" title=\"对 WordArray 进行加密\"></a>对 WordArray 进行加密</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function encryptFile(wordArray) &#123;\n  &#x2F;&#x2F; encrypt 函数接受的是一个 wordArray 对象\n  const encrypt &#x3D; CryptoJS.AES.encrypt(wordArray, key, &#123;\n    iv,\n    mode: CryptoJS.mode.CBC,\n    padding: CryptoJS.pad.Pkcs7\n  &#125;)\n  &#x2F;&#x2F; 根据实际场景返回\n  return CryptoJS.enc.Base64.stringify(encrypt.ciphertext)\n&#125;</code></pre>\n\n<h3 id=\"对-Buffer-文件加密\"><a href=\"#对-Buffer-文件加密\" class=\"headerlink\" title=\"对 Buffer 文件加密\"></a>对 Buffer 文件加密</h3><p>对 Buffer 加密，需要先把 Buffer 转为 ArrayBuffer，再把 ArrayBuffer 转为 WordArray</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function encryptBuffer(buffer) &#123;\n  const arrayBuffer &#x3D; bufferToArrayBuffer(buffer)\n  const wordArray &#x3D; CryptoJS.lib.WordArray.create(arrayBuffer)\n  return encryptFile(wordArray)\n&#125;</code></pre>\n\n<h3 id=\"对-Blob-文件加密\"><a href=\"#对-Blob-文件加密\" class=\"headerlink\" title=\"对 Blob 文件加密\"></a>对 Blob 文件加密</h3><p>对 Blob 加密，需要先把 Blob 转为 Arraybuffer，再把 ArrayBuffer 转为 WordArray</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function encryptBlob(blob) &#123;\n  const arrayBuffer &#x3D; await blobToArrayBuffer(blob)\n  const wordArray &#x3D; CryptoJS.lib.WordArray.create(arrayBuffer)\n  return encryptFile(wordArray)\n&#125;</code></pre>\n\n<h2 id=\"文件解密\"><a href=\"#文件解密\" class=\"headerlink\" title=\"文件解密\"></a>文件解密</h2><h3 id=\"对-WordArray-解密\"><a href=\"#对-WordArray-解密\" class=\"headerlink\" title=\"对 WordArray 解密\"></a>对 WordArray 解密</h3><p>文件解密传入的也是 WordArray 对象</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function decryptFile(wordArray) &#123;\n  &#x2F;&#x2F; 后端是采用的 base64 加密，所以需要构建为 base64 的字符串，看情况变化\n  wordArray &#x3D; CryptoJS.enc.Base64.stringify(wordArray)\n  const decrypt &#x3D; CryptoJS.AES.decrypt(wordArray, key, &#123;\n    iv,\n    mode: CryptoJS.mode.CBC,\n    padding: CryptoJS.pad.Pkcs7\n  &#125;)\n  return wordArrayToArrayBuffer(decrypt)\n&#125;</code></pre>\n\n<h3 id=\"对-Blob-解密\"><a href=\"#对-Blob-解密\" class=\"headerlink\" title=\"对 Blob 解密\"></a>对 Blob 解密</h3><p>浏览器通过 axios 返回的是一个 Blob 文件，所以，对 Blob 文件解密需要先转为 ArrayBuffer，然后把ArrayBuffer 转为 WordArray 对象</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function decryptBlob(blob) &#123;\n  const arrayBuffer &#x3D; await blobToArrayBuffer(blob)\n  const wordArray &#x3D; CryptoJS.lib.WordArray.create(arrayBuffer)\n  return decryptFile(wordArray)\n&#125;</code></pre>\n\n\n<h2 id=\"对字符串加解密\"><a href=\"#对字符串加解密\" class=\"headerlink\" title=\"对字符串加解密\"></a>对字符串加解密</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function encrypt(data) &#123;\n  if (typeof data &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;\n    &#x2F;&#x2F; 如果传入的data是json对象，先转义为json字符串\n    data &#x3D; JSON.stringify(data)\n  &#125;\n  const srcs &#x3D; CryptoJS.enc.Utf8.parse(data)\n  const encrypted &#x3D; CryptoJS.AES.encrypt(srcs, key, &#123;\n    iv,\n    mode: CryptoJS.mode.CBC, &#x2F;&#x2F; 加密模式\n    padding: CryptoJS.pad.Pkcs7\n  &#125;)\n  &#x2F;&#x2F; 需要返回base64格式的加密结果\n  return CryptoJS.enc.Base64.stringify(encrypted.ciphertext)\n  &#x2F;&#x2F; 需要返回hex格式的加密结果\n  &#x2F;&#x2F; return encrypted.ciphertext.toString()\n&#125;\n\n&#x2F;**\n * 解密数据\n * @param data 数据\n * @returns &#123;string&#125;\n *&#x2F;\nfunction decrypt(data) &#123;\n  const base64 &#x3D; CryptoJS.enc.Base64.parse(data)\n  const srcs &#x3D; CryptoJS.enc.Base64.stringify(base64)\n  const decrypt &#x3D; CryptoJS.AES.decrypt(srcs, key, &#123;\n    iv: iv,\n    mode: CryptoJS.mode.CBC,\n    padding: CryptoJS.pad.Pkcs7\n  &#125;)\n  const decryptedStr &#x3D; decrypt.toString(CryptoJS.enc.Utf8)\n  return decryptedStr.toString()\n&#125;\n</code></pre>\n","feature":true,"text":"Electron 使用 cryptoJs 进行加密背景由于 electron 开启了浏览器端可以直接使用 node 的包，所以导致了对文件加密时出现了多种类型的文件描述，node fs 读取的 Buffer 文件，浏览器的 Blob 文件 key 和 iv 构建const key...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":9,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","count":14,"path":"api/tags/JAVASCRIPT.json"},{"name":"CRYPTO_JS","slug":"CRYPTO-JS","count":1,"path":"api/tags/CRYPTO-JS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Electron-%E4%BD%BF%E7%94%A8-cryptoJs-%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86\"><span class=\"toc-text\">Electron 使用 cryptoJs 进行加密</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">背景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#key-%E5%92%8C-iv-%E6%9E%84%E5%BB%BA\"><span class=\"toc-text\">key 和 iv 构建</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">不同格式之间转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Buffer-to-ArrayBuffer\"><span class=\"toc-text\">Buffer to ArrayBuffer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Blob-to-ArrayBuffer\"><span class=\"toc-text\">Blob to ArrayBuffer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#wordArray-To-ArrayBuffer\"><span class=\"toc-text\">wordArray To ArrayBuffer</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86\"><span class=\"toc-text\">文件加密</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9-WordArray-%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86\"><span class=\"toc-text\">对 WordArray 进行加密</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9-Buffer-%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86\"><span class=\"toc-text\">对 Buffer 文件加密</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9-Blob-%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86\"><span class=\"toc-text\">对 Blob 文件加密</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E8%A7%A3%E5%AF%86\"><span class=\"toc-text\">文件解密</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9-WordArray-%E8%A7%A3%E5%AF%86\"><span class=\"toc-text\">对 WordArray 解密</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9-Blob-%E8%A7%A3%E5%AF%86\"><span class=\"toc-text\">对 Blob 解密</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E8%A7%A3%E5%AF%86\"><span class=\"toc-text\">对字符串加解密</span></a></li></ol></li></ol>","author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}},"mapped":true,"prev_post":{"title":"electron 常见问题","uid":"98a5ddadc5f84e73bebd47e1058c0877","slug":"electron","date":"2022-10-25T16:00:00.000Z","updated":"2023-07-10T08:34:58.060Z","comments":true,"path":"api/articles/electron.json","keywords":null,"cover":"https://skyfuryblog.oss-cn-guangzhou.aliyuncs.com/img/1666676246515.png","text":"Electron 常见问题Electron 使用 chokidar 导致编译后白屏的问题 问题出现场景： 配置的是 contextIsolation 为 false ，可以在 renderer 进程中去使用 node 的包，使用 chokidar 去监听文件变化，windows ...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"前端","slug":"前端","count":4,"path":"api/categories/前端.json"}],"tags":[{"name":"ELECTRON","slug":"ELECTRON","count":2,"path":"api/tags/ELECTRON.json"},{"name":"WEBPACK","slug":"WEBPACK","count":2,"path":"api/tags/WEBPACK.json"}],"author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}},"feature":true},"next_post":{"title":"webpack 自定义 loader","uid":"1f856bdf240a03a57edc41573ba4f1c6","slug":"webpack","date":"2022-10-25T16:00:00.000Z","updated":"2023-07-10T08:34:58.060Z","comments":true,"path":"api/articles/webpack.json","keywords":null,"cover":"https://skyfuryblog.oss-cn-guangzhou.aliyuncs.com/img/1666682400879.png","text":"webpack 自定义 loader需求来源需要在客户端中写入日志，并且需要知道报错日志的原文件路径和行号，不采用 sentry 的方式（需要额外部署） 思路想法是在 logger 的最后两个参数中加入原始文件名和行号，所以这一步在 webpack 加载文件的时候就需要去解析文件...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[{"name":"前端","slug":"前端","count":4,"path":"api/categories/前端.json"}],"tags":[{"name":"VUE","slug":"VUE","count":2,"path":"api/tags/VUE.json"},{"name":"ELECTRON","slug":"ELECTRON","count":2,"path":"api/tags/ELECTRON.json"},{"name":"WEBPACK","slug":"WEBPACK","count":2,"path":"api/tags/WEBPACK.json"}],"author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}},"feature":true}}