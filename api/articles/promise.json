{"title":"Promise 简写","uid":"66f57e202e85c56083a0db8b6aa3f2f8","slug":"promise","date":"2021-12-15T15:00:00.000Z","updated":"2022-09-28T07:19:23.111Z","comments":true,"path":"api/articles/promise.json","keywords":null,"cover":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211212224316297.png","content":"<h1 id=\"MyPromise\"><a href=\"#MyPromise\" class=\"headerlink\" title=\"MyPromise\"></a>MyPromise</h1><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 状态状态\nconst PENDING &#x3D; &#39;PENDING&#39;\n\n&#x2F;&#x2F; 成功状态\nconst FULFILLED &#x3D; &#39;FULFILLED&#39;\n\n&#x2F;&#x2F; 失败状态\nconst REJECTED &#x3D; &#39;REJECTED&#39;\n\nclass MyPromise &#123;\n  constructor(executor) &#123;\n    try &#123;\n      &#x2F;&#x2F; 执行器，立即执行\n      executor(this.resolve, this.reject)\n    &#125; catch (e) &#123;\n      this.reject(e)\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 初始化状态为准备状态\n  status &#x3D; PENDING\n\n  &#x2F;&#x2F; resolve 的值\n  value &#x3D; undefined\n\n  &#x2F;&#x2F; reject 的值\n  error &#x3D; undefined\n\n  &#x2F;&#x2F; 成功的回调，主要用于异步的情况下多次调用 then 方法\n  successCallBack &#x3D; []\n\n  &#x2F;&#x2F; 失败的回调\n  errorCallBack &#x3D; []\n\n  &#x2F;**\n   * 成功调用，箭头函数里面没有 this，使用 this 时既是外部的 this\n   * @param value 成功后的返回值\n   *&#x2F;\n  resolve &#x3D; value &#x3D;&gt; &#123;\n\n    &#x2F;&#x2F; 状态更改后就不能再次修改，直接返回\n    if (this.status !&#x3D;&#x3D; PENDING) &#123;\n      return\n    &#125;\n\n    &#x2F;&#x2F; 更新状态为成功\n    this.status &#x3D; FULFILLED\n\n    &#x2F;&#x2F; 保存值\n    this.value &#x3D; value\n\n    &#x2F;&#x2F; 执行异步的多次回调\n    while (this.successCallBack.length) &#123;\n      this.successCallBack.shift()()\n    &#125;\n  &#125;\n  &#x2F;**\n   * 失败调用\n   * @param error 错误信息\n   *&#x2F;\n  reject &#x3D; error &#x3D;&gt; &#123;\n\n    &#x2F;&#x2F; 状态修改后就不能再次修改\n    if (this.status !&#x3D;&#x3D; PENDING) &#123;\n      return\n    &#125;\n\n    &#x2F;&#x2F; 更新状态为失败\n    this.status &#x3D; REJECTED\n\n    &#x2F;&#x2F; 保存失败原因\n    this.error &#x3D; error\n\n    &#x2F;&#x2F; 执行异步的多次回调\n    while (this.errorCallBack.length) &#123;\n      this.errorCallBack.shift()()\n    &#125;\n  &#125;\n\n  &#x2F;**\n   * then 方法\n   * @param successCallBack 成功的回调\n   * @param errorCallBack 失败的回调\n   * @return &#123;MyPromise&#125;\n   *&#x2F;\n  then(successCallBack, errorCallBack) &#123;\n    &#x2F;&#x2F; 如果没有传值，默认返回原有的值\n    successCallBack &#x3D; successCallBack || (value &#x3D;&gt; value)\n\n    &#x2F;&#x2F; 如果没有传值，默认抛出原有的错误\n    errorCallBack &#x3D; errorCallBack || (error &#x3D;&gt; &#123;\n      throw error\n    &#125;)\n\n    &#x2F;&#x2F; then 方法需要返回一个行的 MyPromise 对象\n    const promise &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;\n\n      if (this.status &#x3D;&#x3D;&#x3D; FULFILLED) &#123;\n\n        &#x2F;&#x2F; 状态为成功\n        &#x2F;&#x2F; setTimeout 可以保证 promise 中有值，即里面的语句跳过了当前的事件循环\n        setTimeout(() &#x3D;&gt; &#123;\n          try &#123;\n\n            &#x2F;&#x2F; 成功的回调，回调可能返回新的值\n            const x &#x3D; successCallBack(this.value)\n\n            &#x2F;&#x2F; 处理回调返回的值\n            resolvePromise(promise, x, resolve, reject)\n          &#125; catch (e) &#123;\n\n            &#x2F;&#x2F; 异常处理\n            reject(e)\n          &#125;\n        &#125;, 0)\n      &#125; else if (this.status &#x3D;&#x3D;&#x3D; REJECTED) &#123;\n\n        &#x2F;&#x2F; 状态为失败\n        setTimeout(() &#x3D;&gt; &#123;\n          try &#123;\n\n            &#x2F;&#x2F; 失败的回调，失败可能返回新的值\n            const x &#x3D; errorCallBack(this.error)\n\n            &#x2F;&#x2F; 处理回调的返回的值\n            resolvePromise(promise, x, resolve, reject)\n          &#125; catch (e) &#123;\n\n            &#x2F;&#x2F; 异常处理\n            reject(e)\n          &#125;\n        &#125;, 0)\n      &#125; else &#123;\n\n        &#x2F;&#x2F; 异步的情况，状态还没有更改\n        &#x2F;&#x2F; 同一个 promise 的 then 方法支持多次调用，回掉中的值保持不变\n        this.successCallBack.push(() &#x3D;&gt; &#123;\n          setTimeout(() &#x3D;&gt; &#123;\n            try &#123;\n              const x &#x3D; successCallBack(this.value)\n              resolvePromise(promise, x, resolve, reject)\n            &#125; catch (e) &#123;\n              reject(e)\n            &#125;\n          &#125;, 0)\n        &#125;)\n        this.errorCallBack.push(() &#x3D;&gt; &#123;\n          setTimeout(() &#x3D;&gt; &#123;\n            try &#123;\n              const x &#x3D; errorCallBack(this.error)\n              resolvePromise(promise, x, resolve, reject)\n            &#125; catch (e) &#123;\n              reject(e)\n            &#125;\n          &#125;, 0)\n        &#125;)\n      &#125;\n    &#125;)\n\n    &#x2F;&#x2F; then 返回一个新的 MyPromise 对象\n    return promise\n  &#125;\n\n  &#x2F;**\n   * 构造一个成功的 MyPromise 对象\n   * @param value 包装的值\n   * @return &#123;MyPromise&#125;\n   *&#x2F;\n  static resolve(value) &#123;\n\n    &#x2F;&#x2F; 如果值是一个 MyPromise 对象，则返回原有的值\n    if (value instanceof MyPromise) &#123;\n      return value\n    &#125;\n\n    &#x2F;&#x2F; 否则返回一个新的 MyPromise 对象\n    return new MyPromise(resolve &#x3D;&gt; resolve(value))\n  &#125;\n\n  &#x2F;**\n   * 失败回调的别名\n   * @param errorCallback 失败回调方法\n   * @return &#123;MyPromise&#125;\n   *&#x2F;\n  catch(errorCallback) &#123;\n\n    &#x2F;&#x2F; 成功回调设置为 undefined 即可\n    return this.then(undefined, errorCallback)\n  &#125;\n\n  &#x2F;**\n   * 无论什么状态，都会调用的方法，返回一个新的 MyPromise 对象\n   * @param callback 回调\n   * @return &#123;MyPromise&#125;\n   *&#x2F;\n  finally(callback) &#123;\n    return this.then(value &#x3D;&gt; &#123;\n      return MyPromise.resolve(callback()).then(() &#x3D;&gt; value)\n    &#125;, err &#x3D;&gt; &#123;\n      return MyPromise.resolve(callback()).then(() &#x3D;&gt; &#123;\n        throw err\n      &#125;)\n    &#125;)\n  &#125;\n\n  &#x2F;**\n   * 把一个数组中的每个值都转为 MyPromise 对象，并且执行，按照原有的顺序返回值\n   * @param arr 数组对象\n   * @return &#123;MyPromise&#125;\n   *&#x2F;\n  static all(arr) &#123;\n    const result &#x3D; []\n    let index &#x3D; 0\n\n    &#x2F;&#x2F; 返回一个新的 MyPromise 对象\n    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;\n\n      &#x2F;**\n       * 添加执转换后的值\n       * @param key\n       * @param value\n       *&#x2F;\n      function addData(key, value) &#123;\n        result[key] &#x3D; value\n        index++\n\n        &#x2F;&#x2F; 判断是否都已经执行完毕\n        if (index &#x3D;&#x3D;&#x3D; arr.length) &#123;\n          resolve(result)\n        &#125;\n      &#125;\n\n      for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n\n        &#x2F;&#x2F; 获取数组中的值\n        const current &#x3D; arr[i]\n        if (current instanceof MyPromise) &#123;\n\n          &#x2F;&#x2F; 如果是 MyPromise 对象\n          current.then(value &#x3D;&gt; addData(i, value), err &#x3D;&gt; reject(err))\n        &#125; else &#123;\n\n          &#x2F;&#x2F; 如果是普通的对象\n          addData(i, arr[i])\n        &#125;\n      &#125;\n    &#125;)\n  &#125;\n&#125;\n\n&#x2F;**\n * 处理回调的值\n * @param promise 新的 MyPromise 对象\n * @param x 回调的值\n * @param resolve 成功调用\n * @param reject 失败调用\n * @return &#123;*&#125;\n *&#x2F;\nfunction resolvePromise(promise, x, resolve, reject) &#123;\n\n  &#x2F;&#x2F; 判断新的 MyPromise 对象是否 和回调的 MyPromise 是同一个对象\n  if (promise &#x3D;&#x3D;&#x3D; x) &#123;\n    return reject(new TypeError(&#39;Chaining cycle detected for promise #&lt;Promise&gt;&#39;))\n  &#125;\n  if (x instanceof MyPromise) &#123;\n\n    &#x2F;&#x2F; 如果是一个新的 MyPromise 对象\n    x.then(resolve, reject)\n  &#125; else &#123;\n    resolve(x)\n  &#125;\n&#125;\n\nmodule.exports &#x3D; MyPromise\n</code></pre>\n\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const MyPromise &#x3D; require(&#39;MyPromise&#39;)\n\nconst pomise &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;\n  resolve(100)\n&#125;)\n\n&#x2F;&#x2F; 重复调用 then\npomise.then(res &#x3D;&gt; &#123;\n  console.log(res)\n&#125;)\n\n&#x2F;&#x2F; 链式调用\npromise.then(res &#x3D;&gt; &#123;\n  console.loe(res)\n  return 100\n&#125;)\n  .then(res &#x3D;&gt; &#123;\n    console.log(res)\n  &#125;)\n  .catch(err &#x3D;&gt; &#123;\n    console.log(err)\n  &#125;)\n\n&#x2F;&#x2F; all 方法\nMyPromise.all([1, 2, new MyPromise((r, j) &#x3D;&gt; r(100)), 3])\n  .then(res &#x3D;&gt; &#123;\n    console.log(res)\n  &#125;)\n</code></pre>\n","text":"MyPromise&#x2F;&#x2F; 状态状态 const PENDING &#x3D; &#39;PENDING&#39; &#x2F;&#x2F; 成功状态 const FULFILLED &#x3D; &#39;FULFILLED&#39; &#x2F;&#x2F; ...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":9,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","count":14,"path":"api/tags/JAVASCRIPT.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MyPromise\"><span class=\"toc-text\">MyPromise</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">使用方法</span></a></li></ol></li></ol>","author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}},"mapped":true,"prev_post":{"title":"gitlab-runner","uid":"8c7191ccbfefacf8736e1c2ac855bf1e","slug":"gitlabRunner","date":"2021-12-17T06:30:00.000Z","updated":"2022-09-28T07:19:23.109Z","comments":true,"path":"api/articles/gitlabRunner.json","keywords":null,"cover":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211217142322091.png","text":"gitlab-runnermac下安装 gitlab-runner其他系统可以参照官方文档gitlab runner install brew install gitlab-runner brew services start gitlab-runner .gitlab-ci.y...","link":"","photos":[],"count_time":{"symbolsCount":906,"symbolsTime":"1 mins."},"categories":[{"name":"教程","slug":"教程","count":5,"path":"api/categories/教程.json"}],"tags":[{"name":"GITLAB","slug":"GITLAB","count":1,"path":"api/tags/GITLAB.json"}],"author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}}},"next_post":{"title":"javascript asynchronous(未完成)","uid":"12f35e821d0385fb0185ca26a956309f","slug":"asynchronousJavascript","date":"2021-12-12T15:00:00.000Z","updated":"2022-09-28T07:19:23.106Z","comments":true,"path":"api/articles/asynchronousJavascript.json","keywords":null,"cover":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211212224316297.png","text":"JavaScript AsynchronousJavaScript 执行方法同步模式和异步模式 Synchronous （同步模式） console.log(&#39;global begin&#39;) function bar() &#123; console.log(&#3...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":9,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","count":14,"path":"api/tags/JAVASCRIPT.json"}],"author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}}}}