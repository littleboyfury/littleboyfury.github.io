{"title":"ECMAScript 2015 新特性","uid":"511aed350b5ec3b2d451257538725c66","slug":"ecmascript2015","date":"2021-12-31T03:30:00.000Z","updated":"2022-09-28T07:19:23.107Z","comments":true,"path":"api/articles/ecmascript2015.json","keywords":null,"cover":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211212224316297.png","content":"<h1 id=\"ECMAScript-2015-新特性\"><a href=\"#ECMAScript-2015-新特性\" class=\"headerlink\" title=\"ECMAScript 2015 新特性\"></a>ECMAScript 2015 新特性</h1><h2 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h2><ul>\n<li>let 声明的成员只会在所声明的块中生效</li>\n</ul>\n<p>如果使用 var 声明变量，可以正常输出，var 关键字有变量提升的过程</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (true) &#123;\n  var foo &#x3D; &#39;foo&#39;\n  console.log(foo)\n&#125;\n\nconsole.log(foo)</code></pre>\n\n<p>如果使用 let 声明变量，外层调用就会报错</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">if (true) &#123;\n  let foo &#x3D; &#39;foo&#39;\n  console.log(foo)\n&#125;\n\n&#x2F;&#x2F; ReferenceError: foo is not defined\nconsole.log(foo)</code></pre>\n\n<ul>\n<li>let 在 for 循环中的表现</li>\n</ul>\n<p>如果使用 var 声明</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">for (var i &#x3D; 0; i &lt; 3; i++) &#123;\n  for (var i &#x3D; 0; i &lt; 3; i++) &#123;\n    console.log(i)\n  &#125;\n  console.log(&#39;内层结束 i &#x3D; &#39; + i)\n&#125;\n\n&#x2F;&#x2F; 0\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 内层结束 i &#x3D; 3</code></pre>\n\n<p>如果使用 let 声明，能正常的得到想要的 9 次输出</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">for (let i &#x3D; 0; i &lt; 3; i++) &#123;\n  for (let i &#x3D; 0; i &lt; 3; i++) &#123;\n    console.log(i)\n  &#125;\n  console.log(&#39;内层结束 i &#x3D; &#39; + i)\n&#125;\n\n&#x2F;&#x2F; 0\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 内层结束 i &#x3D; 0\n&#x2F;&#x2F; 0\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 内层结束 i &#x3D; 1\n&#x2F;&#x2F; 0\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 内层结束 i &#x3D; 2</code></pre>\n\n<ul>\n<li>let 应用场景：循环绑定事件，事件处理函数中获取正确索引</li>\n</ul>\n<p>使用 var 作为循环声明</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var elements &#x3D; [&#123;&#125;, &#123;&#125;, &#123;&#125;]\n\nfor (var i &#x3D; 0; i &lt; elements.length; i++) &#123;\n  elements[i].onclick &#x3D; function () &#123;\n    console.log(i)\n  &#125;\n&#125;\n\nelements[1].onclick()\n&#x2F;&#x2F; 不管调用哪一个事件，输出都是3</code></pre>\n\n<p>使用闭包来解决变量提升的问题</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var elements &#x3D; [&#123;&#125;, &#123;&#125;, &#123;&#125;]\n\nfor (var i &#x3D; 0; i &lt; elements.length; i++) &#123;\n  elements[i].onclick &#x3D; (function (i) &#123;\n    return function () &#123;\n      console.log(i)\n    &#125;\n  &#125;)(i)\n&#125;\n\nelements[1].onclick()</code></pre>\n\n<p>使用 let 可以避免这种问题</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var elements &#x3D; [&#123;&#125;, &#123;&#125;, &#123;&#125;]\n\nfor (let i &#x3D; 0; i &lt; elements.length; i++) &#123;\n  elements[i].onclick &#x3D; function () &#123;\n    console.log(i)\n  &#125;\n&#125;\n\nelements[1].onclick()</code></pre>\n\n<ul>\n<li>for 循环中有两层作用域</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">for (let i &#x3D; 0; i &lt; 3; i++) &#123;\n  let i &#x3D; &#39;foo&#39;\n  console.log(i)\n&#125;\n\n&#x2F;&#x2F; foo\n&#x2F;&#x2F; foo\n&#x2F;&#x2F; foo\n\n&#x2F;&#x2F; for 循环类似代码\nlet i &#x3D; 0\nif (i &lt; 3) &#123;\n  let i &#x3D; &#39;foo&#39;\n  console.log(i)\n&#125;\ni++\nif (i &lt; 3) &#123;\n  let i &#x3D; &#39;foo&#39;\n  console.log(i)\n&#125;\ni++\nif (i &lt; 3) &#123;\n  let i &#x3D; &#39;foo&#39;\n  console.log(i)\n&#125;\ni++</code></pre>\n\n<ul>\n<li>let 修复了变量声明提升现象</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(foo)\nvar foo &#x3D; &#39;foo&#39;\n\nconsole.log(foo1)\nlet foo1 &#x3D; &#39;foo1&#39;\n\n&#x2F;&#x2F; var 输出\n&#x2F;&#x2F; undefined\n\n&#x2F;&#x2F; let 输出\n&#x2F;&#x2F; ReferenceError: Cannot access &#39;foo1&#39; before initialization</code></pre>\n\n<h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><p>const 声明的变量不允许重新赋值</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const name &#x3D; &#39;name&#39;\n\nname &#x3D; &#39;name1&#39;\n\n&#x2F;&#x2F; TypeError: Assignment to constant variable.</code></pre>\n\n<p>const 声明的变量要求声明并且同时赋值</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const name\nname &#x3D; &#39;name&#39;\n\n&#x2F;&#x2F; SyntaxError: Missing initializer in const declaration</code></pre>\n\n<p>const 声明只是要求指向不允许被改变，但是可以修改数据内成员</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123;&#125;\nobj.name &#x3D; &#39;name&#39;\nconsole.log(obj)\nobj &#x3D; &#123;&#125;\n\n&#x2F;&#x2F; &#123; name: &#39;name&#39; &#125;\n&#x2F;&#x2F; TypeError: Assignment to constant variable.</code></pre>\n\n<h2 id=\"let-和-const-注意\"><a href=\"#let-和-const-注意\" class=\"headerlink\" title=\"let 和 const 注意\"></a>let 和 const 注意</h2><ol>\n<li>let 和 const 声明的变量，在全局作用域下不会被挂在到全局对象中，浏览器为 window，node 为 global</li>\n</ol>\n<p><img src=\"https://skyfuryblog.oss-cn-guangzhou.aliyuncs.com/img/1651030467488.png\"></p>\n<ol start=\"2\">\n<li>ReferenceError 引用错误与暂存死区</li>\n</ol>\n<p>let 和 const 一致</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(b) &#x2F;&#x2F; Uncaught ReferenceError: b is not defined\n\n&#x2F;&#x2F; 以上的区域为暂存死区\nlet b &#x3D; 1</code></pre>\n\n<h2 id=\"Array-解构\"><a href=\"#Array-解构\" class=\"headerlink\" title=\"Array 解构\"></a>Array 解构</h2><ul>\n<li>获取每一样，单独定义变量</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [100, 200, 300]\n\nconst foo &#x3D; arr[0]\nconst bar &#x3D; arr[1]\nconst baz &#x3D; arr[2]\nconsole.log(foo, bar, baz)\n&#x2F;&#x2F; 100 200 300</code></pre>\n\n<ul>\n<li>可以使用解构的方式获取每一项的值</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [100, 200, 300]\n\n&#x2F;&#x2F; 解构\nconst [foo, bar, baz] &#x3D; arr\nconsole.log(foo, bar, baz)\n\n&#x2F;&#x2F; 100 200 300</code></pre>\n\n<ul>\n<li>可以只获取某一个位置的值</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [100, 200, 300]\n\nconst [, , baz] &#x3D; arr\nconsole.log(baz)\n\n&#x2F;&#x2F; 300</code></pre>\n\n<ul>\n<li>剩余参数</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [100, 200, 300]\n\nconst [foo, ...rest] &#x3D; arr\nconsole.log(rest)\n\n&#x2F;&#x2F; [ 200, 300 ]</code></pre>\n\n<ul>\n<li>如果超过了数组返回这是 undefined</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [100, 200, 300]\n\nconst [foo, bar, baz, more] &#x3D; arr\nconsole.log(more)\n&#x2F;&#x2F; undefined</code></pre>\n\n<ul>\n<li>添加默认值</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [100, 200, 300]\n\nconst [foo, bar, baz &#x3D; 123, more &#x3D; &#39;default value&#39;] &#x3D; arr\nconsole.log(baz, more)\n&#x2F;&#x2F; 300 default value</code></pre>\n\n<ul>\n<li>应用</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const path &#x3D; &#39;&#x2F;foo&#x2F;bar&#x2F;baz&#39;\nconst [, rootdir] &#x3D; path.split(&#39;&#x2F;&#39;)\nconsole.log(rootdir)\n\n&#x2F;&#x2F; foo</code></pre>\n\n<h2 id=\"object\"><a href=\"#object\" class=\"headerlink\" title=\"object\"></a>object</h2><h3 id=\"object-解构\"><a href=\"#object-解构\" class=\"headerlink\" title=\"object 解构\"></a>object 解构</h3><ul>\n<li>对象解构</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123;name: &#39;sky&#39;, age: 18&#125;\nconst &#123;name&#125; &#x3D; obj\nconsole.log(name)\n&#x2F;&#x2F; sky</code></pre>\n\n<ul>\n<li>对象解构重命名</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123;name: &#39;sky&#39;, age: 18&#125;\nconst &#123;name: objName&#125; &#x3D; obj\nconsole.log(objName)\n&#x2F;&#x2F; sky</code></pre>\n\n<ul>\n<li>默认值</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123;name: &#39;sky&#39;, age: 18&#125;\nconst &#123;name: objName &#x3D; &#39;jack&#39;, name1: objName1 &#x3D; &#39;jack1&#39;&#125; &#x3D; obj\nconsole.log(objName, objName1)\n&#x2F;&#x2F; sky jack1</code></pre>\n\n<ul>\n<li>应用</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const &#123;log&#125; &#x3D; console\nlog(&#39;foo&#39;)\nlog(&#39;bar&#39;)\nlog(&#39;123&#39;)\n&#x2F;&#x2F; foo\n&#x2F;&#x2F; bar\n&#x2F;&#x2F; 123</code></pre>\n\n<h3 id=\"对象字面量\"><a href=\"#对象字面量\" class=\"headerlink\" title=\"对象字面量\"></a>对象字面量</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const bar &#x3D; &#39;345&#39;\n\nconst obj &#x3D; &#123;\n  foo: 123,\n\n  &#x2F;&#x2F; bar: bar\n  &#x2F;&#x2F; 属性名与变量名相同，可以省略 : bar\n  bar,\n\n  &#x2F;&#x2F; 方法可以省略 : funtion\n  method1: function () &#123;\n    consle.log(&#39;method1&#39;)\n    &#x2F;&#x2F; 这种方法就是普通的函数，同样影响 this 指向，指向当前对象\n    console.log(this, &#39;method1&#39;)\n  &#125;,\n\n  method2() &#123;\n    console.log(&#39;method2&#39;)\n    &#x2F;&#x2F; 这种方法就是普通的函数，同样影响 this 指向，指向当前对象\n    conosle.log(this, &#39;method2&#39;)\n  &#125;,\n\n  &#x2F;&#x2F; 123: 12 不允许\n  &#x2F;&#x2F; 允许键是一个变量，但是只能是字符串\n  [bar]: 123,\n&#125;\n\nobj.method1()\nobj.method2()\nconsole.log(obj)</code></pre>\n\n<h3 id=\"Object-assign-方法\"><a href=\"#Object-assign-方法\" class=\"headerlink\" title=\"Object.assign 方法\"></a>Object.assign 方法</h3><p>Object.assign(target, …args)<br>将 target 后面多个对象合并到 target 中，相同的属性将会被覆盖</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const source1 &#x3D; &#123;\n  a: 123,\n  b: 123,\n&#125;\n\nconst source2 &#x3D; &#123;\n  b: 789,\n  c: 789\n&#125;\n\nconst target &#x3D; &#123;\n  a: 456,\n  c: 456\n&#125;\n\nconst result &#x3D; Object.assign(target, source1, source2)\nconsole.log(result)\nconsole.log(result &#x3D;&#x3D;&#x3D; target)\n&#x2F;&#x2F; &#123; a: 123, c: 789, b: 789 &#125;\n&#x2F;&#x2F; true</code></pre>\n\n<p>应用：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function fun(obj) &#123;\n  &#x2F;&#x2F; 这种方法会更改外面传入的对象\n  &#x2F;&#x2F; obj.name &#x3D; &#39;func obj&#39;\n  &#x2F;&#x2F; console.log(obj)\n\n  &#x2F;&#x2F; 达到复制对象的目的\n  const funcObj &#x3D; Object.assign(&#123;&#125;, obj)\n  funcObj.name &#x3D; &#39;func obj&#39;\n  console.log(funcObj)\n&#125;\n\nconst obj &#x3D; &#123;name: &#39;global obj&#39;&#125;\nfunc(obj)\nconsole.log(obj)\n&#x2F;&#x2F; &#123; name: &#39;func obj&#39; &#125;\n&#x2F;&#x2F; &#123; name: &#39;global obj&#39; &#125;</code></pre>\n\n<h3 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is\"></a>Object.is</h3><p>Object.is 可以判断 +0 和 -0 NaN</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(0 &#x3D;&#x3D; false)\nconsole.log(0 &#x3D;&#x3D;&#x3D; false)\nconsole.log(+0 &#x3D;&#x3D;&#x3D; -0)\nconsole.log(NaN &#x3D;&#x3D;&#x3D; NaN)\nconsole.log(Object.is(+0, -0))\nconsole.log(Object.is(NaN, NaN))\n\n&#x2F;&#x2F; true\n&#x2F;&#x2F; false\n&#x2F;&#x2F; true\n&#x2F;&#x2F; false\n&#x2F;&#x2F; false\n&#x2F;&#x2F; true</code></pre>\n\n<h2 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h2><h3 id=\"模版字符串\"><a href=\"#模版字符串\" class=\"headerlink\" title=\"模版字符串\"></a>模版字符串</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const str &#x3D; &#96;hello es2015&#96;\nconsole.log(str)\n&#x2F;&#x2F; hello es2015\n\n&#x2F;&#x2F; 允许换行\nconst str1 &#x3D; &#96;\nhello es2015,\nhello\nthis is a \\&#96;string\\&#96;\n&#96;\nconsole.log(str1)\n&#x2F;&#x2F; hello es2015,\n&#x2F;&#x2F; hello\n&#x2F;&#x2F; this is a &#96;string&#96;\n\nconst name &#x3D; &#39;tom&#39;\n&#x2F;&#x2F; 可以通过 $&#123;&#125; 插入表达式，表达式执行的结果将会输出到对应的位置\nconst msg &#x3D; &#96;hey, $&#123;name&#125; --- $&#123;1 + 3&#125; --- $&#123;Math.random()&#125;&#96;\nconsole.log(msg)\n&#x2F;&#x2F; hey, tom --- 4 --- 0.7121610722271636</code></pre>\n\n<h3 id=\"带标签的模版字符串\"><a href=\"#带标签的模版字符串\" class=\"headerlink\" title=\"带标签的模版字符串\"></a>带标签的模版字符串</h3><p>模版字符串的标签就是一个特殊的函数，使用这个标签就是调用这个函数</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; const str &#x3D; console.log&#96;hello world&#96;\n\nconst name &#x3D; &#39;tom&#39;\nconst gender &#x3D; false\n\nfunction myTagFunc(strings, name, gender) &#123;\n  &#x2F;&#x2F; strings 是以 $&#123;&#125; 为间隔分割字符串的值，可以自定义处理字符串的返回\n  console.log(strings, name, gender)\n  const sex &#x3D; gender ? &#39;man&#39; : &#39;woman&#39;\n  return strings[0] + name + strings[1] + sex + strings[2]\n&#125;\n\nconst result &#x3D; myTagFunc&#96;hey, $&#123;name&#125; is a $&#123;gender&#125;&#96;\nconsole.log(result)\n&#x2F;&#x2F; [ &#39;hey, &#39;, &#39; is a &#39;, &#39;&#39; ] tom false\n&#x2F;&#x2F; hey, tom is a woman</code></pre>\n\n<h3 id=\"扩展方法\"><a href=\"#扩展方法\" class=\"headerlink\" title=\"扩展方法\"></a>扩展方法</h3><ul>\n<li>includes</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const message &#x3D; &#39;Error: foo is not defined.&#39;\nconsole.log(message.startsWith(&#39;Error&#39;))\nconsole.log(message.endsWith(&#39;.&#39;))\nconsole.log(message.includes(&#39;foo&#39;))\n&#x2F;&#x2F; true\n&#x2F;&#x2F; true\n&#x2F;&#x2F; true</code></pre>\n\n<h2 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h2><h3 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function foo(enable) &#123;\n  enable &#x3D; enable &#x3D;&#x3D;&#x3D; undefined ? true : false\n  console.log(&#39;foo invoked - enable: &#39;, enable)\n&#125;\n\nfoo()\nfoo(true)\n&#x2F;&#x2F; foo invoked - enable:  true\n&#x2F;&#x2F; foo invoked - enable:  false\n\n&#x2F;&#x2F; 默认值参数一定要在形参列表的最后\nfunction foo1(enable &#x3D; true) &#123;\n  console.log(&#39;foo invoked - enable: &#39;, enable)\n&#125;\n\nfoo1()\nfoo1(false)\n&#x2F;&#x2F; foo invoked - enable:  true\n&#x2F;&#x2F; foo invoked - enable:  false</code></pre>\n\n<h3 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function foo() &#123;\n  console.log(arguments)\n&#125;\n\nfunction foo1(first, ...args) &#123;\n  console.log(first, args)\n&#125;\n\nfoo(1, 2, 3)\nfoo1(1, 2, 3, 4)\n&#x2F;&#x2F; [arguments] &#123; &#39;0&#39;: 1, &#39;1&#39;: 2, &#39;2&#39;: 3 &#125;\n&#x2F;&#x2F; 1 [ 2, 3, 4 ]</code></pre>\n\n<h3 id=\"展开数组参数\"><a href=\"#展开数组参数\" class=\"headerlink\" title=\"展开数组参数\"></a>展开数组参数</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [1, 2, 3]\nconsole.log(arr[0], arr[1], arr[2])\nconsole.log.apply(console, arr)\nconsole.log(...arr)\n&#x2F;&#x2F; 1 2 3\n&#x2F;&#x2F; 1 2 3\n&#x2F;&#x2F; 1 2 3</code></pre>\n\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function inc(num) &#123;\n  return num + 1\n&#125;\n\nconst inc1 &#x3D; n &#x3D;&gt; n + 1\n\nconsole.log(inc(1))\nconsole.log(inc1(2))\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 3\n\n&#x2F;&#x2F; 完成参数列表，函数体多条语句，返回值仍需 return\n\nconst add &#x3D; (n1, n2) &#x3D;&gt; &#123;\n  console.log(n1, n2)\n  return n1 + n2\n&#125;\n\nconsole.log(add(1, 3))\n&#x2F;&#x2F; 1 3\n&#x2F;&#x2F; 4\n\n&#x2F;&#x2F; 应用\n\nconst arr &#x3D; [1, 2, 3, 4, 5]\nconsole.log(arr.filter(i &#x3D;&gt; i % 2))\n&#x2F;&#x2F; [ 1, 3, 5 ]</code></pre>\n\n<h3 id=\"箭头函数与-this\"><a href=\"#箭头函数与-this\" class=\"headerlink\" title=\"箭头函数与 this\"></a>箭头函数与 this</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const person &#x3D; &#123;\n  name: &#39;tom&#39;,\n\n  sayHi: function () &#123;\n    console.log(&#39;hi, my name is &#39;, this.name)\n  &#125;,\n\n  sayHi1: () &#x3D;&gt; &#123;\n    console.log(&#39;hi, my name is &#39;, this.name)\n  &#125;,\n\n  sayHiAsync: function () &#123;\n    const _this &#x3D; this\n    setTimeout(function () &#123;\n      console.log(this.name, &#39;setTimeout&#39;)\n      console.log(_this.name, &#39;setTimeout1&#39;)\n    &#125;, 1000)\n\n    console.log(this.name, &#39;sayHiAsync&#39;)\n\n    setTimeout(() &#x3D;&gt; &#123;\n      console.log(this.name, &#39;setTimeout2&#39;)\n    &#125;, 1000)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; sayHi 是由 person 调用，而且不是箭头函数，所以 this 指向了调用者\nperson.sayHi()\n&#x2F;&#x2F; hi, my name is  tom\n\n&#x2F;&#x2F; sayHi1 是由 person 调用，但是是箭头函数，this 指向了父级作用域，则是 window，window 中没有 name 属性，所以打印 undefined\nperson.sayHi1()\n&#x2F;&#x2F; hi, my name is  undefined\n\n&#x2F;&#x2F; 第一个 setTimeout 中的 this，由于不是箭头函数，这个回调函数是在 setTimeout 中执行，则 this 指向了 Timeout 对象，这里可以理解为 setTimeout 中是由 Timeout 对象调用了 callback 函数\n&#x2F;&#x2F; 第二个 this，指向了 sayHiAsync 调用者，即 person\n&#x2F;&#x2F; 第三个 setTimeout 中的 this，由于是箭头函数，则 this 指向上一层作用域，则也是 person 对象\nperson.sayHiAsync()\n&#x2F;&#x2F; tom sayHiAsync\n&#x2F;&#x2F; undefined setTimeout\n&#x2F;&#x2F; tom setTimeout1\n&#x2F;&#x2F; tom setTimeout2</code></pre>\n\n<h2 id=\"Proxy-对象\"><a href=\"#Proxy-对象\" class=\"headerlink\" title=\"Proxy 对象\"></a>Proxy 对象</h2><p>const p = new Proxy(target, handler)</p>\n<p>target: 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理） handler:<br>一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</p>\n<table>\n<thead>\n<tr>\n<th>handler ⽅法</th>\n<th>触发方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>get</td>\n<td>读取某个属性</td>\n</tr>\n<tr>\n<td>set</td>\n<td>写入某个属性</td>\n</tr>\n<tr>\n<td>has</td>\n<td>in 操作符</td>\n</tr>\n<tr>\n<td>deleteProperty</td>\n<td>delete 操作符</td>\n</tr>\n<tr>\n<td>getProperty</td>\n<td>Object.getPrototypeOf()</td>\n</tr>\n<tr>\n<td>setProperty</td>\n<td>Object.setPrototypeOf()</td>\n</tr>\n<tr>\n<td>isExtensible</td>\n<td>Object.isExtensible()</td>\n</tr>\n<tr>\n<td>preventExtensions</td>\n<td>Object.preventExtensions()</td>\n</tr>\n<tr>\n<td>getOwnPropertyDescriptor</td>\n<td>Object.getOwnPropertyDescriptor()</td>\n</tr>\n<tr>\n<td>defineProperty</td>\n<td>Object.defineProperty()</td>\n</tr>\n<tr>\n<td>ownKeys</td>\n<td>Object.keys(), Object.getOwnPropertyNames(), Object.getOwnPropertySymbols()</td>\n</tr>\n<tr>\n<td>apply</td>\n<td>调用一个函数</td>\n</tr>\n<tr>\n<td>construct</td>\n<td>用 new 调用一个函数</td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const person &#x3D; &#123;\n  name: &#39;name&#39;,\n  age: 20\n&#125;\n\nconst personProxy &#x3D; new Proxy(person, &#123;\n  &#x2F;&#x2F; 监视属性读取\n  get(target, property) &#123;\n    console.log(target, property)\n    return property in target ? target[property] : &#39;default&#39;\n  &#125;,\n\n  &#x2F;&#x2F; 监听属性设置 \n  set(target, property, value) &#123;\n    if (property &#x3D;&#x3D;&#x3D; &#39;age&#39;) &#123;\n      if (!Number.isInteger(value)) &#123;\n        throw new TypeError(&#96;$&#123;value&#125; is not an int number&#96;)\n      &#125;\n    &#125;\n\n    target[property] &#x3D; value\n  &#125;,\n&#125;)\n\nconsole.log(personProxy.name)\npersonProxy.age &#x3D; 30\nconsole.log(personProxy)\nconsole.log(person)\n&#x2F;&#x2F; &#123; name: &#39;name&#39;, age: 20 &#125; name\n&#x2F;&#x2F; name\n&#x2F;&#x2F; &#123; name: &#39;name&#39;, age: 30 &#125;\n&#x2F;&#x2F; &#123; name: &#39;name&#39;, age: 30 &#125;</code></pre>\n\n<p>对比 Proxy 与 Object.defineProperty()</p>\n<ul>\n<li>优势1：Proxy 可以监听读写以外的操作</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const person &#x3D; &#123;\n  name: &#39;name&#39;,\n  age: 10\n&#125;\n\nconst personProxy &#x3D; new Proxy(person, &#123;\n  deleteProperty(target, property) &#123;\n    console.log(&#39;delete&#39;, property)\n    delete target[property]\n  &#125;\n&#125;)\n\ndelete personProxy.age\nconsole.log(person)\n&#x2F;&#x2F; delete age\n&#x2F;&#x2F; &#123; name: &#39;name&#39; &#125;</code></pre>\n\n<ul>\n<li>优势2： Proxy 可以很方便的监听数组操作</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const list &#x3D; []\n\nconst listProxy &#x3D; new Proxy(list, &#123;\n  &#x2F;&#x2F; 数组也可以理解为一个对象，下标就是对应键，还有一个 length 属性的键\n  &#x2F;&#x2F; &#123;\n  &#x2F;&#x2F;   0: 1\n  &#x2F;&#x2F;   1: 2\n  &#x2F;&#x2F;   length: 2\n  &#x2F;&#x2F; &#125;\n  set(target, property, value) &#123;\n    console.log(&#39;set&#39;, property, value)\n    target[property] &#x3D; value\n    &#x2F;&#x2F; 表示设置成功，否则会报错\n    return true\n  &#125;\n&#125;)\n\nlistProxy.push(1)\nlistProxy.push(2)\n&#x2F;&#x2F; set 0 1\n&#x2F;&#x2F; set length 1\n&#x2F;&#x2F; set 1 2\n&#x2F;&#x2F; set length 2</code></pre>\n\n<ul>\n<li>优势3： Proxy 不需要侵入对象</li>\n</ul>\n<p>Object.defineProperty 用法</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const person &#x3D; &#123;&#125;\n\nObject.defineProperty(person, &#39;name&#39;, &#123;\n  get() &#123;\n    console.log(&#39;get name&#39;)\n    return person._name\n  &#125;,\n  set(value) &#123;\n    console.log(&#39;set name&#39;)\n    person._name &#x3D; value\n  &#125;\n&#125;)\n\nObject.defineProperty(person, &#39;age&#39;, &#123;\n  get() &#123;\n    console.log(&#39;get age&#39;)\n    return person._age\n  &#125;,\n  set(value) &#123;\n    console.log(&#39;set age&#39;)\n    person._age &#x3D; value\n  &#125;\n&#125;)\n\nperson.name &#x3D; &#39;name&#39;\nperson.age &#x3D; 20\nconsole.log(person)\n&#x2F;&#x2F; set name\n&#x2F;&#x2F; set age\n&#x2F;&#x2F; &#123; _name: &#39;name&#39;, _age: 20 &#125;</code></pre>\n\n<p>Proxy 用法</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const person &#x3D; &#123;&#125;\nconst personProxy &#x3D; new Proxy(person, &#123;\n  get(target, property) &#123;\n    console.log(&#39;get&#39;, property)\n    return target[property]\n  &#125;,\n  set(target, property, value) &#123;\n    console.log(&#39;set&#39;, property, value)\n    target[property] &#x3D; value\n  &#125;\n&#125;)\n\npersonProxy.name &#x3D; &#39;name&#39;\npersonProxy.age &#x3D; 18\nconsole.log(person)\n&#x2F;&#x2F; set name name\n&#x2F;&#x2F; set age 18\n&#x2F;&#x2F; &#123; name: &#39;name&#39;, age: 18 &#125;</code></pre>\n\n<h2 id=\"Reflect-对象\"><a href=\"#Reflect-对象\" class=\"headerlink\" title=\"Reflect 对象\"></a>Reflect 对象</h2><p>Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handlers 的方法相同。<br>Reflect不是一个函数对象，因此它是不可构造的。 Reflect 对象提供了以下静态方法，这些方法与proxy handler methods<br>的命名相同.</p>\n<table>\n<thead>\n<tr>\n<th>Proxy handler ⽅法</th>\n<th>默认调用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>get</td>\n<td>Reflect.get()</td>\n</tr>\n<tr>\n<td>set</td>\n<td>Reflect.set()</td>\n</tr>\n<tr>\n<td>has</td>\n<td>Reflect.has()</td>\n</tr>\n<tr>\n<td>deleteProperty</td>\n<td>Reflect.delete()</td>\n</tr>\n<tr>\n<td>getProperty</td>\n<td>Reflect.getPrototypeOf()</td>\n</tr>\n<tr>\n<td>setProperty</td>\n<td>Reflect.setPrototypeOf()</td>\n</tr>\n<tr>\n<td>isExtensible</td>\n<td>Reflect.isExtensible()</td>\n</tr>\n<tr>\n<td>preventExtensions</td>\n<td>Reflect.preventExtensions()</td>\n</tr>\n<tr>\n<td>getOwnPropertyDescriptor</td>\n<td>Reflect.getOwnPropertyDescriptor()</td>\n</tr>\n<tr>\n<td>defineProperty</td>\n<td>Reflect.defineProperty()</td>\n</tr>\n<tr>\n<td>ownKeys</td>\n<td>Reflect.ownKeys()</td>\n</tr>\n<tr>\n<td>apply</td>\n<td>Reflect.apply()</td>\n</tr>\n<tr>\n<td>construct</td>\n<td>Reflect.construct()</td>\n</tr>\n</tbody></table>\n<ul>\n<li>结合 Proxy 使用</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123;\n  foo: &#39;123&#39;,\n  bar: &#39;456&#39;,\n&#125;\n\nconst proxy &#x3D; new Proxy(obj, &#123;\n  get(target, property) &#123;\n    console.log(&#39;watch logic ~&#39;)\n    &#x2F;&#x2F; Proxy 默认实现\n    return Reflect.get(target, property)\n  &#125;\n&#125;)\n\nconsole.log(proxy)\nconsole.log(proxy.foo)\n&#x2F;&#x2F; &#123; foo: &#39;123&#39;, bar: &#39;456&#39; &#125;\n&#x2F;&#x2F; watch logic ~\n&#x2F;&#x2F; 123</code></pre>\n\n<ul>\n<li>独立使用</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123;\n  name: &#39;name&#39;,\n  age: 18\n&#125;\n\nconsole.log(Reflect.has(obj, &#39;name&#39;))\nconsole.log(Reflect.deleteProperty(obj, &#39;age&#39;))\nconsole.log(Reflect.ownKeys(obj))\n&#x2F;&#x2F; true\n&#x2F;&#x2F; true\n&#x2F;&#x2F; [ &#39;name&#39; ]</code></pre>\n\n<h2 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h2><h3 id=\"新增-class-关键字来定义类\"><a href=\"#新增-class-关键字来定义类\" class=\"headerlink\" title=\"新增 class 关键字来定义类\"></a>新增 class 关键字来定义类</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Person &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name\n  &#125;\n\n  say() &#123;\n    console.log(&#39;hi, my name is&#39;, this.name)\n  &#125;\n&#125;\n\nconst p &#x3D; new Person(&#39;tom&#39;)\np.say()\n\n&#x2F;&#x2F; hi, my name is tom</code></pre>\n\n<h3 id=\"static-静态方法\"><a href=\"#static-静态方法\" class=\"headerlink\" title=\"static 静态方法\"></a>static 静态方法</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Person &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name\n  &#125;\n\n  say() &#123;\n    console.log(&#39;hi, my name is&#39;, this.name)\n  &#125;\n\n  static create(name) &#123;\n    return new Person(name)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 可以使用类名直接调用\nconst p &#x3D; Person.create(&#39;tom&#39;)\np.say()\n&#x2F;&#x2F; hi, my name is tom</code></pre>\n\n<h3 id=\"extends-类继承\"><a href=\"#extends-类继承\" class=\"headerlink\" title=\"extends 类继承\"></a>extends 类继承</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Person &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name\n  &#125;\n\n  say() &#123;\n    console.log(&#39;hi, my name is&#39;, this.name)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 通过 extends 继承 Person 的属性和方法\nclass Student extends Person &#123;\n  constructor(name, number) &#123;\n    &#x2F;&#x2F; 通过 super 调用父类的构造方法\n    super(name)\n    this.number &#x3D; number\n  &#125;\n\n  hello() &#123;\n    &#x2F;&#x2F; 通过 super 调用父类的 方法\n    super.say()\n    console.log(&#39;my school number is&#39;, this.number)\n  &#125;\n&#125;\n\nconst s &#x3D; new Student(&#39;jack&#39;, 100)\ns.hello()\n&#x2F;&#x2F; hi, my name is jack\n&#x2F;&#x2F; my school number is 100</code></pre>\n\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><ul>\n<li>基本用法</li>\n</ul>\n<p>Set 数据结构，保存唯一的数据，对象类型无法去重相同的值，对象类型是根据地址判断是否重复</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const s &#x3D; new Set()\n\ns.add(1).add(2).add(3).add(4).add(2)\nconsole.log(s)\n&#x2F;&#x2F; Set(3) &#123; 1, 2, 3 &#125;\n\n&#x2F;&#x2F; 遍历\ns.forEach(i &#x3D;&gt; console.log(i))\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 3\n&#x2F;&#x2F; 4\nfor (let i of s) &#123;\n  console.log(i)\n&#125;\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 3\n&#x2F;&#x2F; 4\n\nconsole.log(s.size)\n&#x2F;&#x2F; 输出 set 中的长度 4\n\nconsole.log(s.has(100))\nconsole.log(s.has(2))\n&#x2F;&#x2F; 判断是否有值\n&#x2F;&#x2F; false\n&#x2F;&#x2F; true\n\nconsole.log(s.delete(2))\n&#x2F;&#x2F; 删除一个值，成功返回 true\nconsole.log(s)\n&#x2F;&#x2F; Set(3) &#123; 1, 3, 4 &#125;\n\n&#x2F;&#x2F; 清空 set\ns.clear()\nconsole.log(s)\n&#x2F;&#x2F;  Set(0) &#123;&#125;\n</code></pre>\n\n<ul>\n<li>使用场景</li>\n</ul>\n<p>数组去重</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [1, 2, 1, 3, 4, 1]\nconsole.log(Array.from(new Set(arr)))\nconsole.log([...new Set(arr)])</code></pre>\n\n<ul>\n<li>WeakSet 和 Set</li>\n</ul>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet\">WeakSet</a></p>\n<ol>\n<li>弱引用版本 WeakSet</li>\n<li>差异就是 Set 中会对使用到的数据产生引用</li>\n<li>即便这是数据在外面被消耗，但是由于 Set 引用了这个数据，所以依然不会回收</li>\n<li>而 WeakSet 的特点就是不产生引用</li>\n<li>一旦数据摧毁，就可以被回收，所以不会产生内存泄漏的问题。</li>\n</ol>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><ul>\n<li>Map 和 Object 区别</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123;&#125;\nobj[true] &#x3D; &#39;value&#39;\nobj[123] &#x3D; &#39;value&#39;\nobj[&#123;a: 1&#125;] &#x3D; &#39;value1&#39;\nobj[&#123;a: 2&#125;] &#x3D; &#39;value2&#39;\nconsole.log(obj)\nconsole.log(Object.keys(obj))\n\n&#x2F;&#x2F; 对象类型会把所有的 key 变为 字符串\n&#x2F;&#x2F; &#123; &#39;123&#39;: &#39;value&#39;, true: &#39;value&#39;, &#39;[object Object]&#39;: &#39;value2&#39; &#125;\n&#x2F;&#x2F; [ &#39;123&#39;, &#39;true&#39;, &#39;[object Object]&#39; ]</code></pre>\n<ul>\n<li>Map 可以设置任意类型的 key，不会被转为 字符串</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const m &#x3D; new Map()\n\nconst tom &#x3D; &#123;name: &#39;tom&#39;&#125;\nm.set(tom, 90)\nm.set(tom, 91)\nm.set(&#123;name: &#39;tom&#39;&#125;, 92)\nconsole.log(m)\n&#x2F;&#x2F; Map(2) &#123; &#123; name: &#39;tom&#39; &#125; &#x3D;&gt; 91, &#123; name: &#39;tom&#39; &#125; &#x3D;&gt; 92 &#125;\n\nconsole.log(m.get(tom))\n&#x2F;&#x2F; 91\n\nconsole.log(m.get(&#123;name: &#39;tom&#39;&#125;))\n&#x2F;&#x2F; undefined\n\nconsole.log(m.has(tom))\n&#x2F;&#x2F; true\n\nconsole.log(m.delete(tom))\n&#x2F;&#x2F; true\n\nconsole.log(m.clear())\n&#x2F;&#x2F; undefined\n\nconsole.log(m)\n&#x2F;&#x2F; Map(0) &#123;&#125;\n\nm.set(1, 1)\nm.set(true, true)\nm.set(&#39;key&#39;, &#39;value&#39;)\n&#x2F;&#x2F; Map(3) &#123; 1 &#x3D;&gt; 1, true &#x3D;&gt; true, &#39;key&#39; &#x3D;&gt; &#39;value&#39; &#125;\n\n&#x2F;&#x2F; Map 遍历\nm.forEach((value, key) &#x3D;&gt;&#123;\n  console.log(value, key)\n&#125;)\n&#x2F;&#x2F; 1 1\n&#x2F;&#x2F; true true\n&#x2F;&#x2F; value key\n</code></pre>\n\n<ul>\n<li>WeakMap 和 Map</li>\n</ul>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\">WeakMap</a></p>\n<ol>\n<li>弱引用版本 WeakMap</li>\n<li>差异就是 Map 中会对所使用到的数据产生引用</li>\n<li>即便这个数据在外面被消耗，但是由于 Map 引用了这个数据，所以依然不会回收</li>\n<li>而 WeakMap 的特点就是不会产生引用，</li>\n<li>一旦数据销毁，就可以被回收，所以不会产生内存泄漏问题。</li>\n</ol>\n<h2 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h2><p>Symbol 是一个基本类型，创建出来的对象永远不会相等</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const s &#x3D; Symbol()\n\nconsole.log(s)\nconsole.log(typeof s)\n\n&#x2F;&#x2F; Symbol()\n&#x2F;&#x2F; symbol\n\nconsole.log(Symbol() &#x3D;&#x3D;&#x3D; Symbol())\n&#x2F;&#x2F; false\n\n&#x2F;&#x2F; 添加文字描述\nconsole.log(Symbol(&#39;foo&#39;))\nconsole.log(Symbol(&#39;bar&#39;))\nconsole.log(Symbol(&#39;baz&#39;))\n\n&#x2F;&#x2F; Symbol(foo)\n&#x2F;&#x2F; Symbol(bar)\n&#x2F;&#x2F; Symbol(baz)\n\n&#x2F;&#x2F; 使用 Symbol 为对象添加不重复的键\n\nconst obj &#x3D; &#123;&#125;\nobj[Symbol()] &#x3D; &#39;123&#39;\nobj[Symbol()] &#x3D; &#39;456&#39;\nconsole.log(obj)\n&#x2F;&#x2F; &#123; [Symbol()]: &#39;123&#39;, [Symbol()]: &#39;456&#39; &#125;\n\n&#x2F;&#x2F; 使用计算属性名添加\n\nconst obj &#x3D; &#123;\n  [Symbol()]: 123\n&#125;\n\nconsole.log(obj)\n&#x2F;&#x2F; &#123; [Symbol()]: 123 &#125;</code></pre>\n\n<ul>\n<li>案例 Symbol 模拟实现私有成员</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; a.js &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nconst name &#x3D; Symbol()\nconst person  &#x3D; &#123;\n  [name]: &#39;name&#39;,\n  say () &#123;\n    console.log(this[name])\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 只对外暴露 person\n&#x2F;&#x2F; b.js &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&#x2F;**\n * 由于无法创建出一样的 Symbol 值\n * 所以无法直接访问到 person 中的 [私有] 成员\n * person[Symbol()]\n *&#x2F;\nperson.say()</code></pre>\n\n<ul>\n<li>Symbol 补充</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(Symbol() &#x3D;&#x3D;&#x3D; Symbol())\nconsole.log(Symbol(&#39;foo&#39;) &#x3D;&#x3D;&#x3D; Symbol(&#39;foo&#39;))\n&#x2F;&#x2F; false\n&#x2F;&#x2F; false</code></pre>\n\n<ul>\n<li>Symbol 全局注册表</li>\n</ul>\n<p>可以根据 Symbol.for 注册一个 Symbol 对象，这样通过 Symbol.for 得到的对象就是同一个对象</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const s1 &#x3D; Symbol.for(&#39;foo&#39;)\nconst s2 &#x3D; Symbol.for(&#39;foo&#39;)\nconsole.log(s1 &#x3D;&#x3D;&#x3D; s2)\nconsole.log(Symbol.for(true) &#x3D;&#x3D;&#x3D; Symbol.for(true))\n&#x2F;&#x2F; true\n&#x2F;&#x2F; true</code></pre>\n\n<ul>\n<li>Symbol 内置常量</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(Symbol.iterator)\n&#x2F;&#x2F; Symbol(Symbol.iterator)\n\nconsole.log(Symbol.hasInstance)\n&#x2F;&#x2F; Symbol(Symbol.hasInstance)\n\nconst obj &#x3D; &#123;\n  [Symbol.toStringTag]: &#39;xObject&#39;\n&#125;\nconsole.log(obj.toString())\n&#x2F;&#x2F; [object xObject]</code></pre>\n\n<ul>\n<li>Symbol 属性名获取</li>\n</ul>\n<p>使用 for JSON.stringify 或者 Object.keys 都无法获取到 Symbol 的 key 和 value，<br>Symbol 的 key 只能通过 Object.getOwnPropertySymbols() 获取</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123;\n  [Symbol()]: &#39;symbol value&#39;,\n  foo: &#39;normal value&#39;\n&#125;\n\nfor( const key in obj) &#123;\n  console.log(key)\n&#125;\n&#x2F;&#x2F; foo\n\nconsole.log(Object.keys(obj))\n&#x2F;&#x2F; [ &#39;foo&#39; ]\n\nconsole.log(JSON.stringify(obj))\n&#x2F;&#x2F; &#123;&quot;foo&quot;:&quot;normal value&quot;&#125;\n\nconsole.log(Object.getOwnPropertySymbols(obj))\n&#x2F;&#x2F; [ Symbol() ]\n</code></pre>\n\n<h2 id=\"for-of-循环\"><a href=\"#for-of-循环\" class=\"headerlink\" title=\"for of 循环\"></a>for of 循环</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [100, 200, 300, 400]\nfor (const item of arr) &#123;\n  console.log(item)\n&#125;\n&#x2F;&#x2F; 100\n&#x2F;&#x2F; 200\n&#x2F;&#x2F; 300\n&#x2F;&#x2F; 400\n\n&#x2F;&#x2F; for ... of  循环可以替代数组对象的 forEach 方法\narr.forEach(item &#x3D;&gt; &#123;\n  console.log(item)\n&#125;)\n&#x2F;&#x2F; 100\n&#x2F;&#x2F; 200\n&#x2F;&#x2F; 300\n&#x2F;&#x2F; 400\n\n&#x2F;&#x2F; forEach 无法跳出循环，必须使用 some 或者 every 方法\n&#x2F;&#x2F; for ... of 可以使用 break\n\nfor(const item of arr) &#123;\n  console.log(item)\n  if (item &gt; 100) &#123;\n    break\n  &#125;\n&#125;\n&#x2F;&#x2F; 100\n&#x2F;&#x2F; 200\n\n&#x2F;&#x2F; forEach 不能跳出循环\narr.forEach()\narr.some()\narr.every()\n\n&#x2F;&#x2F; 遍历 set 和遍历数组相同\nconst s &#x3D; new Set([&#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;])\nfor (const item of s) &#123;\n  console.log(item)\n&#125;\n&#x2F;&#x2F; foo\n&#x2F;&#x2F; bar\n\n&#x2F;&#x2F; 遍历 Map 可以配合数组解构语法，直接获取键值对\nconst m &#x3D; new Map()\nm.set(&#39;foo&#39;, &#39;123&#39;)\nm.set(&#39;bar&#39;, &#39;345&#39;)\nfor(const [key, value] of m) &#123;\n  console.log(key, value)\n&#125;\n&#x2F;&#x2F; foo 123\n&#x2F;&#x2F; bar 345\n\n&#x2F;&#x2F; 普通对象不能直接被 for ... of 遍历\nconst obj &#x3D; &#123;foo: 123, bar: 456&#125;\nfor (const item of obj) &#123;\n  console.log(item)\n&#125;\n&#x2F;&#x2F; for(const item of obj) &#123;\n&#x2F;&#x2F; ^\n&#x2F;&#x2F;\n&#x2F;&#x2F; TypeError: obj is not iterable\n</code></pre>\n\n<h2 id=\"Iterator-迭代器\"><a href=\"#Iterator-迭代器\" class=\"headerlink\" title=\"Iterator 迭代器\"></a>Iterator 迭代器</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const set &#x3D; new Set([&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;])\n\n&#x2F;&#x2F; 获取 Set 中的迭代器\nconst iterator &#x3D; set[Symbol.iterator]()\nwhile(true) &#123;\n  &#x2F;&#x2F; 获取当前元素\n  const current &#x3D; iterator.next()\n  &#x2F;&#x2F; 判断是否遍历完成\n  if (current.done) &#123;\n    break\n  &#125;\n  &#x2F;&#x2F; 打印结果\n  console.log(current.value)\n&#125;\n&#x2F;&#x2F; foo\n&#x2F;&#x2F; bar\n&#x2F;&#x2F; baz</code></pre>\n\n<h2 id=\"Iterable-实现可迭代接口\"><a href=\"#Iterable-实现可迭代接口\" class=\"headerlink\" title=\"Iterable 实现可迭代接口\"></a>Iterable 实现可迭代接口</h2><p>实现 Iterable 接口，需要在对象中新增 Symbol.iterator 属性</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123;\n  &#x2F;&#x2F; 新增 Symbol.iterator key，返回 next 对象\n  [Symbol.iterator]: function () &#123;\n    return &#123;\n      next: function () &#123;\n        return &#123;\n          &#x2F;&#x2F; next 返回值 包含 value 和 done\n          value: &#39;name&#39;,\n          done: true\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\nconsole.log(obj)</code></pre>\n\n<ul>\n<li>案例</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123;\n  store: [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;],\n  &#x2F;&#x2F; 实现 Iterable 接口\n  [Symbol.iterator]: function () &#123;\n    let index &#x3D; 0\n    &#x2F;&#x2F; 这里的 this 指向 当前对象\n    const self &#x3D; this\n    return &#123;\n      &#x2F;&#x2F; 返回 next()\n      next: function () &#123;\n        &#x2F;&#x2F; 这里的 this 指向 Symbol.iterator 中 return 的对象\n        const result &#x3D; &#123;\n          &#x2F;&#x2F; next() 返回 value 和 done\n          value: self.store[index],\n          done: index &gt;&#x3D; self.store.length\n        &#125;\n        index++\n        return result\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\nfor (const item of obj) &#123;\n  console.log(item)\n&#125;\n&#x2F;&#x2F; foo\n&#x2F;&#x2F; bar\n&#x2F;&#x2F; baz</code></pre>\n\n<h2 id=\"Iterator-pattern-迭代器模式\"><a href=\"#Iterator-pattern-迭代器模式\" class=\"headerlink\" title=\"Iterator-pattern 迭代器模式\"></a>Iterator-pattern 迭代器模式</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 场景：遍历多个任务清单\nconst todo &#x3D; &#123;\n  life: [&#39;eating&#39;, &#39;sleeping&#39;, &#39;hitting Bean&#39;],\n  learn: [&#39;chinese&#39;, &#39;math&#39;, &#39;english&#39;],\n  work: [&#39;tea&#39;],\n\n  &#x2F;&#x2F; 提供一个统一遍历的方法\n  each: function (callback) &#123;\n    const all &#x3D; [].concat(this.life, this.learn, this.work)\n    for (const item of all) &#123;\n      callback(item)\n    &#125;\n  &#125;,\n\n  &#x2F;&#x2F; 或者使用迭代器模式 （ES2015 统一遍历访问接口）\n  [Symbol.iterator]: function () &#123;\n    const all &#x3D; [...this.life, ...this.learn, ...this.work]\n    let index &#x3D; 0\n    return &#123;\n      next: function () &#123;\n        return &#123;\n          value: all[index],\n          done: index++ &gt;&#x3D; all.length\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\ntodo.each(i &#x3D;&gt; console.log(i))\n\nfor(const item of todo) &#123;\n  console.log(item)\n&#125;\n</code></pre>\n\n<h2 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function * foo () &#123;\n  console.log(&#39;111&#39;)\n  yield 100\n  console.log(&#39;222&#39;)\n  yield 200\n  console.log(&#39;333&#39;)\n  yield 300\n&#125;\n\nconst generator &#x3D; foo()\n\n&#x2F;&#x2F; 第一次调用， 函数题开始执行，遇到第一个 yield 暂停\nconsole.log(generator.next())\n&#x2F;&#x2F; 第二次调用，从暂停位置继续，知道遇到下一个 yield 再次暂停\nconsole.log(generator.next())\n&#x2F;&#x2F; 。。。\nconsole.log(generator.next())\n&#x2F;&#x2F; 第四次调用，已经没有需要执行的内容，所以 value 得到了 undefined\nconsole.log(generator.next())\n&#x2F;&#x2F; &#123; value: 100, done: false &#125;\n&#x2F;&#x2F; 222\n&#x2F;&#x2F; &#123; value: 200, done: false &#125;\n&#x2F;&#x2F; 333\n&#x2F;&#x2F; &#123; value: 300, done: false &#125;\n&#x2F;&#x2F; &#123; value: undefined, done: true &#125;</code></pre>\n\n<ul>\n<li>案例一：发号器</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function* createId() &#123;\n  let id &#x3D; 1\n  while (true) &#123;\n    yield id++\n  &#125;\n&#125;\n\nconst idMaker &#x3D; createId()\n\nconsole.log(idMaker.next().value)\nconsole.log(idMaker.next().value)\nconsole.log(idMaker.next().value)\nconsole.log(idMaker.next().value)\nconsole.log(idMaker.next().value)\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 3\n&#x2F;&#x2F; 4\n&#x2F;&#x2F; 5</code></pre>\n\n<ul>\n<li>案例二：使用 generator 实现 iterator 方法</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const todo &#x3D; &#123;\n  life: [&#39;eating&#39;, &#39;sleeping&#39;, &#39;hitting Bean&#39;],\n  learn: [&#39;chinese&#39;, &#39;math&#39;, &#39;english&#39;],\n  work: [&#39;tea&#39;],\n\n  &#x2F;&#x2F; Generator 正好返回 value 和 done 类型的值，正好符合迭代器\n  [Symbol.iterator]: function* () &#123;\n    const all &#x3D; [...this.life, ...this.learn, ...this.work]\n    for (const item of all) &#123;\n      yield item\n    &#125;\n  &#125;\n&#125;\n\nfor (const item of todo) &#123;\n  console.log(item)\n&#125;\n&#x2F;&#x2F; sleeping\n&#x2F;&#x2F; hitting Bean\n&#x2F;&#x2F; chinese\n&#x2F;&#x2F; math\n&#x2F;&#x2F; english\n&#x2F;&#x2F; tea</code></pre>\n","text":"ECMAScript 2015 新特性let let 声明的成员只会在所声明的块中生效 如果使用 var 声明变量，可以正常输出，var 关键字有变量提升的过程 if (true) &#123; var foo &#x3D; &#39;foo&#39; console.log(f...","link":"","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"26 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":9,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","count":14,"path":"api/tags/JAVASCRIPT.json"},{"name":"ECMASCRIPT","slug":"ECMASCRIPT","count":5,"path":"api/tags/ECMASCRIPT.json"},{"name":"ES6","slug":"ES6","count":1,"path":"api/tags/ES6.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ECMAScript-2015-%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">ECMAScript 2015 新特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#let\"><span class=\"toc-text\">let</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#const\"><span class=\"toc-text\">const</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#let-%E5%92%8C-const-%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">let 和 const 注意</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Array-%E8%A7%A3%E6%9E%84\"><span class=\"toc-text\">Array 解构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#object\"><span class=\"toc-text\">object</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#object-%E8%A7%A3%E6%9E%84\"><span class=\"toc-text\">object 解构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F\"><span class=\"toc-text\">对象字面量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-assign-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Object.assign 方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-is\"><span class=\"toc-text\">Object.is</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#string\"><span class=\"toc-text\">string</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E7%89%88%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">模版字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E7%89%88%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">带标签的模版字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">扩展方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Function\"><span class=\"toc-text\">Function</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%BB%98%E8%AE%A4%E5%80%BC\"><span class=\"toc-text\">默认值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">剩余参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%95%E5%BC%80%E6%95%B0%E7%BB%84%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">展开数组参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">箭头函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E-this\"><span class=\"toc-text\">箭头函数与 this</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Proxy-%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">Proxy 对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Reflect-%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">Reflect 对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#class\"><span class=\"toc-text\">class</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%A2%9E-class-%E5%85%B3%E9%94%AE%E5%AD%97%E6%9D%A5%E5%AE%9A%E4%B9%89%E7%B1%BB\"><span class=\"toc-text\">新增 class 关键字来定义类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#static-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">static 静态方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#extends-%E7%B1%BB%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">extends 类继承</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Set\"><span class=\"toc-text\">Set</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Map\"><span class=\"toc-text\">Map</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Symbol\"><span class=\"toc-text\">Symbol</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#for-of-%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">for of 循环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">Iterator 迭代器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Iterable-%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%BF%AD%E4%BB%A3%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">Iterable 实现可迭代接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Iterator-pattern-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">Iterator-pattern 迭代器模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Generator\"><span class=\"toc-text\">Generator</span></a></li></ol></li></ol>","author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}},"mapped":true,"prev_post":{"title":"ECMAScript 2017 新特性","uid":"d318e18e99918ad61da8e565bf7bdfdc","slug":"ecmascript2017","date":"2022-01-04T16:00:00.000Z","updated":"2022-09-28T07:19:23.107Z","comments":true,"path":"api/articles/ecmascript2017.json","keywords":null,"cover":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211212224316297.png","text":"ECMAScript 2017 新特性Object.values输出对象的值 const obj &#x3D; &#123; foo: &#39;value1&#39;, bar: &#39;value2&#39;, &#125; console.log(Object.value...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":9,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","count":14,"path":"api/tags/JAVASCRIPT.json"},{"name":"ECMASCRIPT","slug":"ECMASCRIPT","count":5,"path":"api/tags/ECMASCRIPT.json"}],"author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}}},"next_post":{"title":"JavaScript 系列","uid":"076515ed99fa4d813b6007ee6d9ea2b4","slug":"javascriptSeries","date":"2021-12-31T03:30:00.000Z","updated":"2022-09-28T07:19:23.110Z","comments":true,"path":"api/articles/javascriptSeries.json","keywords":null,"cover":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211212224316297.png","text":"JavaScript 系列编程挑战ProgrammingChallenge 函数式编程FunctionalProgramming 简单 Promise 实现MyPromise ES2015 新特性ES2015 新特性 ES2016 新特性ES2016 新特性 ES2017 新特性...","link":"","photos":[],"count_time":{"symbolsCount":171,"symbolsTime":"1 mins."},"categories":[{"name":"编程","slug":"编程","count":3,"path":"api/categories/编程.json"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","count":14,"path":"api/tags/JAVASCRIPT.json"},{"name":"ECMASCRIPT","slug":"ECMASCRIPT","count":5,"path":"api/tags/ECMASCRIPT.json"}],"author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}},"feature":true}}