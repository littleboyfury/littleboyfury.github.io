{"title":"javascript asynchronous(未完成)","uid":"12f35e821d0385fb0185ca26a956309f","slug":"asynchronousJavascript","date":"2021-12-12T15:00:00.000Z","updated":"2022-09-28T07:19:23.106Z","comments":true,"path":"api/articles/asynchronousJavascript.json","keywords":null,"cover":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211212224316297.png","content":"<h1 id=\"JavaScript-Asynchronous\"><a href=\"#JavaScript-Asynchronous\" class=\"headerlink\" title=\"JavaScript Asynchronous\"></a>JavaScript Asynchronous</h1><h2 id=\"JavaScript-执行方法\"><a href=\"#JavaScript-执行方法\" class=\"headerlink\" title=\"JavaScript 执行方法\"></a>JavaScript 执行方法</h2><h3 id=\"同步模式和异步模式\"><a href=\"#同步模式和异步模式\" class=\"headerlink\" title=\"同步模式和异步模式\"></a>同步模式和异步模式</h3><ul>\n<li>Synchronous （同步模式）</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(&#39;global begin&#39;)\n\nfunction bar() &#123;\n  console.log(&#39;bar task&#39;)\n&#125;\n\nfunction foo() &#123;\n  console.log(&#39;foo task&#39;)\n  bar()\n&#125;\n\nfoo()\nconsole.log(&#39;global end&#39;)</code></pre>\n\n<ul>\n<li>Asynchronous （异步模式）</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(&#39;global begin&#39;)\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;timer1 invoke&#39;)\n&#125;, 1800)\n\nsetTimeout(() &#x3D;&gt; &#123;\n  consle.log(&#39;timer2 invoke&#39;)\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;inner invoke&#39;)\n  &#125;, 1000)\n&#125;, 1000)\n\nconsole.log(&#39;global end&#39;)</code></pre>\n\n<h3 id=\"事件循环与消息队列\"><a href=\"#事件循环与消息队列\" class=\"headerlink\" title=\"事件循环与消息队列\"></a>事件循环与消息队列</h3><p><img src=\"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211212235521443.png\" alt=\"image-20211212235521443\"></p>\n<h3 id=\"异步编程的几种方式\"><a href=\"#异步编程的几种方式\" class=\"headerlink\" title=\"异步编程的几种方式\"></a>异步编程的几种方式</h3><h4 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function foo(callback) &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    callback()\n  &#125;, 3000)\n&#125;\n\nfoo(() &#x3D;&gt; &#123;\n  console.log(&#39;这就是一个回调函数&#39;)\n  console.log(&#39;调用者定义这个函数，执行者执行这个函数&#39;)\n  console.log(&#39;其实就是调用者告诉执行者异步任务结束后应该做什么&#39;)\n&#125;)</code></pre>\n\n<h3 id=\"Promise-异步方案、宏任务-微任务队列\"><a href=\"#Promise-异步方案、宏任务-微任务队列\" class=\"headerlink\" title=\"Promise 异步方案、宏任务/微任务队列\"></a>Promise 异步方案、宏任务/微任务队列</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 回调地狱，只是示例，不能运行\n\n$.get(&#39;&#x2F;url1&#39;, function (data1) &#123;\n  $.get(&#39;&#x2F;url2&#39;, data1, function (data2) &#123;\n    $.get(&#39;&#x2F;url3&#39;, data2, function (data3) &#123;\n      $.get(&#39;&#x2F;url4&#39;, data3, function (data4) &#123;\n        $.get(&#39;&#x2F;url5&#39;, data4, function (data5) &#123;\n          $.get(&#39;&#x2F;url6&#39;, data5, function (data6) &#123;\n            $.get(&#39;&#x2F;url7&#39;, data6, function (data7) &#123;\n              &#x2F;&#x2F; 略微夸张了一点点\n            &#125;)\n          &#125;)\n        &#125;)\n      &#125;)\n    &#125;)\n  &#125;)\n&#125;)\n</code></pre>\n\n<p>Promise 的状态不可变<br><img src=\"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211213000342570.png\" alt=\"image-20211213000342570\"></p>\n<ul>\n<li>使用示例</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const promise &#x3D; new Promise((function (resolve, reject) &#123;\n  &#x2F;&#x2F; 这里用于 &quot;兑现&quot; 承诺，两个回调只有一个能生效，以先执行的为准\n  &#x2F;&#x2F; resolve(100) &#x2F;&#x2F; 承诺达成\n  reject(new Error(&#39;promise rejected&#39;)) &#x2F;&#x2F; 承诺失败\n&#125;))\n\npromise.then(value &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 即便没有异步调用，then 方法中传入的回调仍然会被放入到队列，等待下一轮执行\n  console.log(value)\n&#125;, error &#x3D;&gt; &#123;\n  console.log(&#39;rejected&#39;, error)\n&#125;)\n\nconsole.log(&#39;end&#39;)</code></pre>\n\n<ul>\n<li>Promise 方式的 AJAX</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function ajax(url) &#123;\n  return new Promise((function (resolve, reject) &#123;\n    const xhr &#x3D; new XMLHttpRequest()\n    xhr.open(&#39;GET&#39;, url)\n    xhr.responseType &#x3D; &#39;json&#39;\n    xhr.onload &#x3D; function () &#123;\n      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        resolve(this.response)\n      &#125; else &#123;\n        reject(new Error(this.statusText))\n      &#125;\n    &#125;\n    xhr.send()\n  &#125;))\n&#125;\n\najax(&#39;&#x2F;api&#x2F;urls.json&#39;)\n  .then(res &#x3D;&gt; &#123;\n    console.log(res)\n  &#125;, err &#x3D;&gt; &#123;\n    console.log(err)\n  &#125;)\n\n&#x2F;&#x2F; 嵌套使用 Promise 是常见的误区\najax(&#39;&#x2F;api&#x2F;urls.json&#39;).then(urls &#x3D;&gt; &#123;\n  ajax(urls.users).then(users &#x3D;&gt; &#123;\n    ajax(urls.users).then(users &#x3D;&gt; &#123;\n      ajax(urls.users).then(users &#x3D;&gt; &#123;\n        ajax(urls.users).then(users &#x3D;&gt; &#123;\n\n        &#125;)\n      &#125;)\n    &#125;)\n  &#125;)\n&#125;)\n\n&#x2F;&#x2F; then 中回到的 value 参数就是上一个 Promise 对象的返回值\najax(&#39;&#x2F;api&#x2F;users.json&#39;)\n  .then(value &#x3D;&gt; &#123;\n    console.log(111)\n    return ajax(&#39;&#x2F;api&#x2F;urls.json&#39;)\n  &#125;)\n  .then(value &#x3D;&gt; &#123;\n    console.log(value)\n    return ajax(&#39;&#x2F;api&#x2F;urls.json&#39;)\n  &#125;)\n  .then(value &#x3D;&gt; &#123;\n    console.log(value)\n    return ajax(&#39;&#x2F;api&#x2F;urls.json&#39;)\n  &#125;)\n  .then(value &#x3D;&gt; &#123;\n    throw new Error(&#39;test&#39;)\n    console.log(value)\n    return &#39;foo&#39;\n  &#125;)\n  .then(value &#x3D;&gt; &#123;\n    console.log(value)\n  &#125;)\n  .catch(e &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果链式调用中有一个抛出异常，错误会传递到最后一个 Promise 对象，并被 catch 捕获到\n    console.log(e)\n  &#125;)\n\n&#x2F;&#x2F; 全局异常捕获 window\nwindow.addEventListener(&#39;unhandledrejection&#39;, event &#x3D;&gt; &#123;\n  const &#123;reason, promise&#125; &#x3D; event\n  console.log(reason, promise)\n  &#x2F;&#x2F; reason &#x3D;&gt; Promise 失败的原因，一般是一个错误对象\n  &#x2F;&#x2F; promise &#x3D;&gt; 出现异常的 Promise 对象\n  event.preventDefault()\n&#125;, false)\n\n&#x2F;&#x2F; Node.js 使用以下的方式\nprocess.on(&#39;unhandledRejection&#39;, (reason, promise) &#x3D;&gt; &#123;\n  conosle.log(reason, promise)\n  &#x2F;&#x2F; reason &#x3D;&gt; Promise 失败原因，一把是一个错误对象\n  &#x2F;&#x2F; promise &#x3D;&gt; 出现异常的 Promise 对象\n&#125;)</code></pre>\n\n<ul>\n<li>Promise 中的静态方法</li>\n</ul>\n<ol>\n<li>Promise.resolve()</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function ajax(url) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    &#x2F;&#x2F; foo()\n    &#x2F;&#x2F; throw new Error()\n    var xhr &#x3D; new XMLHttpRequest()\n    xhr.open(&#39;GET&#39;, url)\n    xhr.responseType &#x3D; &#39;json&#39;\n    xhr.onload &#x3D; function () &#123;\n      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        resolve(this.response)\n      &#125; else &#123;\n        reject(new Error(this.statusText))\n      &#125;\n    &#125;\n    xhr.send()\n  &#125;)\n&#125;\n\nPromise.resolve(&#39;foo&#39;)\n  .then(value &#x3D;&gt; console.log(value))\n&#x2F;&#x2F; 如何上面等效\nnew Promise((function (resolve, reject) &#123;\n  resolve(&#39;foo&#39;)\n&#125;))\n\nconst promise &#x3D; ajax(&#39;&#x2F;api&#x2F;users.json&#39;)\nconst promise2 &#x3D; Promise.resolve(promise)\nconsole.log(promise &#x3D;&#x3D;&#x3D; promise2)\n&#x2F;&#x2F; &#x3D;&gt; true\n\n&#x2F;&#x2F; 如果传入一个根 Promise 一样的 then 方法对象\n&#x2F;&#x2F; Promise.resolve 会将这个对象作为 Promise 执行\n\nPromise.resolve(&#123;\n  then: function (onfulfilled, onrejected) &#123;\n    onfulfilled(&#39;foo&#39;)\n  &#125;\n&#125;)\n  .then(value &#x3D;&gt; &#123;\n    console.log(value)\n  &#125;)</code></pre>\n\n<ol start=\"2\">\n<li>Promise.reject()</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; Promise.reject 传入任何值，都会作为这个 Promise失败的理由\nPromise.reject(new Error(&#39;rejected&#39;))\n  .catch(e &#x3D;&gt; &#123;\n    console.log(e)\n  &#125;)\n\nPromise.reject(&#39;anything&#39;)\n  .catch(e &#x3D;&gt; &#123;\n    console.log(e)\n  &#125;)</code></pre>\n\n<ol start=\"3\">\n<li>Promise.all()</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 将多个 Promise 组合为一个新的 Promise, all() 需要全部都执行成功才算成功\nconst promise &#x3D; Promise.all([\n  ajax(&#39;&#x2F;api&#x2F;users.json&#39;),\n  ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)\n])\n\n&#x2F;&#x2F; value 返回的是一个数组，是每个 Promise 执行后的结果\npromise.then(value &#x3D;&gt; &#123;\n  console.log(value)\n&#125;)\n  .catch(e &#x3D;&gt; &#123;\n    console.log(e)\n  &#125;)\n\n\najax(&#39;&#x2F;api&#x2F;urls.json&#39;)\n  .then(value &#x3D;&gt; &#123;\n    const urls &#x3D; Object.values(value)\n    const tasks &#x3D; urls.map(url &#x3D;&gt; ajax(url))\n    return Promise.all(tasks)\n  &#125;)\n  .then(values &#x3D;&gt; console.log(values))</code></pre>\n\n<ol start=\"4\">\n<li>Promise.race()</li>\n</ol>\n<p>只要有一个成功则 Promise 成功</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const request &#x3D; ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)\nconst timeout &#x3D; new Promise((function (resolve, reject) &#123;\n  setTimeout(() &#x3D;&gt; reject(new Error(&#39;timeout&#39;), 500))\n&#125;))\n\nPromise.race([\n  request,\n  timeout\n])\n  .then(value &#x3D;&gt; &#123;\n    console.log(value)\n  &#125;)\n  .catch(err &#x3D;&gt; &#123;\n    console.log(err)\n  &#125;)</code></pre>\n\n<ol start=\"5\">\n<li>宏任务和微任务</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">console.log(&#39;global start&#39;)\n\n&#x2F;&#x2F; setTimeout 的回调是宏任务，进入回调队列排队\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;setTimeout&#39;)\n&#125;, 0)\n\n&#x2F;&#x2F; Promise 的回调是微任务，本来调用末尾直接执行\nPromise.resolve()\n  .then(() &#x3D;&gt; &#123;\n    console.log(&#39;promise&#39;)\n  &#125;)\n  .then(() &#x3D;&gt; &#123;\n    console.log(&#39;promise1&#39;)\n  &#125;)\nconsole.log(&#39;global end&#39;)</code></pre>\n\n<ol start=\"6\">\n<li>回调和链式调用</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function ajax(url, callback) &#123;\n  const executor &#x3D; (resolve, reject) &#x3D;&gt; &#123;\n    const xhr &#x3D; new XMLHttpRequest()\n    xhr.open(&#39;GET&#39;, url)\n    xhr.responseType &#x3D; &#39;json&#39;\n    xhr.onload &#x3D; () &#x3D;&gt; &#123;\n      if (xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        resolve(xhr.response)\n      &#125; else &#123;\n        reject(new Error(xhr.statusText))\n      &#125;\n    &#125;\n    xhr.send()\n  &#125;\n  if (typeof callback &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n    executor(\n      res &#x3D;&gt; callback(null, res),\n      err &#x3D;&gt; callback(err)\n    )\n  &#125;\n  return new Promise(executor)\n&#125;\n\n&#x2F;&#x2F; Callback hell\najax(&#39;&#x2F;api&#x2F;url1&#39;, (error, value) &#x3D;&gt; &#123;\n  ajax(&#39;&#x2F;api&#x2F;url1&#39;, (error, value) &#x3D;&gt; &#123;\n    ajax(&#39;&#x2F;api&#x2F;url1&#39;, (error, value) &#x3D;&gt; &#123;\n      ajax(&#39;&#x2F;api&#x2F;url1&#39;, (error, value) &#x3D;&gt; &#123;\n\n      &#125;)\n    &#125;)\n  &#125;)\n&#125;)\n\n&#x2F;&#x2F; Promise chain\najax(&#39;&#x2F;api&#x2F;url1&#39;)\n  .then(value &#x3D;&gt; &#123;\n    return ajax(&#39;&#x2F;api&#x2F;url2&#39;)\n  &#125;)\n  .then(value &#x3D;&gt; &#123;\n    return ajax(&#39;&#x2F;api&#x2F;url2&#39;)\n  &#125;)\n  .then(value &#x3D;&gt; &#123;\n    return ajax(&#39;&#x2F;api&#x2F;url2&#39;)\n  &#125;)\n  .catch(err &#x3D;&gt; &#123;\n    console.log(err)\n  &#125;)\n\n&#x2F;&#x2F; sync mode code\ntry &#123;\n  const value1 &#x3D; ajax(&#39;&#x2F;api&#x2F;url1&#39;)\n  console.log(value1)\n  const value2 &#x3D; ajax(&#39;&#x2F;api&#x2F;url1&#39;)\n  console.log(value2)\n  const value3 &#x3D; ajax(&#39;&#x2F;api&#x2F;url1&#39;)\n  console.log(value3)\n&#125; catch (e) &#123;\n  console.error(e)\n&#125; </code></pre>\n\n<h3 id=\"Generator-异步方案、Async-Await-语法糖\"><a href=\"#Generator-异步方案、Async-Await-语法糖\" class=\"headerlink\" title=\"Generator 异步方案、Async/Await 语法糖\"></a>Generator 异步方案、Async/Await 语法糖</h3><ul>\n<li>generator</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; Generator\nfunction* foo() &#123;\n  console.log(&#39;start&#39;)\n  try &#123;\n    &#x2F;&#x2F; yield 会暂停函数执行，直到外部调用 next\n    const res &#x3D; yield &#39;foo&#39;\n    console.log(res)\n  &#125; catch (e) &#123;\n    console.log(e)\n  &#125;\n&#125;\n\nconst generator &#x3D; foo()\n\n&#x2F;&#x2F; 获取 yield 的返回的值，即 foo 函数中的 &#39;foo&#39;\nconst result &#x3D; generator.next()\nconsole.log(result)\n\n&#x2F;&#x2F; next 的参数作为 yield 的返回值，即 foo 函数中的 res\ngenerator.next(&#39;bar&#39;)\n&#x2F;&#x2F; 或者可以抛出异常，foo 函数中可以捕获\ngenerator.throw(new Error(&#39;Generator error&#39;))</code></pre>\n\n<ul>\n<li>Generator 配合 Promise 的异步方案</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function ajax(url) &#123;\n  return new Promise((function (resolve, reject) &#123;\n    const xhr &#x3D; new XMLHttpRequest()\n    xhr.open(&#39;GET&#39;, url)\n    xhr.responseType &#x3D; &#39;json&#39;\n    xhr.onload &#x3D; () &#x3D;&gt; &#123;\n      if (xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        resolve(xhr.response)\n      &#125; else &#123;\n        reject(new Error(xhr.statusText))\n      &#125;\n    &#125;\n    xhr.send()\n  &#125;))\n&#125;\n\nfunction* main() &#123;\n  try &#123;\n    const users &#x3D; yield ajax(&#39;&#x2F;api&#x2F;users.json&#39;)\n    console.log(users)\n\n    const posts &#x3D; yield ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)\n    console.log(posts)\n\n    const urls &#x3D; yield ajax(&#39;&#x2F;api&#x2F;urls11.json&#39;)\n    console.log(urls)\n  &#125; catch (e) &#123;\n    console.log(e)\n  &#125;\n&#125;\n\nconst generator &#x3D; main()\n\nconst result &#x3D; generator.next()\n&#x2F;&#x2F; 可以采取递归的方式\nresult.value.then(data &#x3D;&gt; &#123;\n  const result2 &#x3D; generator.next(data)\n  if (result2.done) return\n  result2.value.then(data &#x3D;&gt; &#123;\n    const result3 &#x3D; generator.next()\n    if (result3.done) return\n    result3.value.then(data &#x3D;&gt; &#123;\n\n    &#125;)\n  &#125;)\n&#125;)\n\n&#x2F;&#x2F; 上面代码的递归形式\nfunction handleResult(result) &#123;\n  if (result.done) return\n  result.value.then(data &#x3D;&gt; &#123;\n    handleResult(generator.next(data))\n  &#125;, error &#x3D;&gt; &#123;\n    generator.throw(error)\n  &#125;)\n&#125;\n\nhandleResult(generator.next())\n\n&#x2F;&#x2F; 封装 co 函数\nfunction co(fn) &#123;\n  const g &#x3D; fn()\n\n  function handleResult(result) &#123;\n\n    &#x2F;&#x2F; 已经没有后续结果\n    if (result.done) return\n    result.value.then(data &#x3D;&gt; &#123;\n\n      &#x2F;&#x2F; 继续调用下一个 next\n      handleResult(g.next(data))\n    &#125;, error &#x3D;&gt; &#123;\n      g.throw(error)\n    &#125;)\n  &#125;\n\n  handleResult(g.next())\n&#125;\n\nco(main)</code></pre>\n\n<ul>\n<li>Async/Await 方案</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function main() &#123;\n  try &#123;\n    const users &#x3D; await ajax(&#39;&#x2F;api&#x2F;users.json&#39;)\n    console.log(users)\n\n    const posts &#x3D; await ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)\n    console.log(posts)\n\n    const urls &#x3D; await ajax(&#39;&#x2F;api&#x2F;urls11.json&#39;)\n    console.log(urls)\n  &#125; catch (e) &#123;\n    console.log(e)\n  &#125;\n&#125;\n\nconst promise &#x3D; main()\n\npromise.then(() &#x3D;&gt; &#123;\n  console.log(&#39;all completed&#39;)\n&#125;)</code></pre>\n","text":"JavaScript AsynchronousJavaScript 执行方法同步模式和异步模式 Synchronous （同步模式） console.log(&#39;global begin&#39;) function bar() &#123; console.log(&#3...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":9,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","count":14,"path":"api/tags/JAVASCRIPT.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JavaScript-Asynchronous\"><span class=\"toc-text\">JavaScript Asynchronous</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JavaScript-%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">JavaScript 执行方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">同步模式和异步模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">事件循环与消息队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">异步编程的几种方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">回调函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-%E5%BC%82%E6%AD%A5%E6%96%B9%E6%A1%88%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1-%E5%BE%AE%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97\"><span class=\"toc-text\">Promise 异步方案、宏任务&#x2F;微任务队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Generator-%E5%BC%82%E6%AD%A5%E6%96%B9%E6%A1%88%E3%80%81Async-Await-%E8%AF%AD%E6%B3%95%E7%B3%96\"><span class=\"toc-text\">Generator 异步方案、Async&#x2F;Await 语法糖</span></a></li></ol></li></ol></li></ol>","author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}},"mapped":true,"prev_post":{"title":"Promise 简写","uid":"66f57e202e85c56083a0db8b6aa3f2f8","slug":"promise","date":"2021-12-15T15:00:00.000Z","updated":"2022-09-28T07:19:23.111Z","comments":true,"path":"api/articles/promise.json","keywords":null,"cover":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211212224316297.png","text":"MyPromise&#x2F;&#x2F; 状态状态 const PENDING &#x3D; &#39;PENDING&#39; &#x2F;&#x2F; 成功状态 const FULFILLED &#x3D; &#39;FULFILLED&#39; &#x2F;&#x2F; ...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":9,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","count":14,"path":"api/tags/JAVASCRIPT.json"}],"author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}}},"next_post":{"title":"Functional Programming","uid":"f1c5db41d78c24c5668189654926ca28","slug":"functionalProgramming","date":"2021-12-10T03:00:00.000Z","updated":"2022-09-28T07:19:23.108Z","comments":true,"path":"api/articles/functionalProgramming.json","keywords":null,"cover":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211212224316297.png","text":"Functional Programming什么是函数式编程函数式编程的思维方式：把显示世界的事务和事物之间的联系抽象到程序世界（对运算过程进行抽象） 函数式编程中的函数指的数学中的函数即映射关系，输入的值对应一个输出的值，例如 y = f(x) 相同的输入始终得到相同的输出（纯...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":9,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","count":14,"path":"api/tags/JAVASCRIPT.json"}],"author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}}}}