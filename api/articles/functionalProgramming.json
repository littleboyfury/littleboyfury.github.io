{"title":"Functional Programming","uid":"f1c5db41d78c24c5668189654926ca28","slug":"functionalProgramming","date":"2021-12-10T03:00:00.000Z","updated":"2022-09-28T07:19:23.108Z","comments":true,"path":"api/articles/functionalProgramming.json","keywords":null,"cover":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211212224316297.png","content":"<h1 id=\"Functional-Programming\"><a href=\"#Functional-Programming\" class=\"headerlink\" title=\"Functional Programming\"></a>Functional Programming</h1><h2 id=\"什么是函数式编程\"><a href=\"#什么是函数式编程\" class=\"headerlink\" title=\"什么是函数式编程\"></a>什么是函数式编程</h2><p>函数式编程的思维方式：把显示世界的事务和事物之间的联系抽象到程序世界（对运算过程进行抽象）</p>\n<ul>\n<li>函数式编程中的函数指的数学中的函数即映射关系，输入的值对应一个输出的值，例如 <code>y = f(x)</code></li>\n<li>相同的输入始终得到相同的输出（纯函数）</li>\n<li>函数式编程用来描述数据（函数）之间的映射</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 非函数式\nconst num1 &#x3D; 2\nconst num2 &#x3D; 3\nconst sum &#x3D; num1 + num2\nconsole.log(sum)\n\n&#x2F;&#x2F; 函数式\nfunction add(n1, n2) &#123;\n  return n1 + n2\n&#125;\n\nconst sum &#x3D; add(2, 3)\nconsole.log(sum)</code></pre>\n\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><h3 id=\"函数式一等公民（头等函数）\"><a href=\"#函数式一等公民（头等函数）\" class=\"headerlink\" title=\"函数式一等公民（头等函数）\"></a>函数式一等公民（头等函数）</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/First-class_Function\">MDB First-class Function</a></p>\n<ul>\n<li>函数可以存储在变量中</li>\n<li>函数作为参数</li>\n<li>函数作为返回值</li>\n</ul>\n<p>在 javascript 中函数就是一个普通对象（可以通过 <code>new Function()</code>），可以把函数存储到变量或者数组中，<br>还可以当成另外一个函数的参数和返回值，甚至可以在程序运行的时候通过<code>new Function(&#39;alter(1)&#39;)</code>来构造一个新的函数。</p>\n<ul>\n<li>把函数复制给变量</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const fn &#x3D; function () &#123;\n  console.log(&#39;this is a function&#39;)\n&#125;\n\nfn()\n\n&#x2F;&#x2F; 一个示例\nconst BlogController &#x3D; &#123;\n  index(posts) &#123;\n    return Views.index(posts)\n  &#125;,\n  show(post) &#123;\n    return Views.show(post)\n  &#125;,\n  create(attrs) &#123;\n    return Db.create(attrs)\n  &#125;,\n  update(post, attrs) &#123;\n    return Db.update(post, attrs)\n  &#125;,\n  destroy(post) &#123;\n    return Db.destroy(post)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 优化\nconst BlogController &#x3D; &#123;\n  index: Views.index,\n  show: Views.show,\n  create: Db.create,\n  update: Db.update,\n  destroy: Db.destroy\n&#125;</code></pre>\n\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><h4 id=\"什么是高阶函数\"><a href=\"#什么是高阶函数\" class=\"headerlink\" title=\"什么是高阶函数\"></a>什么是高阶函数</h4><ul>\n<li>高阶函数(Higher-order function)<ul>\n<li>可以把函数作为参数传递给另一个函数</li>\n<li>可以把函数作为另一个函数的返回值</li>\n</ul>\n</li>\n<li>函数作为参数</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function forEach(array, fn) &#123;\n  for (let i &#x3D; 0; i &lt; array.length; i++) &#123;\n    fn(array[i])\n  &#125;\n&#125;\n\nfunction filter(array, fn) &#123;\n  const result &#x3D; []\n  for (let i &#x3D; 0; i &lt; array.length; i++) &#123;\n    if (fn(array[i])) &#123;\n      result.push(array[i])\n    &#125;\n  &#125;\n  return result\n&#125;\n\nconst a &#x3D; [1, 2, 3, 4, 5]\n\n\nforEach(a, v &#x3D;&gt; &#123;\n  console.log(v)\n&#125;)\n\nconst result &#x3D; filter(a, v &#x3D;&gt; &#123;\n  return v % 2 &#x3D;&#x3D;&#x3D; 0\n&#125;)\nconsole.log(result)</code></pre>\n\n<ul>\n<li>函数作为返回值</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function makeFn() &#123;\n  const msg &#x3D; &#39;Hello Function&#39;\n\n  return function () &#123;\n    console.log(msg)\n  &#125;\n&#125;\n\nconst fn &#x3D; makeFn()\nfn()\n&#x2F;&#x2F; 或者\nmakeFn()()\n\n&#x2F;&#x2F; once 函数\nfunction once(fn) &#123;\n  let done &#x3D; false\n  return function () &#123;\n    if (!done) &#123;\n      done &#x3D; true\n      return fn.apply(this, arguments)\n    &#125;\n  &#125;\n&#125;\n\nconst onceFn &#x3D; once(function (msg) &#123;\n  console.log(msg)\n&#125;)\n\nonceFn(&#39;run once&#39;)\nonceFn(&#39;run once&#39;)\nonceFn(&#39;run once&#39;)\nonceFn(&#39;run once&#39;)</code></pre>\n\n<h4 id=\"使用高阶函数的意义\"><a href=\"#使用高阶函数的意义\" class=\"headerlink\" title=\"使用高阶函数的意义\"></a>使用高阶函数的意义</h4><ul>\n<li>抽象可以屏蔽细节，只需要关注目标</li>\n<li>高阶函数式用来抽象通用问题</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\n&#x2F;&#x2F; 面向过程的方式\nconst arr &#x3D; [1, 2, 3, 4]\n\nfor (const i of arr) &#123;\n  console.log(i)\n&#125;\n\n&#x2F;&#x2F; 高阶函数\n\nconst arr &#x3D; [1, 2, 3, 4]\n\n&#x2F;&#x2F; 前面定义的函数\nforEach(arr, item &#x3D;&gt; &#123;\n  console.log(item)\n&#125;)</code></pre>\n\n<h4 id=\"常用的高阶函数\"><a href=\"#常用的高阶函数\" class=\"headerlink\" title=\"常用的高阶函数\"></a>常用的高阶函数</h4><ul>\n<li>forEach</li>\n<li>map</li>\n<li>filter</li>\n<li>every</li>\n<li>some</li>\n<li>find/findIndex</li>\n<li>reduce</li>\n<li>sort</li>\n<li>……</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const map &#x3D; (arr, fn) &#x3D;&gt; &#123;\n  const result &#x3D; []\n  for (const value of arr) &#123;\n    result.push(fn(value))\n  &#125;\n  return result\n&#125;\n\nconst every &#x3D; (arr, fn) &#x3D;&gt; &#123;\n  let result &#x3D; true\n  for (const value of arr) &#123;\n    result &#x3D; fn(value)\n    if (!result) &#123;\n      break\n    &#125;\n  &#125;\n  return result\n&#125;\n\nconst some &#x3D; (arr, fn) &#x3D;&gt; &#123;\n  let result &#x3D; false\n  for (const value of arr) &#123;\n    result &#x3D; fn(value)\n    if (result) &#123;\n      break\n    &#125;\n  &#125;\n  return result\n&#125;</code></pre>\n\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><ul>\n<li>闭包（Closure）：函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包。<ul>\n<li>可以在另一个作用域中调用一个函数的内部函数并访问该函数的作用域中的成员</li>\n</ul>\n</li>\n<li>闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为<br>被外部引用不能释放，因此内部函数依然可以访问外部函数的成员</li>\n<li>闭包案例</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function makePower(power) &#123;\n  return function (x) &#123;\n    return Math.pow(x, power)\n  &#125;\n&#125;\n\nconst power2 &#x3D; makePower(2)\nconst power3 &#x3D; makePower(3)\n\nconsole.log(power2(2))\nconsole.log(power2(3))\nconsole.log(power3(2))</code></pre>\n\n<h2 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a>纯函数</h2><h3 id=\"纯函数概念\"><a href=\"#纯函数概念\" class=\"headerlink\" title=\"纯函数概念\"></a>纯函数概念</h3><ul>\n<li>纯函数：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用<ul>\n<li>纯函数类似数学中的函数（用来描述输入和输出之间的关系），<code>y = f(x)</code></li>\n</ul>\n</li>\n<li>数组的 <code>slice</code> 和 <code>splice</code> 分别是：纯函数和不纯的函数<ul>\n<li><code>slice</code> 返回数组中的指定部分，不会改变原数组</li>\n<li><code>splice</code> 对数组进行操作返回该数组，会改变原数组</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let numbers &#x3D; [1, 2, 3, 4, 5]\n&#x2F;&#x2F; 纯函数\nnumbers.slice(0, 3)\n&#x2F;&#x2F; &#x3D;&gt; [1, 2, 3]\nnumbers.slice(0, 3)\n&#x2F;&#x2F; &#x3D;&gt; [1, 2, 3]\nnumbers.slice(0, 3)\n&#x2F;&#x2F; &#x3D;&gt; [1, 2, 3]\n\n&#x2F;&#x2F; 不纯的函数\nnumbers.splice(0, 3)\n&#x2F;&#x2F; &#x3D;&gt; [1, 2, 3]\nnumbers.splice(0, 3)\n&#x2F;&#x2F; &#x3D;&gt; [4, 5]\nnumbers.splice(0, 3)\n&#x2F;&#x2F; &#x3D;&gt; []</code></pre>\n\n<ul>\n<li>函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的）</li>\n<li>可以把一个函数的执行结果交给另一个函数去处理</li>\n</ul>\n<h3 id=\"纯函数的好处\"><a href=\"#纯函数的好处\" class=\"headerlink\" title=\"纯函数的好处\"></a>纯函数的好处</h3><ul>\n<li>可缓存<ul>\n<li>纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来</li>\n</ul>\n</li>\n<li>lodash memoize</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const _ &#x3D; require(&#39;lodash&#39;)\n\nfunction getArea(r) &#123;\n  console.log(&#39;running&#39;)\n  return Math.PI * r * r\n&#125;\n\nconst getAreaWithMemory &#x3D; _.memoize(getArea)\n\nconsole.log(getAreaWithMemory(4))\nconsole.log(getAreaWithMemory(4))\nconsole.log(getAreaWithMemory(4))</code></pre>\n\n<ul>\n<li>手动模拟</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function memoize(fn) &#123;\n  const cache &#x3D; &#123;&#125;\n  return function () &#123;\n    const key &#x3D; JSON.stringify(arguments)\n    cache[key] &#x3D; cache[key] || fn.apply(fn, arguments)\n    return cache[key]\n  &#125;\n&#125;</code></pre>\n\n<ul>\n<li>可测试<ul>\n<li>纯函数测试更方便</li>\n</ul>\n</li>\n<li>并行处理<ul>\n<li>在多线程环境下并行操作共享的内存数据很有可能会出现意外情况</li>\n<li>纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数（Web Worker）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"副作用\"><a href=\"#副作用\" class=\"headerlink\" title=\"副作用\"></a>副作用</h3><ul>\n<li>纯函数： 对于相同的输入永远会得到相同的输出，而且没有任何可观察的副作用</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 不纯的函数\nconst mini &#x3D; 18\n\nfunction checkAge(age) &#123;\n  return age &gt;&#x3D; mini\n&#125;\n\n&#x2F;&#x2F; 纯函数（但是有硬编码，不方便扩展）\nfunction checkAge(age) &#123;\n  const mini &#x3D; 18\n  return age &gt;&#x3D; mini\n&#125;</code></pre>\n\n<p>如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用。 副作用来源：</p>\n<ul>\n<li>配置文件</li>\n<li>数据库</li>\n<li>用户输入</li>\n<li>……</li>\n</ul>\n<p>所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作<br>用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控 范围内发生。</p>\n<h2 id=\"柯里化（Haskell-Brooks-Curry）\"><a href=\"#柯里化（Haskell-Brooks-Curry）\" class=\"headerlink\" title=\"柯里化（Haskell Brooks Curry）\"></a>柯里化（Haskell Brooks Curry）</h2><ul>\n<li>柯里化（Currying）：<ul>\n<li>当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）</li>\n<li>然后返回一个新的函数接受剩余的参数，返回结果</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function checkAge(age) &#123;\n  let min &#x3D; 18\n  return age &gt;&#x3D; min\n&#125;\n\n&#x2F;&#x2F; 普通纯函数\nfunction checkAge(min, age) &#123;\n  return age &gt;&#x3D; min\n&#125;\n\n&#x2F;&#x2F; 柯里化，函数闭包\nfunction checkAge(min) &#123;\n  return function (age) &#123;\n    return age &gt;&#x3D; min\n  &#125;\n&#125;\n\n&#x2F;&#x2F; ES6 写法\nconst checkAge &#x3D; min &#x3D;&gt; age &#x3D;&gt; age &gt;&#x3D; min\n\nconst checkAge18 &#x3D; checkAge(18)\nconst checkAge22 &#x3D; checkAge(22)\n\ncheckAge18(20)\ncheckAge22(20)</code></pre>\n\n<h3 id=\"lodash-中的柯里化函数\"><a href=\"#lodash-中的柯里化函数\" class=\"headerlink\" title=\"lodash 中的柯里化函数\"></a>lodash 中的柯里化函数</h3><ul>\n<li>_.curry(func)</li>\n<li>功能：创建一个函数，该函数接受一个或者多个 func 的参数，如果 func 所需要的参数都被提供 则执行 func<br>并返回执行的结果。否则继续返回该函数并等待接受剩余的参数。</li>\n<li>参数：需要柯里化的函数</li>\n<li>返回值：柯里化后的函数</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const _ &#x3D; require(&#39;lodash&#39;)\n\n&#x2F;&#x2F; 需要柯里化的函数\nfunction getSum(a, b, c) &#123;\n  return a + b + c\n&#125;\n\n&#x2F;&#x2F; 柯里化后的函数\nconst curried &#x3D; _.curry(getSum)\n\n&#x2F;&#x2F; 多种使用方式\ncurried(1, 2, 3)\ncurried(1, 2)(3)\ncurried(1)(2, 3)\ncurried(1)(2)(3)</code></pre>\n\n<ul>\n<li>案例</li>\n</ul>\n<p>查找字符数组中带有空格的项</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const _ &#x3D; require(&#39;lodash&#39;)\n\n&#x2F;&#x2F; 柯里化后的函数\nconst match &#x3D; _.curry(function (reg, str) &#123;\n  return str.match(reg)\n&#125;)\n\n&#x2F;&#x2F; 接受了一个参数\nconst haveSpace &#x3D; match(&#x2F;\\s+&#x2F;g)\nconst haveNumber &#x3D; match(&#x2F;\\d+&#x2F;g)\n\n&#x2F;&#x2F; 传入剩余参数\nconsole.log(haveSpace(&#39;hello world&#39;))\nconsole.log(haveNumber(&#39;23$&#39;))\n\n&#x2F;&#x2F; 柯里化后的函数\nconst filter &#x3D; _.curry(function (func, arr) &#123;\n  return arr.filter(func)\n&#125;)\n\n&#x2F;&#x2F; 传入全部的参数\nconsole.log(filter(haveSpace, [&#39;Hello World&#39;, &#39;hello_wordl&#39;]))\n\n&#x2F;&#x2F; 传入一个参数\nconst findSpace &#x3D; filter(haveSpace)\n\n&#x2F;&#x2F; 传入剩余的参数\nconsole.log(findSpace([&#39;hello world&#39;, &#39;hello_world&#39;]))</code></pre>\n\n<ul>\n<li>模拟 <code>_.curry()</code> 的实现</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\n&#x2F;&#x2F; 参数为需要柯里化的函数\nfunction curry(fn) &#123;\n\n  &#x2F;&#x2F; 返回的函数需要接受剩余的参数\n  return function curryFn(...args) &#123;\n\n    &#x2F;&#x2F; 如果传入的参数和函数的参数长度不一致\n    if (fn.length &gt; args.length) &#123;\n\n      &#x2F;&#x2F; 继续返回一个函数，多次柯里化\n      return function () &#123;\n\n        &#x2F;&#x2F; 将闭包中的 args 和传入的参数合并，arguments\n        return curryFn(...args.concat(Array.from(arguments)))\n      &#125;\n    &#125;\n\n    &#x2F;&#x2F; 返回执行后的值\n    return fn(...args)\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数</li>\n<li>这是一种对函数参数的缓存</li>\n<li>让函数变得更灵活，让函数的粒度更小</li>\n<li>可以把多元函数转为一元函数，可以组合使用函数产生强大的功能（一个参数的函数成为一元函数，类似数学的函数）</li>\n</ul>\n<h2 id=\"函数组合\"><a href=\"#函数组合\" class=\"headerlink\" title=\"函数组合\"></a>函数组合</h2><ul>\n<li>纯函数和柯里化很容易写出洋葱代码<code>h(g(f(x)))</code><ul>\n<li>获取数组的最后一个元素再转成大写字母，<code>_.toUpper(_.first(_.reverse(arr)))</code></li>\n</ul>\n</li>\n</ul>\n<img src=\"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211211102956846.png\" alt=\"image-20211211102956846\" style=\"zoom:50%;\" />\n\n<ul>\n<li>函数组合可以让我们把细粒度的函数重新组合生成一个新的函数</li>\n</ul>\n<h3 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h3><p>下面这张图表示程序中使用函数处理数据的过程，给 fn 函数输入参数 a，返回结果 b。可以想想 a 数据 通过一个管道得到了 b 数据。</p>\n<p><img src=\"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211211103212323.png\" alt=\"image-20211211103212323\"></p>\n<p>当 fn 函数比较复杂的时候，我们可以把函数 fn 拆分成多个小函数，此时多了中间运算过程产生的 m 和 n。</p>\n<p>下面这张图中可以想象成把 fn 这个管道拆分成了3个管道 f1, f2, f3，数据 a 通过管道 f3 得到结果 m，m 再通过管道 f2 得到结果 n，n<br>通过管道 f1 得到最终结果 b</p>\n<p><img src=\"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211211103248191.png\" alt=\"image-20211211103248191\"></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">fn &#x3D; compose(f1, f2, f3)\nresult &#x3D; fn(value)</code></pre>\n\n<h3 id=\"函数组合-1\"><a href=\"#函数组合-1\" class=\"headerlink\" title=\"函数组合\"></a>函数组合</h3><ul>\n<li>函数组合(compose)：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间的过程的 函数合并成一个函数<ul>\n<li>函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果</li>\n<li>函数组合默认是从右到左执行</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 基本函数组合\nfunction compose(f, g) &#123;\n  return function (x) &#123;\n    return f(g(x))\n  &#125;\n&#125;\n\nfunction first(arr) &#123;\n  return arr[0]\n&#125;\n\nfunction reverse(arr) &#123;\n  return arr.reverse()\n&#125;\n\nconst last &#x3D; compose(first, reverse)\n\nconsole.log(last([1, 2, 3, 4]))</code></pre>\n\n<ul>\n<li>lodash 中的组合函数</li>\n<li>lodash 中阻焊函数 <code>flow()</code> 从左到右或者 <code>flowRight()</code> 从右到左</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const _ &#x3D; require(&#39;lodash&#39;)\n\nconst toUpper &#x3D; s &#x3D;&gt; s.toUpperCase()\nconst reverse &#x3D; arr &#x3D;&gt; arr.reverse()\nconst first &#x3D; arr &#x3D;&gt; arr[0]\n\n&#x2F;&#x2F; 获取数组最后一个值，并转为大写\nconst f &#x3D; _.flowRight(toUpper, first, reverse)\nconsole.log(f([&#39;one&#39;, &#39;tow&#39;, &#39;three&#39;]))</code></pre>\n\n<ul>\n<li>模拟 lodash 的 flowRight 方法</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 接受多个函数\nfunction compose(...fns) &#123;\n  &#x2F;&#x2F; 传入的值\n  return function (value) &#123;\n    &#x2F;&#x2F; 使用 reverse 将函数从右到左执行，使用 reduce 把执行结果进行累加\n    return fns.reverse().reduce(function (acc, fn) &#123;\n      return fn(acc)\n      &#x2F;&#x2F; 累加初始值为 value\n    &#125;, value)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; ES6 写法\nconst compose &#x3D; (...fns) &#x3D;&gt; value &#x3D;&gt; fns.reverse().reduce((acc, fn) &#x3D;&gt; fn(acc), value)</code></pre>\n\n<ul>\n<li>函数的组合要满足结合律（associativity）:<ul>\n<li>可以把 g 和 h 组合，还可以把 f 和 g组合，结果都是一样的</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 结合律\nconst fn &#x3D; compose(f, g, h)\n\nconst fnAssociative &#x3D; compose(compose(f, g), h) &#x3D;&#x3D;&#x3D; compose(f, compose(g, h))</code></pre>\n\n<ul>\n<li>所以代码可以这样结合</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const _ &#x3D; require(&#39;lodash&#39;)\n\nconst f &#x3D; _.flowRight(_.toUpper, _.first, _.reverse)\nconst f &#x3D; _.flowRight(_.flowRight(_.toUpper, _.first), _.reverse)\nconst f &#x3D; _.flowRight(_.toUpper, _.flowRight(_.first, _.reverse))\nconsole.log(f([&#39;one&#39;, &#39;tow&#39;, &#39;three&#39;])) &#x2F;&#x2F; THREE</code></pre>\n\n<h3 id=\"函数组合打印日志\"><a href=\"#函数组合打印日志\" class=\"headerlink\" title=\"函数组合打印日志\"></a>函数组合打印日志</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const _ &#x3D; require(&#39;lodash&#39;)\n\nconst trace &#x3D; _.curry((tag, value) &#x3D;&gt; &#123;\n  console.log(value, tag)\n  return value\n&#125;)\n\n&#x2F;&#x2F; 使用柯里化，使得函数可以传递部分参数，加上函数组合为更强大的函数\n&#x2F;&#x2F; lodash 模块都是值在前，fn 在后的形式\nconst split &#x3D; _.curry((sep, str) &#x3D;&gt; _.split(str, sep))\nconst join &#x3D; _.curry((sep, arr) &#x3D;&gt; _.join(arr, sep))\nconst map &#x3D; _.curry((fn, arr) &#x3D;&gt; _.map(arr, fn))\n\nconst f &#x3D; _.flowRight(join(&#39;-&#39;), trace(&#39;map&#39;), map(_.toLower), trace(&#39;split&#39;), split(&#39; &#39;))\nconsole.log(f(&#39;NEVER SAY DIE&#39;)) &#x2F;&#x2F; never-say-die</code></pre>\n\n<ul>\n<li><a href=\"https://github.com/lodash/lodash/wiki/FP-Guide\">lodash/fp</a><ul>\n<li>lodash 的 fp 模块提供了实用的对<strong>函数式编程</strong>友好的方法</li>\n<li>提供了不可变 <strong>auto-curried iteratee-first data-last</strong> 的方法</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const _ &#x3D; require(&#39;lodash&#39;)\n_.map([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], _.toUpper)\n&#x2F;&#x2F; &#x3D;&gt; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]\n_.map([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])\n&#x2F;&#x2F; &#x3D;&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n\n_.split(&#39;hello world&#39;, &#39; &#39;)\n\nconst fp &#x3D; require(&#39;lodash&#x2F;fp&#39;)\n\n&#x2F;&#x2F; fp 模块下的函数都是柯里化后的函数\n&#x2F;&#x2F; 可以传递部分参数生成一个新的函数\n&#x2F;&#x2F; 获取全部参数可以得到返回结果\n&#x2F;&#x2F; 全部参数\nfp.map(fp.toUpper, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])\n&#x2F;&#x2F; 部分参数，生成了一个新的函数，再次调用\nfp.map(fp.toUpper)([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])\nfp.split(&#39; &#39;, &#39;hello world&#39;)\nfp.split(&#39; &#39;)(&#39;hello world&#39;)\n\nconst f &#x3D; fp.flowRight(fp.join(&#39;-&#39;), fp.map(fp.toLower), fp.split(&#39; &#39;))\nconsole.log(f(&#39;NEVER SAY DIE&#39;))</code></pre>\n\n<h3 id=\"Point-Free-Programming\"><a href=\"#Point-Free-Programming\" class=\"headerlink\" title=\"Point Free Programming\"></a>Point Free Programming</h3><p>Point Free: 可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数<br>只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。</p>\n<ul>\n<li>不需要知名处理的数据</li>\n<li>只需要合成运算的过程</li>\n<li>需要定义一些辅助的基本运算函数</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const f &#x3D; fp.flowRight(fp.join(&#39;-&#39;), fp.map(fp.toLower), fp.split(&#39; &#39;))</code></pre>\n\n<ul>\n<li>案例演示</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 非 Point Free 模式\n&#x2F;&#x2F; Hello World &#x3D;&gt; hello_world\nfunction f(word) &#123;\n  return word.toLowerCase().replace(&#x2F;\\s_&#x2F;g, &#39;_&#39;)\n&#125;\n\n&#x2F;&#x2F; Point Free\nconst fp &#x3D; require(&#39;lodash&#x2F;fp&#39;)\n\n&#x2F;&#x2F; 合成运算\nconst f &#x3D; fp.flowRight(fp.replace(&#x2F;\\s+&#x2F;g, &#39;_&#39;), fp.toLower)\n\nconsole.log(f(&#39;Hello World&#39;))</code></pre>\n\n<h2 id=\"Functor-函子\"><a href=\"#Functor-函子\" class=\"headerlink\" title=\"Functor(函子)\"></a>Functor(函子)</h2><h3 id=\"why\"><a href=\"#why\" class=\"headerlink\" title=\"why\"></a>why</h3><p>需要把函数式编程中的副作用控制在可控的范围内、异常处理和异步操作等。</p>\n<h3 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h3><ul>\n<li>容器：包含值和值的变形关系（这个变形关系就是函数）</li>\n<li>函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以运行一个 函数对值进行处理（变形关系）</li>\n</ul>\n<h3 id=\"Functor-函子-1\"><a href=\"#Functor-函子-1\" class=\"headerlink\" title=\"Functor 函子\"></a>Functor 函子</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 一个容器，包裹一个值\nclass Container &#123;\n  constructor(value) &#123;\n    this._value &#x3D; value\n  &#125;\n\n  &#x2F;&#x2F; 静态方法，可以屏蔽 new 关键字创建对象\n  static of(value) &#123;\n    return new Container(value)\n  &#125;\n\n  &#x2F;&#x2F; map 方法，传入变形关系，将容器里的值映射到另外一个容器\n  map(fn) &#123;\n    return new Container(fn(this._value))\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 链式调用\nContainer.of(3)\n  .map(v &#x3D;&gt; v + 1)\n  .map(v &#x3D;&gt; v ** 2)</code></pre>\n\n<ul>\n<li>函数式编程的运算不直接操作值，而是由函子完成</li>\n<li>函子就是一个实现了 map 契约的对象</li>\n<li>可以把函子想象成一个盒子，这个盒子里封装了一个值</li>\n<li>想要处理盒子中的值，需要给盒子的 map 方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理</li>\n<li>最后 map 方法返回一个包含新值的盒子（函子）</li>\n</ul>\n<p>如果 Functor 中传入 null 或者 undefined</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 如果传入 null， 会报错\nContainer.of(null)\n  .map(x &#x3D;&gt; x.toUpperCase())\n&#x2F;&#x2F; TypeError: Cannot read property &#39;toUpperCase&#39; of null</code></pre>\n\n<h3 id=\"MayBe-函子\"><a href=\"#MayBe-函子\" class=\"headerlink\" title=\"MayBe 函子\"></a>MayBe 函子</h3><ul>\n<li>编程的过程中可能会遇到很多错误，需要对这些错误做响应的处理</li>\n<li>MayBe 函子的作用就是可以对外部的控制情况做处理（控制副作用在允许的范围）</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 基本结果和上面一样\nclass MayBe &#123;\n  constructor(value) &#123;\n    this._value &#x3D; value\n  &#125;\n\n  static of(value) &#123;\n    return new MayBe(value)\n  &#125;\n\n  map(fn) &#123;\n    &#x2F;&#x2F; 新增对 _value 值的判断，判断不通过则返回 null\n    return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this._value))\n  &#125;\n\n  &#x2F;&#x2F; 新增对值的判断\n  isNothing() &#123;\n    return this._value &#x3D;&#x3D;&#x3D; null || this._value &#x3D;&#x3D;&#x3D; undefined\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 传入具体值 \nMayBe.of(&#39;Hello World&#39;)\n  .map(x &#x3D;&gt; x.toUpperCase())\n&#x2F;&#x2F; 传入 null 的情况 \nMayBe.of(null)\n  .map(x &#x3D;&gt; x.toUpperCase())\n&#x2F;&#x2F; &#x3D;&gt; MayBe &#123; _value: null &#125;</code></pre>\n\n<ul>\n<li>在 MayBe 函子中，很难确定在哪一步产生的空值问题，如下：</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">MayBe.of(&#39;hello&#39;)\n  .map(v &#x3D;&gt; v.toUpperCase())\n  .map(v &#x3D;&gt; null)\n  .map(v &#x3D;&gt; x.split(&#39; &#39;))\n&#x2F;&#x2F; &#x3D;&gt; MayBe &#123; _value: null &#125;</code></pre>\n\n<h3 id=\"Either-函子\"><a href=\"#Either-函子\" class=\"headerlink\" title=\"Either 函子\"></a>Either 函子</h3><ul>\n<li>Either 两者中的任务一个，类似于 if … else … 的处理</li>\n<li>异常会让函数变得不纯， Either 函子可以用来做异常处理</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Left &#123;\n  constructor(value) &#123;\n    this._value &#x3D; value\n  &#125;\n\n  static of(value) &#123;\n    return new Left(value)\n  &#125;\n\n  map(fn) &#123;\n\n    &#x2F;&#x2F; Left 处理异常信息，不对值进行改变\n    return this\n  &#125;\n&#125;\n\nclass Right &#123;\n  constructor(value) &#123;\n    this._value &#x3D; value\n  &#125;\n\n  static of(value) &#123;\n    return new Right(value)\n  &#125;\n\n  map(fn) &#123;\n    return Right.of(fn(this._value))\n  &#125;\n&#125;</code></pre>\n\n<ul>\n<li>Either 用来处理异常</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function parseJSON(str) &#123;\n  try &#123;\n    return Right.of(JSON.parse(str))\n  &#125; catch (e) &#123;\n    &#x2F;&#x2F; 异常会让函数不纯，使用 Left 来统一获取异常消息\n    return Left.of(&#123;error: e.message&#125;)\n  &#125;\n&#125;\n\nconst result &#x3D; parseJSON(&#39;&#123;&quot;age&quot;: 1&#125;&#39;).map(x &#x3D;&gt; x &gt;&#x3D; 18)\nconsole.log(result)</code></pre>\n\n<h3 id=\"IO-函子\"><a href=\"#IO-函子\" class=\"headerlink\" title=\"IO 函子\"></a>IO 函子</h3><ul>\n<li>IO 函子中的 _value 是一个函数，这里把函数作为值来处理</li>\n<li>IO 函子可以把不纯的动作存储到 _value 中，延迟这个不纯的操作（惰性执行），保证当前的操作纯</li>\n<li>把不纯的操作交给调用者来处理</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const fp &#x3D; require(&#39;lodash&#x2F;fp&#39;)\n\nclass IO &#123;\n\n  &#x2F;&#x2F; 构造函数传入一个函数\n  constructor(fn) &#123;\n    this._value &#x3D; fn\n  &#125;\n\n  static of(value) &#123;\n    return new IO(function () &#123;\n      return value\n    &#125;)\n  &#125;\n\n  map(fn) &#123;\n    &#x2F;&#x2F; 把当前的 _value 和传入的 fn 组合成一个新的函数\n    return new IO(fp.flowRight(fn, this._value))\n  &#125;\n&#125;\n\nconst io &#x3D; IO.of(process).map(p &#x3D;&gt; p.execPath)\nconsole.log(io._value())</code></pre>\n\n<h3 id=\"Task-异步执行\"><a href=\"#Task-异步执行\" class=\"headerlink\" title=\"Task 异步执行\"></a>Task 异步执行</h3><ul>\n<li>folktale(2.3.2)</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const &#123;task&#125; &#x3D; require(&#39;folktale&#x2F;concurrency&#x2F;task&#39;)\n\n&#x2F;&#x2F; 类似后面的 Promise\nfunction readFile(filename) &#123;\n  return task(resolver &#x3D;&gt; &#123;\n    fs.readFile(filename, &#39;utf-8&#39;, (err, data) &#x3D;&gt; &#123;\n      if (err) &#123;\n        resolver.reject(err)\n      &#125;\n      resolver.resolve(data)\n    &#125;)\n  &#125;)\n&#125;\n\n&#x2F;&#x2F; 调用 run 执行\nreadFile(&#39;..&#x2F;package.json&#39;)\n  .map(split(&#39;\\n&#39;))\n  .map(find(x &#x3D;&gt; x.includes(&#39;version&#39;)))\n  .run()\n  .listen(&#123;\n    onRejected: err &#x3D;&gt; &#123;\n      console.log(err)\n    &#125;,\n    onResolved: value &#x3D;&gt; &#123;\n      console.log(value)\n    &#125;\n  &#125;)</code></pre>\n\n<h3 id=\"Pointed-函子\"><a href=\"#Pointed-函子\" class=\"headerlink\" title=\"Pointed 函子\"></a>Pointed 函子</h3><ul>\n<li>Pointed 函子是实现了 of 静态方法的函子</li>\n<li>of 方法是为了避免使用 new 来创建对象，更深层次的含义是 of 方法用来把值放到上下文 Context （把值放到容器中，使用 map 来处理值）</li>\n</ul>\n<p><img src=\"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211211182414089.png\" alt=\"image-20211211182414089\"></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Container &#123;\n  static of(value) &#123;\n    return new Container(value)\n  &#125;\n\n&#x2F;&#x2F; ...\n&#125;\n\nContainer.of(2).map(x &#x3D;&gt; x + 5)</code></pre>\n\n<h3 id=\"Monad-单子\"><a href=\"#Monad-单子\" class=\"headerlink\" title=\"Monad (单子)\"></a>Monad (单子)</h3><p>在使用 IO 函子的时候，如果写出如下代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const fs &#x3D; require(&#39;fs&#39;)\nconst fp &#x3D; require(&#39;lodash&#x2F;fp&#39;)\nconst readFile &#x3D; function (filename) &#123;\n  return new IO(() &#x3D;&gt; &#123;\n    return fs.readFileSync(filename, &#39;utf-8&#39;)\n  &#125;)\n&#125;\n\nconst print &#x3D; function (value) &#123;\n  return new IO(() &#x3D;&gt; &#123;\n    console.log(value)\n    return value\n  &#125;)\n&#125;\n\nconst cat &#x3D; fp.flowRight(print, readFile)\nconst r &#x3D; cat(&#39;..&#x2F;package.json&#39;)._value()._value()\nconsole.log(r)</code></pre>\n\n<ul>\n<li>Monad 函子是可以变扁的 Pointed 函子， IO(IO(x))</li>\n<li>一个函子如果具有 join 和 of 两个方法并遵守一些定律就是一个 Monad</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const fp &#x3D; require(&#39;lodash&#x2F;fp&#39;)\n\nclass IO &#123;\n  constructor(fn) &#123;\n    this._value &#x3D; fn\n  &#125;\n\n  static of(value) &#123;\n    return new IO(() &#x3D;&gt; &#123;\n      return value\n    &#125;)\n  &#125;\n\n  map(fn) &#123;\n    return new IO(fp.flowRight(fn, this._value))\n  &#125;\n\n  join() &#123;\n    return this._value()\n  &#125;\n\n  flatMap(fn) &#123;\n    return this.map(fn).join()\n  &#125;\n&#125;\n\nconst r &#x3D; readFile(&#39;..&#x2F;package.json&#39;)\n  .map(fp.toUpper)\n  .flatMap(print)\n  .join()</code></pre>\n","text":"Functional Programming什么是函数式编程函数式编程的思维方式：把显示世界的事务和事物之间的联系抽象到程序世界（对运算过程进行抽象） 函数式编程中的函数指的数学中的函数即映射关系，输入的值对应一个输出的值，例如 y = f(x) 相同的输入始终得到相同的输出（纯...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":9,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","count":14,"path":"api/tags/JAVASCRIPT.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Functional-Programming\"><span class=\"toc-text\">Functional Programming</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">什么是函数式编程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">前置知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%BC%8F%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%EF%BC%88%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0%EF%BC%89\"><span class=\"toc-text\">函数式一等公民（头等函数）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">高阶函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">什么是高阶函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E6%84%8F%E4%B9%89\"><span class=\"toc-text\">使用高阶函数的意义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">常用的高阶函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">闭包</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%AF%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">纯函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%AF%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">纯函数概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%AF%E5%87%BD%E6%95%B0%E7%9A%84%E5%A5%BD%E5%A4%84\"><span class=\"toc-text\">纯函数的好处</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%AF%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">副作用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%AF%E9%87%8C%E5%8C%96%EF%BC%88Haskell-Brooks-Curry%EF%BC%89\"><span class=\"toc-text\">柯里化（Haskell Brooks Curry）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#lodash-%E4%B8%AD%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">lodash 中的柯里化函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88\"><span class=\"toc-text\">函数组合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%A1%E9%81%93\"><span class=\"toc-text\">管道</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88-1\"><span class=\"toc-text\">函数组合</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">函数组合打印日志</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Point-Free-Programming\"><span class=\"toc-text\">Point Free Programming</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Functor-%E5%87%BD%E5%AD%90\"><span class=\"toc-text\">Functor(函子)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#why\"><span class=\"toc-text\">why</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#what\"><span class=\"toc-text\">what</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Functor-%E5%87%BD%E5%AD%90-1\"><span class=\"toc-text\">Functor 函子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MayBe-%E5%87%BD%E5%AD%90\"><span class=\"toc-text\">MayBe 函子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Either-%E5%87%BD%E5%AD%90\"><span class=\"toc-text\">Either 函子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IO-%E5%87%BD%E5%AD%90\"><span class=\"toc-text\">IO 函子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Task-%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">Task 异步执行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Pointed-%E5%87%BD%E5%AD%90\"><span class=\"toc-text\">Pointed 函子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Monad-%E5%8D%95%E5%AD%90\"><span class=\"toc-text\">Monad (单子)</span></a></li></ol></li></ol></li></ol>","author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}},"mapped":true,"prev_post":{"title":"javascript asynchronous(未完成)","uid":"12f35e821d0385fb0185ca26a956309f","slug":"asynchronousJavascript","date":"2021-12-12T15:00:00.000Z","updated":"2022-09-28T07:19:23.106Z","comments":true,"path":"api/articles/asynchronousJavascript.json","keywords":null,"cover":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211212224316297.png","text":"JavaScript AsynchronousJavaScript 执行方法同步模式和异步模式 Synchronous （同步模式） console.log(&#39;global begin&#39;) function bar() &#123; console.log(&#3...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":9,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"JAVASCRIPT","slug":"JAVASCRIPT","count":14,"path":"api/tags/JAVASCRIPT.json"}],"author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}}},"next_post":{"title":"Deploy K8S","uid":"6a10bf4989cdd89dde18ea8bad304bb7","slug":"k8s","date":"2021-11-28T15:00:00.000Z","updated":"2022-09-28T07:19:23.110Z","comments":true,"path":"api/articles/k8s.json","keywords":null,"cover":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211128225817137.png","text":"三节点 k8s 部署1：机器准备这里我们准备三台虚拟机，一台master，二台node 机器准备教程 ubuntu 搭建 kvm 安装虚拟机 2：安装前的环境确认所有机器都需要执行： a：三台机器都可以联网，uname -a查看内核是否大于等于3.1 b：关闭三台机器的防火墙 s...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"教程","slug":"教程","count":5,"path":"api/categories/教程.json"}],"tags":[{"name":"K8S","slug":"K8S","count":1,"path":"api/tags/K8S.json"}],"author":{"name":"SKY","slug":"sky","avatar":"https://cycling-bucket.oss-cn-shenzhen.aliyuncs.com/littleboy/image-20211223171018733.png","link":"/","description":"Welcome to sky home","socials":{"github":"https://github.com/littleboyfury","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_38916811","juejin":"https://juejin.cn/user/2049948533144104","customs":{}}},"feature":true}}