[{"id":"42123ec318c96fdfb65cd843c0240696","title":"Eslint 自定义插件","content":"Eslint 自定义插件需求来源在整理 import 的时候，发现 &#123;&#125; 中属性换行调整不到想要的结果。\n例如:\n&#x2F;&#x2F; 编写的代码\nimport &#123;A, B, C&#125; from &#39;xxx&#39;\n\n&#x2F;&#x2F; 期望格式化后的结果\nimport &#123;\n  A,\n  B,\n  C\n&#125; from &#39;xxx&#39;\n\n&#x2F;&#x2F; object-curly-newline 规则的结果，我期望的是每一行一个属性\n&#x2F;&#x2F; &#39;object-curly-newline&#39;: [\n&#x2F;&#x2F;   &#39;error&#39;,\n&#x2F;&#x2F;   &#123;\n&#x2F;&#x2F;     ImportDeclaration: &#123;\n&#x2F;&#x2F;       multiline: true,\n&#x2F;&#x2F;       minProperties: 3,\n&#x2F;&#x2F;     &#125;,\n&#x2F;&#x2F;   &#125;\n&#x2F;&#x2F; ]\nimport &#123;\n  A, B, C\n&#125; from &#39;xxx&#39;\n\n于是打算自己实现一个 eslint plugin 来实现该功能。\n思路根据 eslint plugin 文档，创建项目结构，eslint 有自带的工具 yo，这里就没用使用，其实是一个道理。\n├── README.md\n├── build.js\n├── jest.config.js\n├── lib\n│   ├── helper.js\n│   ├── index.js\n│   └── rules\n│       └── newline.js\n├── package-lock.json\n├── package.json\n└── tests\n    └── newline.test.js\n\n代码说明package.json比较核心的字段：main: ./lib/index.js，对应commonjs引入方式的程序入口文件exports: ./lib/index.js，默认导出的文件scripts.build: 打包出较小的文件目录结构scripts.test: 单元测试，包括了代码覆盖率peerDependencies: 限制了 eslint 版本  \n&#123;\n  &quot;name&quot;: &quot;eslint-plugin-import-curly&quot;,\n  &quot;version&quot;: &quot;1.0.1&quot;,\n  &quot;description&quot;: &quot;import curly&quot;,\n  &quot;keywords&quot;: [\n    &quot;eslint&quot;,\n    &quot;eslintplugin&quot;,\n    &quot;eslint-plugin&quot;\n  ],\n  &quot;main&quot;: &quot;.&#x2F;lib&#x2F;index.js&quot;,\n  &quot;exports&quot;: &quot;.&#x2F;lib&#x2F;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;build&quot;: &quot;node .&#x2F;build.js&quot;,\n    &quot;test&quot;: &quot;jest --coverage&quot;,\n    &quot;fix&quot;: &quot;eslint lib build.js --fix&quot;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@typescript-eslint&#x2F;parser&quot;: &quot;^6.18.1&quot;,\n    &quot;eslint&quot;: &quot;^8.19.0&quot;,\n    &quot;eslint-doc-generator&quot;: &quot;^1.0.0&quot;,\n    &quot;eslint-plugin-eslint-plugin&quot;: &quot;^5.0.0&quot;,\n    &quot;eslint-plugin-jest&quot;: &quot;^27.6.2&quot;,\n    &quot;fs-extra&quot;: &quot;^11.2.0&quot;,\n    &quot;jest&quot;: &quot;^29.7.0&quot;,\n    &quot;typescript&quot;: &quot;^5.3.3&quot;\n  &#125;,\n  &quot;engines&quot;: &#123;\n    &quot;node&quot;: &quot;^14.17.0 || ^16.0.0 || &gt;&#x3D; 18.0.0&quot;\n  &#125;,\n  &quot;peerDependencies&quot;: &#123;\n    &quot;eslint&quot;: &quot;&gt;&#x3D;7&quot;\n  &#125;,\n  &quot;license&quot;: &quot;ISC&quot;\n&#125;\n\nbuild.js先看看如何打包，思路很简单，核心思路，拷贝 package.json README.md 和 lib 目录，package.json 去掉 devDependencies 中的所有依赖即可，然后把这些文件放入到 build 中\n&#39;use strict&#39;\n\nconst fs &#x3D; require(&#39;fs&#39;)\nconst fse &#x3D; require(&#39;fs-extra&#39;)\nconst &#123; join &#125; &#x3D; require(&#39;path&#39;)\n\nconst buildDir &#x3D; join(__dirname, &#39;build&#39;)\n\nif (fs.existsSync(buildDir)) &#123;\n  fs.rmdirSync(buildDir, &#123;recursive: true&#125;)\n&#125;\nfs.mkdirSync(buildDir)\n\nconst packageJSON &#x3D; JSON.parse(fs.readFileSync(&#39;.&#x2F;package.json&#39;, &#39;utf8&#39;))\npackageJSON.devDependencies &#x3D; &#123;&#125;\n\nfse.copySync(&#39;.&#x2F;lib&#39;, join(buildDir, &#39;lib&#39;))\nfs.writeFileSync(join(buildDir, &#39;package.json&#39;), JSON.stringify(packageJSON, undefined, 2), &#39;utf8&#39;)\nfs.copyFileSync(&#39;.&#x2F;README.md&#39;, join(buildDir, &#39;README.md&#39;))\n\n\nlib/index.js正文开始，现在来看看 index.js 写了什么。\n这文件也很简单，导入了一个包，然后导出了一个 rules， rules 里面包含的这是规则名称，即 newline。\n文档参考 Eslint plugin\n&quot;use strict&quot;;\n\nconst newline &#x3D; require(&#39;.&#x2F;rules&#x2F;newline&#39;)\n\nmodule.exports.rules &#x3D; &#123;\n  newline,\n&#125;\n\nlib/rules/newline.js现在来看看规则是如何实现的。\n文档参考 Custom rules\nmodule.exports &#x3D; &#123;\n  meta: &#123;\n    &#x2F;&#x2F; 该规则主要关注空格、分号、逗号和括号，程序的所有部分决定代码的外观而不是代码的执行方式。这些规则适用于 AST 中未指定的部分代码。\n    type: &#39;layout&#39;,\n    &#x2F;&#x2F; whitespace: 可以修复代码中的空白字符问题，例如缩进不一致、换行不规范、空格过多或过少等。\n    fixable: &#39;whitespace&#39;,\n    &#x2F;&#x2F; 传入参数的规则校验\n    schema: [\n      &#123;\n        type: &#39;object&#39;,\n        properties: &#123;\n          count: &#123;\n            type: &#39;number&#39;,\n          &#125;,\n        &#125;,\n        additionalProperties: false,\n      &#125;,\n    ],\n    &#x2F;&#x2F; 规则文档\n    docs: &#123;\n      url: &#39;xxxxx&#39;\n    &#125;,\n    &#x2F;&#x2F; key: reportId， value: 错误消息提示\n    messages: &#123;\n      &#39;import-curly-newline&#39;: &#39;Run autofix to import curly newline!&#39;,\n    &#125;,\n  &#125;,\n  &#x2F;&#x2F; 返回一个对象，其中包含 ESLint 在遍历 JavaScript 代码的抽象语法树（ESTree 定义的 AST）时调用到 “visit” 节点的方法\n  &#x2F;&#x2F; AST 结构可以在网站 https:&#x2F;&#x2F;astexplorer.net&#x2F; 上查看\n  create: (context) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 初始化默认值，超过了三个属性则换行\n    const option &#x3D; getDefaultValues(&#123; ...context.options[0] &#125;, &#123; count: 3 &#125;)\n\n    return &#123;\n      &#x2F;&#x2F; 遍历 import 语句的回调方法，node 则为当前 import 节点\n      ImportDeclaration: node &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 保留花括号中的属性，去掉 default 的导入： import A, &#123;B, C&#125; from &#39;xxx&#39;，即去掉 A\n        const importSpecifiers &#x3D; node.specifiers.filter(v &#x3D;&gt; v.type &#x3D;&#x3D;&#x3D; &#39;ImportSpecifier&#39;)\n        if (!(importSpecifiers.length &amp;&amp; option.count)) &#123;\n          return\n        &#125;\n        if (importSpecifiers.length &lt; option.count) &#123;\n          return\n        &#125;\n        &#x2F;&#x2F; 判断和处理代码\n        handleFailedImport(context, node, importSpecifiers, &#39;import-curly-newline&#39;)\n      &#125;,\n    &#125;\n  &#125;\n&#125;\n\nfunction handleFailedImport(context, node, importSpecifiers, messageId) &#123;\n  const sourceCode &#x3D; context.getSourceCode()\n\n  const &#123;\n    &#x2F;&#x2F; 左花括号节点\n    bracesLeft,\n    &#x2F;&#x2F; 后花括号节点\n    bracesRight,\n    &#x2F;&#x2F; 最后一个属性是否是逗号结尾\n    isHavaLastComma\n  &#125; &#x3D; getBracesTokens(sourceCode.getTokens(node))\n\n  if (\n    bracesLeft &amp;&amp;\n    bracesRight &amp;&amp;\n    importSpecifiers &amp;&amp;\n    &#x2F;&#x2F; 判断是否是每个属性都在单独的一行\n    isImportNewline(importSpecifiers, bracesLeft.loc.start.line, bracesRight.loc.start.line)\n  ) &#123;\n    &#x2F;&#x2F; 报告错误\n    reportFailedImport(\n      context,\n      [bracesLeft.range[0], bracesRight.range[1]],\n      messageId,\n      &#x2F;&#x2F; 修复后的代码\n      fixFailedImportCurlyNewline(sourceCode.getText(node), isHavaLastComma)\n    )\n  &#125;\n&#125;\n\n&#x2F;&#x2F; true 表示代码不满足规则\nfunction isImportNewline(nodes, bracesLeftLine, bracesRightLine) &#123;\n  &#x2F;&#x2F; 初始化上一行为左花括号的行数\n  let lastNodeLine &#x3D; bracesLeftLine\n  for (const node of nodes) &#123;\n    &#x2F;&#x2F; 判断同一个节点是否在同一行 A as AA, A \\n as AA\n    if (node.loc.start.line !&#x3D;&#x3D; node.loc.end.line) &#123;\n      return true\n    &#125;\n    &#x2F;&#x2F; 判断上一个节点和该节点是否在同一行\n    if (lastNodeLine &#x3D;&#x3D;&#x3D; node.loc.start.line) &#123;\n      return true\n    &#125; else &#123;\n      lastNodeLine &#x3D; node.loc.start.line\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 判断最后一个节点是否和右花括号在 同一行\n  return nodes[nodes.length - 1].loc.start.line &#x3D;&#x3D;&#x3D; bracesRightLine\n&#125;\n\n&#x2F;&#x2F; 修复代码\nfunction fixFailedImportCurlyNewline(codeStr, isHavaLastComma) &#123;\n  &#x2F;&#x2F; 判断结束符\n  const lineOff &#x3D; &#x2F;\\r\\n&#x2F;.test(codeStr) ? &#39;\\r\\n&#39; : (&#x2F;\\r&#x2F;.test(codeStr) ? &#39;\\r&#39; : &#39;\\n&#39;)\n\n  &#x2F;&#x2F; 思路是把花括号中的内容，先去掉换行符，然后按照逗号分成数组，过滤掉空行，最后在每个节点前加两个空格\n  &#x2F;&#x2F; TODO 这里固定了加两个空格，应该做兼容，暂时没有想到有什么好的方案\n  const params &#x3D; codeStr.substring(codeStr.indexOf(&#39;&#123;&#39;) + 1, codeStr.indexOf(&#39;&#125;&#39;))\n    .replace(&#x2F;\\n&#x2F;g, &#39;&#39;)\n    .replace(&#x2F;\\r&#x2F;g, &#39;&#39;)\n    .split(&#39;,&#39;)\n    .filter(v &#x3D;&gt; v.trim())\n    .map(v &#x3D;&gt; &#96;  $&#123;v.trim()&#125;&#96;)\n\n  &#x2F;&#x2F; 如果最后有逗号，添加一个空节点\n  if (isHavaLastComma) &#123;\n    params.push(&#39;&#39;)\n  &#125;\n\n  &#x2F;&#x2F; 拼接修复后的代码即可\n  return &#96;&#123;$&#123;lineOff&#125;$&#123;params.join(&#96;,$&#123;lineOff&#125;&#96;)&#125;$&#123;isHavaLastComma ? &#39;&#125;&#39; : &#96;$&#123;lineOff&#125;&#125;&#96;&#125;&#96;\n&#125;\n\nlib/helper.js相对通用的方法\n&#x2F;&#x2F; 获取左右花括号的位置，判断最后是否有逗号\nfunction getBracesTokens(tokens) &#123;\n  let bracesLeft\n  let bracesRight\n  let isHavaLastComma &#x3D; false\n  tokens.forEach((v, i) &#x3D;&gt; &#123;\n    if (v.type &#x3D;&#x3D;&#x3D; &#39;Punctuator&#39; &amp;&amp; v.value &#x3D;&#x3D;&#x3D; &#39;&#123;&#39;) &#123;\n      bracesLeft &#x3D; v\n    &#125;\n    if (v.type &#x3D;&#x3D;&#x3D; &#39;Punctuator&#39; &amp;&amp; v.value &#x3D;&#x3D;&#x3D; &#39;&#125;&#39;) &#123;\n      if (i &gt; 0 &amp;&amp; tokens[i - 1].value &#x3D;&#x3D;&#x3D; &#39;,&#39;) &#123;\n        isHavaLastComma &#x3D; true\n      &#125;\n      bracesRight &#x3D; v\n    &#125;\n  &#125;)\n  return &#123;\n    bracesLeft,\n    bracesRight,\n    isHavaLastComma,\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 报告错误代码，并且提示修复\nfunction reportFailedImport(context, ranges, messageId, fixedCode) &#123;\n  const sourceCode &#x3D; context.getSourceCode()\n\n  context.report(&#123;\n    messageId,\n    loc: &#123;\n      start: sourceCode.getLocFromIndex(ranges[0]),\n      end: sourceCode.getLocFromIndex(ranges[1])\n    &#125;,\n    fix: fixer &#x3D;&gt; fixer.replaceTextRange(ranges, fixedCode)\n  &#125;)\n&#125;\n\n&#x2F;&#x2F; 生成默认参数\nfunction getDefaultValues(options, defaultValues) &#123;\n  for (const key of Object.keys(defaultValues)) &#123;\n    if (options[key] &#x3D;&#x3D;&#x3D; undefined) &#123;\n      options[key] &#x3D; defaultValues[key]\n    &#125;\n  &#125;\n  return options\n&#125;\n\n\n使用方法先安装该插件\nnpm install eslint-plugin-import-curly --save-dev\n\n在 .eslintrc 文件中配置该插件，去掉 eslint-plugin-\n&#123;\n  &quot;plugins&quot;: [&quot;import-curly&quot;]\n&#125;\n\n规则：import-curly/newline用于格式化换行操作，import 花括号中属性默认超过了 3 个，则每个属性都换一行。\n\n\n\nname\n类型\n默认值\n描述\n\n\n\ncount\nnumber\n3\n如果花括号中的属性超过了 3 个，则会触发该规则\n\n\n&#123;\n  &quot;rules&quot;: &#123;\n    &quot;import-curly&#x2F;newline&quot;: &quot;error&quot;\n  &#125;\n&#125;\n\n或者\n&#123;\n  &quot;rules&quot;: &#123;\n    &quot;import-curly&#x2F;newline&quot;: [\n      &quot;error&quot;,\n      &#123;\n        &quot;count&quot;: 4\n      &#125;\n    ]\n  &#125;\n&#125;\n\ncase：\n&#x2F;&#x2F; invalid\nimport &#123;\n  A as AA,B, C&#125; from &#39;C&#39;\n\n&#x2F;&#x2F; ||\n&#x2F;&#x2F; \\&#x2F;\n\n&#x2F;&#x2F; valid\nimport &#123;\n  A as AA,\n  B,\n  C\n&#125; from &#39;C&#39;\n\n规则：import-curly/sort-params用于 import 花括号中的属性进行排序\n\n\n\nname\n类型\n默认值\n可选值\n描述\n\n\n\ntypeLocation\nstring\nignore\nignore,first,last\nignore: 忽略 ts 中 type 的位置，first: type 的位置在最前方, last: type 的位置在最后放\n\n\norderBy\nstring\nalphabeticalOrder\nalphabeticalOrder,letterNumber\nalphabeticalOrder: 按照字母排序， letterNumber: 按照字数排序。如果按照字数排序，相同字数的会按照字母排序\n\n\nsortBy\nstring\naec\naec,desc\naec: 增序, desc: 降序\n\n\nignoreCase\nboolean\ntrue\n\ntrue: 忽略大小写，false: 不忽略大小写\n\n\n&#123;\n  &quot;rules&quot;: &#123;\n    &quot;import-curly&#x2F;sort-params&quot;: &quot;error&quot;\n  &#125;\n&#125;\n\n或者\n&#123;\n  &quot;rules&quot;: &#123;\n    &quot;import-curly&#x2F;sort-params&quot;: [\n      &quot;error&quot;,\n      &#123;\n        &quot;typeLocation&quot;: &quot;first&quot;,\n        &quot;orderBy&quot;: &quot;letterNumber&quot;,\n        &quot;sortBy&quot;: &quot;desc&quot;,\n        &quot;ignoreCase&quot;: false\n      &#125;\n    ]\n  &#125;\n&#125;\n\n默认规则&#123;\n  &quot;rules&quot;: &#123;\n    &quot;import-curly&#x2F;sort-params&quot;: &quot;error&quot;,\n    &quot;import-curly&#x2F;sort-params&quot;: [\n      &quot;error&quot;,\n      &#123;\n        &quot;typeLocation&quot;: &quot;ignore&quot;,\n        &quot;orderBy&quot;: &quot;alphabeticalOrder&quot;,\n        &quot;sortBy&quot;: &quot;aec&quot;,\n        &quot;ignoreCase&quot;: true\n      &#125;\n    ]\n  &#125;\n&#125;\n\n有效的样例\nimport type &#123;a,b,c,d&#125; from &#39;a&#39;\nimport &#123;A,B,C,D&#125; from &#39;a&#39;\nimport type &#123;a,B,c,D&#125; from &#39;a&#39;\nimport &#123;A,b,c,D&#125; from &#39;a&#39;\nimport &#123;type a,b,type c,d&#125; from &#39;a&#39;\nimport &#123;a,type b,c,default as d&#125; from &#39;a&#39;\n\n错误的样例\n&#x2F;&#x2F; invalid\nimport &#123;type A,type c,d,B&#125; from &#39;a&#39;\n&#x2F;&#x2F; ||\n&#x2F;&#x2F; \\&#x2F;\n&#x2F;&#x2F; valid\nimport &#123;type A,B,type c,d&#125; from &#39;a&#39;\n\n\n&#x2F;&#x2F; invalid, ignore type, compare with &#39;default&#39;\nimport &#123;c,default as d,type b,a&#125; from &#39;a&#39;\n&#x2F;&#x2F; ||\n&#x2F;&#x2F; \\&#x2F;\n&#x2F;&#x2F; valid\nimport &#123;a,type b,c,default as d&#125; from &#39;a&#39;\n\ntype 在最前方&#123;\n  &quot;rules&quot;: &#123;\n    &quot;import-curly&#x2F;sort-params&quot;: [\n      &quot;error&quot;,\n      &#123;\n        &quot;typeLocation&quot;: &quot;first&quot;\n      &#125;\n    ],\n    &quot;import-curly&#x2F;sort-params&quot;: [\n      &quot;error&quot;,\n      &#123;\n        &quot;typeLocation&quot;: &quot;ignore&quot;,\n        &quot;orderBy&quot;: &quot;alphabeticalOrder&quot;,\n        &quot;sortBy&quot;: &quot;aec&quot;,\n        &quot;ignoreCase&quot;: true\n      &#125;\n    ]\n  &#125;\n&#125;\n\n有效的样例\n&#x2F;&#x2F; type first\nimport &#123;type B,type c,A, d&#125; from &#39;a&#39;\nimport &#123;type b,type d,a,c&#125; from &#39;a&#39;\n\n错误的样例\n&#x2F;&#x2F; invalid, compare with &#39;default&#39;\nimport &#123;c,a,default as d,type b&#125; from &#39;a&#39;\n&#x2F;&#x2F; ||\n&#x2F;&#x2F; \\&#x2F;\n&#x2F;&#x2F; valid\nimport &#123;type b,a,c,default as d&#125; from &#39;a&#39;\n\n按照字数排序&#123;\n  &quot;rules&quot;: &#123;\n    &quot;import-curly&#x2F;sort-params&quot;: [\n      &quot;error&quot;,\n      &#123;\n        &quot;orderBy&quot;: &quot;letterNumber&quot;\n      &#125;\n    ],\n    &quot;import-curly&#x2F;sort-params&quot;: [\n      &quot;error&quot;,\n      &#123;\n        &quot;typeLocation&quot;: &quot;ignore&quot;,\n        &quot;orderBy&quot;: &quot;letterNumber&quot;,\n        &quot;sortBy&quot;: &quot;aec&quot;,\n        &quot;ignoreCase&quot;: true\n      &#125;\n    ]\n  &#125;\n&#125;\n\n有效的样例\nimport &#123;a, ba, bb, ccc&#125; from &#39;a&#39;\nimport &#123;a, ba, bb, bbb&#125; from &#39;a&#39;\n\n错误的样例\n&#x2F;&#x2F; invalid bb ba letterNumber is the same, should order by alpha\nimport &#123;a, bb, ba&#125; from &#39;a&#39;\n&#x2F;&#x2F; ||\n&#x2F;&#x2F; \\&#x2F;\n&#x2F;&#x2F; valid\nimport &#123;a, ba, bb&#125; from &#39;a&#39;\n\n按照字母降序排序&#123;\n  &quot;rules&quot;: &#123;\n    &quot;import-curly&#x2F;sort-params&quot;: [\n      &quot;error&quot;,\n      &#123;\n        &quot;sortBy&quot;: &quot;desc&quot;\n      &#125;\n    ],\n    &quot;import-curly&#x2F;sort-params&quot;: [\n      &quot;error&quot;,\n      &#123;\n        &quot;typeLocation&quot;: &quot;ignore&quot;,\n        &quot;orderBy&quot;: &quot;alphabeticalOrder&quot;,\n        &quot;sortBy&quot;: &quot;desc&quot;,\n        &quot;ignoreCase&quot;: true\n      &#125;\n    ]\n  &#125;\n&#125;\n\n有效的样例\nimport &#123;d, c, b, a&#125; from &#39;a&#39;\n\n按照字数降序排序&#123;\n  &quot;rules&quot;: &#123;\n    &quot;import-curly&#x2F;sort-params&quot;: [\n      &quot;error&quot;,\n      &#123;\n        &quot;orderBy&quot;: &quot;letterNumber&quot;,\n        &quot;sortBy&quot;: &quot;desc&quot;\n      &#125;\n    ],\n    &quot;import-curly&#x2F;sort-params&quot;: [\n      &quot;error&quot;,\n      &#123;\n        &quot;typeLocation&quot;: &quot;ignore&quot;,\n        &quot;orderBy&quot;: &quot;letterNumber&quot;,\n        &quot;sortBy&quot;: &quot;desc&quot;,\n        &quot;ignoreCase&quot;: true\n      &#125;\n    ]\n  &#125;\n&#125;\n\n有效的样例\nimport &#123;aaa, cc, aa, d&#125; from &#39;a&#39;\n\n不忽略大小写&#123;\n  &quot;rules&quot;: &#123;\n    &quot;import-curly&#x2F;sort-params&quot;: [\n      &quot;error&quot;,\n      &#123;\n        &quot;ignoreCase&quot;: false\n      &#125;\n    ],\n    &quot;import-curly&#x2F;sort-params&quot;: [\n      &quot;error&quot;,\n      &#123;\n        &quot;typeLocation&quot;: &quot;ignore&quot;,\n        &quot;orderBy&quot;: &quot;alphabeticalOrder&quot;,\n        &quot;sortBy&quot;: &quot;aec&quot;,\n        &quot;ignoreCase&quot;: false\n      &#125;\n    ]\n  &#125;\n&#125;\n\n有效的样例\nimport &#123;A, B, C, a, b, c&#125; from &#39;a&#39;\nimport &#123;A, B, C, a, b, c, default as d&#125; from &#39;a&#39;\n\n总结如果大佬有什么现有的更好的方案，欢迎讨论附上项目地址： eslint-plugin-import-curly\n","slug":"eslintRule","date":"2024-01-16T16:00:00.000Z","categories_index":"前端","tags_index":"ESLINT","author_index":"SKY"},{"id":"98a5ddadc5f84e73bebd47e1058c0877","title":"electron 常见问题","content":"Electron 常见问题Electron 使用 chokidar 导致编译后白屏的问题\n问题出现场景：\n\n配置的是 contextIsolation 为 false ，可以在 renderer 进程中去使用 node 的包，使用 chokidar 去监听文件变化，windows 上面打包可以正常运行，mac 上打包出现了白屏\nconst mainWindow &#x3D; new CrateMainWindow(&#123;\n  width: 1200,\n  minWidth: 1200,\n  height: 800,\n  minHeight: 800,\n  useContentSize: true,\n  show: false,\n  frame: false,\n  titleBarStyle: platform().includes(&#39;win32&#39;) ? &#39;default&#39; : &#39;hidden&#39;,\n  webPreferences: &#123;\n    experimentalFeatures: true,\n    contextIsolation: false,\n    nodeIntegration: true,\n    webSecurity: false,\n    devTools: true,\n    scrollBounce: process.platform &#x3D;&#x3D;&#x3D; &#39;darwin&#39;\n  &#125;\n&#125;)\n\n\n解决办法\n\n打包是通过 webpack5 进行打包，由于是在浏览器端直接进行调用 node 的包，所有需要再 main 和 renderer 的配置中加入以下配置\n&#x2F;&#x2F; webpack.renderer.js\nmodule.exports &#x3D; &#123;\n  externals: [\n    &#39;fsevents&#39;\n  ]\n&#125;\n\n&#x2F;&#x2F; webpack.main.js\nmodule.exports &#x3D; &#123;\n  externals: [\n    &#39;fsevents&#39;,\n    &#x2F;&#x2F; dependencies 为 package.json 中 dependencies 中的包名\n    ...Object.keys(dependencies || &#123;&#125;)\n  ]\n&#125;\n\n最后重新 build 一下就可以正常运行了\nelectron-builder 打包报错\n问题描述\n\nelectron 打包的时候报错\n**** build: npm WARN config global &#96;--global&#96;, &#96;--local&#96; are deprecated. Use &#96;--location&#x3D;global&#96; instead.\n**** build:   • electron-builder  version&#x3D;23.6.0 os&#x3D;10.0.19045\n**** build:   • artifacts will be published if draft release exists  reason&#x3D;CI detected\n**** build:   • packaging       platform&#x3D;win32 arch&#x3D;x64 electron&#x3D;19.0.8 appOutDir&#x3D;build\\win-unpacked\n**** build:   ⨯ Get &quot;https:&#x2F;&#x2F;npmmirror.com&#x2F;mirrors&#x2F;electron&#x2F;19.0.8&#x2F;electron-v19.0.8-win32-x64.zip&quot;: proxyconnect tcp: dial tcp :0: connectex: The requested address is not valid in its context.\n**** build: github.com&#x2F;develar&#x2F;app-builder&#x2F;pkg&#x2F;download.(*Downloader).follow.func1\n**** build: \t&#x2F;Volumes&#x2F;data&#x2F;Documents&#x2F;app-builder&#x2F;pkg&#x2F;download&#x2F;downloader.go:206\n**** build: github.com&#x2F;develar&#x2F;app-builder&#x2F;pkg&#x2F;download.(*Downloader).follow\n**** build: \t&#x2F;Volumes&#x2F;data&#x2F;Documents&#x2F;app-builder&#x2F;pkg&#x2F;download&#x2F;downloader.go:234\n**** build: github.com&#x2F;develar&#x2F;app-builder&#x2F;pkg&#x2F;download.(*Downloader).DownloadNoRetry\n**** build: \t&#x2F;Volumes&#x2F;data&#x2F;Documents&#x2F;app-builder&#x2F;pkg&#x2F;download&#x2F;downloader.go:128\n**** build: github.com&#x2F;develar&#x2F;app-builder&#x2F;pkg&#x2F;download.(*Downloader).Download\n**** build: \t&#x2F;Volumes&#x2F;data&#x2F;Documents&#x2F;app-builder&#x2F;pkg&#x2F;download&#x2F;downloader.go:112\n**** build: github.com&#x2F;develar&#x2F;app-builder&#x2F;pkg&#x2F;electron.(*ElectronDownloader).doDownload\n**** build: \t&#x2F;Volumes&#x2F;data&#x2F;Documents&#x2F;app-builder&#x2F;pkg&#x2F;electron&#x2F;electronDownloader.go:192\n**** build: github.com&#x2F;develar&#x2F;app-builder&#x2F;pkg&#x2F;electron.(*ElectronDownloader).Download\n**** build: \t&#x2F;Volumes&#x2F;data&#x2F;Documents&#x2F;app-builder&#x2F;pkg&#x2F;electron&#x2F;electronDownloader.go:177\n**** build: github.com&#x2F;develar&#x2F;app-builder&#x2F;pkg&#x2F;electron.downloadElectron.func1.1\n**** build: \t&#x2F;Volumes&#x2F;data&#x2F;Documents&#x2F;app-builder&#x2F;pkg&#x2F;electron&#x2F;electronDownloader.go:73\n**** build: github.com&#x2F;develar&#x2F;app-builder&#x2F;pkg&#x2F;util.MapAsyncConcurrency.func2\n**** build: \t&#x2F;Volumes&#x2F;data&#x2F;Documents&#x2F;app-builder&#x2F;pkg&#x2F;util&#x2F;async.go:68\n**** build: runtime.goexit\n**** build: \t&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;go&#x2F;1.17&#x2F;libexec&#x2F;src&#x2F;runtime&#x2F;asm_amd64.s:1581  \n**** build: C:\\Users\\haoxing\\gitlab-runner\\builds\\yzC86XrJ\\0\\yang.yang\\haoxing-trade-manage\\node_modules\\.pnpm\\builder-util@23.6.0\\node_modules\\builder-util\\src\\util.ts:250\n**** build:       reject(new ExecError(command, code, out, errorOut))\n**** build:              ^\n**** build: Error: C:\\Users\\haoxing\\gitlab-runner\\builds\\yzC86XrJ\\0\\yang.yang\\haoxing-trade-manage\\node_modules\\.pnpm\\app-builder-bin@4.0.0\\node_modules\\app-builder-bin\\win\\x64\\app-builder.exe process failed ERR_ELECTRON_BUILDER_CANNOT_EXECUTE\n**** build: Exit code:\n**** build: 1\n**** build:     at ChildProcess.&lt;anonymous&gt; (C:\\Users\\haoxing\\gitlab-runner\\builds\\yzC86XrJ\\0\\yang.yang\\haoxing-trade-manage\\node_modules\\.pnpm\\builder-util@23.6.0\\node_modules\\builder-util\\src\\util.ts:250:14)\n**** build:     at Object.onceWrapper (node:events:642:26)\n**** build:     at ChildProcess.emit (node:events:527:28)\n**** build:     at ChildProcess.cp.emit (C:\\Users\\haoxing\\gitlab-runner\\builds\\yzC86XrJ\\0\\yang.yang\\haoxing-trade-manage\\node_modules\\.pnpm\\cross-spawn@7.0.3\\node_modules\\cross-spawn\\lib\\enoent.js:34:29)\n**** build:     at maybeClose (node:internal&#x2F;child_process:1092:16)\n**** build:     at Process.ChildProcess._handle.onexit (node:internal&#x2F;child_process:302:5)\n**** build: Failed\nundefined\nC:\\Users\\haoxing\\gitlab-runner\\builds\\yzC86XrJ\\0\\yang.yang\\haoxing-trade-manage\\packages\\haoxing:\n ERR_PNPM_RECURSIVE_RUN_FIRST_FAIL  @hx&#x2F;haoxing@0.0.1 build: &#96;rimraf dist &amp;&amp; rimraf build &amp;&amp; cross-env NODE_ENV&#x3D;production vue-tsc --noEmit &amp;&amp; vite build&#96;\nExit status 1\n ELIFECYCLE  Command failed with exit code 1.\n\n\n解决办法\n\n手动下载文件\n放入 AppData\\Local\\electron\\Cache 中\n","slug":"electron","date":"2022-10-25T16:00:00.000Z","categories_index":"前端","tags_index":"ELECTRON,WEBPACK","author_index":"SKY"},{"id":"39b4d57bd8b6b84b4666262778a8be78","title":"Electron 使用 cryptoJs 加密","content":"Electron 使用 cryptoJs 进行加密背景由于 electron 开启了浏览器端可以直接使用 node 的包，所以导致了对文件加密时出现了多种类型的文件描述，node fs 读取的 Buffer 文件，浏览器的 Blob 文件\nkey 和 iv 构建const key &#x3D; CryptoJS.enc.Utf8.parse(&#39;1111111111&#39;)\nconst iv &#x3D; CryptoJS.enc.Utf8.parse(&#39;11111111111&#39;)\n\n不同格式之间转换Buffer to ArrayBufferfunction bufferToArrayBuffer(buffer) &#123;\n  const arrayBuffer &#x3D; new ArrayBuffer(buffer.length)\n  const res &#x3D; new Uint8Array(arrayBuffer)\n  for (let i &#x3D; 0; i &lt; buffer.length; ++i) &#123;\n    res[i] &#x3D; buffer[i]\n  &#125;\n  return arrayBuffer\n&#125;\n\nBlob to ArrayBufferfunction blobToArrayBuffer(blob) &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    const file &#x3D; new FileReader()\n    file.onload &#x3D; function(result) &#123;\n      resolve(file.result)\n    &#125;\n    file.readAsArrayBuffer(blob)\n  &#125;)\n&#125;\n\nwordArray To ArrayBufferfunction wordArrayToArrayBuffer(wordArray) &#123;\n  const &#123; words &#125; &#x3D; wordArray\n  const &#123; sigBytes &#125; &#x3D; wordArray\n  const u8 &#x3D; new Uint8Array(sigBytes)\n  for (let i &#x3D; 0; i &lt; sigBytes; i +&#x3D; 1) &#123;\n    u8[i] &#x3D; (words[i &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - (i % 4) * 8)) &amp; 0xff\n  &#125;\n  return u8\n&#125;\n\n文件加密对 WordArray 进行加密function encryptFile(wordArray) &#123;\n  &#x2F;&#x2F; encrypt 函数接受的是一个 wordArray 对象\n  const encrypt &#x3D; CryptoJS.AES.encrypt(wordArray, key, &#123;\n    iv,\n    mode: CryptoJS.mode.CBC,\n    padding: CryptoJS.pad.Pkcs7\n  &#125;)\n  &#x2F;&#x2F; 根据实际场景返回\n  return CryptoJS.enc.Base64.stringify(encrypt.ciphertext)\n&#125;\n\n对 Buffer 文件加密对 Buffer 加密，需要先把 Buffer 转为 ArrayBuffer，再把 ArrayBuffer 转为 WordArray\nfunction encryptBuffer(buffer) &#123;\n  const arrayBuffer &#x3D; bufferToArrayBuffer(buffer)\n  const wordArray &#x3D; CryptoJS.lib.WordArray.create(arrayBuffer)\n  return encryptFile(wordArray)\n&#125;\n\n对 Blob 文件加密对 Blob 加密，需要先把 Blob 转为 Arraybuffer，再把 ArrayBuffer 转为 WordArray\nasync function encryptBlob(blob) &#123;\n  const arrayBuffer &#x3D; await blobToArrayBuffer(blob)\n  const wordArray &#x3D; CryptoJS.lib.WordArray.create(arrayBuffer)\n  return encryptFile(wordArray)\n&#125;\n\n文件解密对 WordArray 解密文件解密传入的也是 WordArray 对象\nfunction decryptFile(wordArray) &#123;\n  &#x2F;&#x2F; 后端是采用的 base64 加密，所以需要构建为 base64 的字符串，看情况变化\n  wordArray &#x3D; CryptoJS.enc.Base64.stringify(wordArray)\n  const decrypt &#x3D; CryptoJS.AES.decrypt(wordArray, key, &#123;\n    iv,\n    mode: CryptoJS.mode.CBC,\n    padding: CryptoJS.pad.Pkcs7\n  &#125;)\n  return wordArrayToArrayBuffer(decrypt)\n&#125;\n\n对 Blob 解密浏览器通过 axios 返回的是一个 Blob 文件，所以，对 Blob 文件解密需要先转为 ArrayBuffer，然后把ArrayBuffer 转为 WordArray 对象\nasync function decryptBlob(blob) &#123;\n  const arrayBuffer &#x3D; await blobToArrayBuffer(blob)\n  const wordArray &#x3D; CryptoJS.lib.WordArray.create(arrayBuffer)\n  return decryptFile(wordArray)\n&#125;\n\n\n对字符串加解密function encrypt(data) &#123;\n  if (typeof data &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;\n    &#x2F;&#x2F; 如果传入的data是json对象，先转义为json字符串\n    data &#x3D; JSON.stringify(data)\n  &#125;\n  const srcs &#x3D; CryptoJS.enc.Utf8.parse(data)\n  const encrypted &#x3D; CryptoJS.AES.encrypt(srcs, key, &#123;\n    iv,\n    mode: CryptoJS.mode.CBC, &#x2F;&#x2F; 加密模式\n    padding: CryptoJS.pad.Pkcs7\n  &#125;)\n  &#x2F;&#x2F; 需要返回base64格式的加密结果\n  return CryptoJS.enc.Base64.stringify(encrypted.ciphertext)\n  &#x2F;&#x2F; 需要返回hex格式的加密结果\n  &#x2F;&#x2F; return encrypted.ciphertext.toString()\n&#125;\n\n&#x2F;**\n * 解密数据\n * @param data 数据\n * @returns &#123;string&#125;\n *&#x2F;\nfunction decrypt(data) &#123;\n  const base64 &#x3D; CryptoJS.enc.Base64.parse(data)\n  const srcs &#x3D; CryptoJS.enc.Base64.stringify(base64)\n  const decrypt &#x3D; CryptoJS.AES.decrypt(srcs, key, &#123;\n    iv: iv,\n    mode: CryptoJS.mode.CBC,\n    padding: CryptoJS.pad.Pkcs7\n  &#125;)\n  const decryptedStr &#x3D; decrypt.toString(CryptoJS.enc.Utf8)\n  return decryptedStr.toString()\n&#125;\n\n","slug":"cryptoJs","date":"2022-10-25T16:00:00.000Z","categories_index":"JavaScript","tags_index":"JAVASCRIPT,CRYPTO_JS","author_index":"SKY"},{"id":"1f856bdf240a03a57edc41573ba4f1c6","title":"webpack 自定义 loader","content":"webpack 自定义 loader需求来源需要在客户端中写入日志，并且需要知道报错日志的原文件路径和行号，不采用 sentry 的方式（需要额外部署）\n思路想法是在 logger 的最后两个参数中加入原始文件名和行号，所以这一步在 webpack 加载文件的时候就需要去解析文件，默认添加参数\n自定义 loaderconst path &#x3D; require(&#39;path&#39;)\nconst traverse &#x3D; require(&#39;@babel&#x2F;traverse&#39;).default\nconst generate &#x3D; require(&#39;@babel&#x2F;generator&#39;).default\nconst parser &#x3D; require(&#39;@babel&#x2F;parser&#39;)\nconst t &#x3D; require(&#39;@babel&#x2F;types&#39;)\n\n&#x2F;**\n * 自己封装的方法\n * 使用方式：logger.log(...args)\n *&#x2F;\nconst loggers &#x3D; [\n  &#39;log&#39;,\n  &#39;error&#39;,\n  &#39;warn&#39;,\n  &#39;info&#39;,\n  &#39;debug&#39;\n]\n\nfunction loggerLoader(content) &#123;\n  &#x2F;&#x2F; 得到源文件的路径\n  const filename &#x3D; path.relative(this.rootContext, this.resourcePath)\n  &#x2F;&#x2F; 解析 AST\n  const ast &#x3D; parser.parse(content, &#123;\n    sourceType: &#39;module&#39;\n  &#125;)\n  &#x2F;&#x2F; 便利 AST\n  traverse(ast, &#123;\n    &#x2F;&#x2F; https:&#x2F;&#x2F;astexplorer.net&#x2F; 这里可以在这个网站中看见，遍历对应的 Expression\n    CallExpression(path) &#123;\n      const memberExpression &#x3D; path.get(&#39;MemberExpression&#39;)\n      &#x2F;&#x2F; 这里可以通过 debug 的方式一步步寻找自己想要的节点\n      if (memberExpression &amp;&amp; memberExpression.container &amp;&amp; memberExpression.container.callee) &#123;\n        const callee &#x3D; memberExpression.container.callee\n\n        if (callee.object &amp;&amp; callee.property) &#123;\n          &#x2F;&#x2F; 验证 logger.log \n          if (t.isIdentifier(callee.object, &#123;name: &#39;logger&#39;&#125;) &amp;&amp;\n            loggers.find(v &#x3D;&gt; t.isIdentifier(callee.property, &#123;name: v&#125;))) &#123;\n            &#x2F;&#x2F; 构造一个 string ，传入文件路径\n            const filenameNode &#x3D; t.stringLiteral(filename)\n            &#x2F;&#x2F; 构造一个 number ，传入开始行号\n            const lineNumStart &#x3D; t.numericLiteral(path.node.loc.start.line)\n            &#x2F;&#x2F; 构造一个 number ，传入结束行号\n            const lineNumEnd &#x3D; t.numericLiteral(path.node.loc.end.line)\n\n            &#x2F;&#x2F; 放入到参数末尾中\n            path.node.arguments.push(filenameNode)\n            path.node.arguments.push(lineNumStart)\n            path.node.arguments.push(lineNumEnd)\n          &#125;\n        &#125;\n      &#125;\n    &#125;\n  &#125;)\n\n  &#x2F;&#x2F; 重新生成代码，则所有的 logger.log 在最后都加上了三个参数 (...args, filename, lineNumStart, lineNumEnd)\n  return generate(ast, &#123;&#125;).code\n&#125;\n\n&#x2F;&#x2F; 默认导出\nmodule.exports &#x3D; loggerLoader\n\n封装 logger采用了 winston 进行日志写入\nconst &#123;\n  createLogger,\n  format,\n  transports\n&#125; &#x3D; require(&#39;winston&#39;)\nrequire(&#39;winston-daily-rotate-file&#39;)\nconst os &#x3D; require(&#39;os&#39;)\nconst path &#x3D; require(&#39;path&#39;)\n\n&#x2F;&#x2F; 构造 Symbol\nconst loggerSymbol &#x3D; Symbol(&#39;loggerSymbol&#39;)\n\n&#x2F;&#x2F; winston 中需要的方法名，其他可以自行加入\nconst LOGGERS &#x3D; [\n  &#39;error&#39;,\n  &#39;warn&#39;,\n  &#39;info&#39;,\n  &#39;debug&#39;\n]\n\nclass Logger &#123;\n  &#x2F;&#x2F; winston 实例\n  constructor(logger) &#123;\n    this.logger &#x3D; logger\n  &#125;\n\n  log(...args) &#123;\n    this.info(...args)\n  &#125;\n\n  info(...args) &#123;\n    this[loggerSymbol](&#39;log&#39;, ...args)\n    this.logger.info(...args)\n  &#125;\n\n  warn(...args) &#123;\n    this[loggerSymbol](&#39;warn&#39;, ...args)\n    this.logger.warn(...args)\n  &#125;\n\n  error(...args) &#123;\n    this[loggerSymbol](&#39;error&#39;, ...args)\n    this.logger.error(...args)\n  &#125;\n\n  debug(...args) &#123;\n    this[loggerSymbol](&#39;debug&#39;, ...args)\n    this.logger.debug(...args)\n  &#125;\n\n  [loggerSymbol](type, ...args) &#123;\n    &#x2F;&#x2F; 获取最后三个变量，则是原始文件路径，开始行号和结束行号\n    const fileInfoArgs &#x3D; args.splice(args.length - 3)\n    if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39;) &#123;\n      &#x2F;&#x2F; 按需答应\n      console[type](\n        &#96;[$&#123;fileInfoArgs[0]&#125;] [$&#123;fileInfoArgs[1]&#125;] [$&#123;fileInfoArgs[2]&#125;]&#96;,\n        ...args\n      )\n    &#125;\n  &#125;\n&#125;\n\nconst customFormat &#x3D; format.combine(\n  &#x2F;&#x2F; format.label(&#123; label: &#39;render&#39; &#125;),\n  format.timestamp(&#123;\n    format: &#39;YYYY-MM-DD HH:mm:ss&#39;\n  &#125;),\n  format.align(),\n  &#x2F;&#x2F; 构造打印日志的格式 \n  format.printf((info) &#x3D;&gt; &#123;\n    info.message &#x3D; info.message.substring(1)\n    &#x2F;&#x2F; webpack 编译传入的参数对象\n    const symbol &#x3D; Object.getOwnPropertySymbols(info).find(symbol &#x3D;&gt; symbol.description &#x3D;&#x3D;&#x3D; &#39;splat&#39;)\n    let message\n    if (symbol) &#123;\n      &#x2F;&#x2F; 通过 webpack loader 会传入文件所在的位置\n      const args &#x3D; info[symbol]\n      const len &#x3D; args.length\n      if (len &gt;&#x3D; 3) &#123;\n        &#x2F;&#x2F; 自定义日志格式，加入源文件路径，开始行号和结束行号\n        message &#x3D; &#96;[$&#123;[info.timestamp]&#125;] [$&#123;args[len - 3]&#125;] [$&#123;args[len - 2]&#125;] [$&#123;args[len - 1]&#125;] [$&#123;info.level&#125;] - $&#123;info.message&#125;&#96;\n      &#125;\n    &#125;\n    if (!message) &#123;\n      message &#x3D; &#96;[$&#123;[info.timestamp]&#125;] [$&#123;info.level&#125;] - $&#123;info.message&#125;&#96;\n    &#125;\n\n    return message\n  &#125;)\n)\n\nconst defaultOptions &#x3D; &#123;\n  format: customFormat,\n  datePattern: &#39;YYYY-MM-DD&#39;,\n  zippedArchive: true,\n  &#x2F;&#x2F; maxSize: &#39;1m&#39;,\n  maxFiles: &#39;14d&#39;\n&#125;\n\nlet filename &#x3D; &#39;logs&#x2F;%DATE%.log&#39;\nfilename &#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39; ? filename : path.join(os.tmpdir(), filename)\n\nconst logger &#x3D; createLogger(&#123;\n  &#x2F;&#x2F; format: customFormat,\n  transports: [\n    new transports.DailyRotateFile(&#123;\n      filename,\n      level: &#39;debug&#39;,\n      ...defaultOptions\n    &#125;)\n  ]\n&#125;)\n\nconst toMessage &#x3D; (arg) &#x3D;&gt; &#96;$&#123;arg&#125; &#96;\n\n&#x2F;&#x2F; 重写 winston 实例，对路径和行号参数进行处理，把原有的参数变为字符串\nLOGGERS.forEach(v &#x3D;&gt; &#123;\n  const fn &#x3D; logger[v]\n  if (fn) &#123;\n    logger[v] &#x3D; function (...args) &#123;\n      let message &#x3D; &#39;&#39;\n      const fileInfoArgs &#x3D; args.splice(args.length - 3)\n\n      args.forEach(arg &#x3D;&gt; &#123;\n        if (typeof arg &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;\n          message +&#x3D; toMessage(JSON.stringify(arg))\n        &#125; else &#123;\n          message +&#x3D; toMessage(arg)\n        &#125;\n      &#125;)\n\n      fn(message, ...fileInfoArgs)\n    &#125;\n  &#125;\n&#125;)\n\nconst hxLogger &#x3D; new Logger(logger)\n\nmodule.exports &#x3D; &#123;\n  logger: hxLogger,\n  loggerFilePath: filename\n&#125;\n\nwebpack 配置&#x2F;&#x2F; webpack 配置\nmodule.exports &#x3D; &#123;\n  module: &#123;\n    rules: [&#123;\n      test: &#x2F;\\.js$&#x2F;,\n      &#x2F;&#x2F; 制定自定义 loader 的路径\n      use: [path.join(__dirname, &#39;.&#x2F;console-loader.js&#39;)]\n    &#125;]\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 代码使用\nlogger.info(&#39;test&#39;)\nlogger.error(&#39;test&#39;)\nlogger.debug(&#39;test&#39;)\nlogger.warn(&#39;test&#39;)\nlogger.log(&#39;test&#39;)\n\n日志样例[2022-10-25 13:11:59] [src&#x2F;renderer&#x2F;App.vue] [17] [17] [info] - IPV4 111.111.111.111\n[2022-10-25 13:11:59] [src&#x2F;renderer&#x2F;App.vue] [18] [18] [info] - mac 地址 11:11:11:11:11:11 \n[2022-10-25 13:11:59] [src&#x2F;renderer&#x2F;App.vue] [19] [19] [info] - 磁盘序列号 1111111111\n[2022-10-25 13:11:59] [src&#x2F;renderer&#x2F;App.vue] [20] [20] [info] - 系统序列号 111111111\n[2022-10-25 13:11:59] [src&#x2F;renderer&#x2F;App.vue] [21] [21] [info] - 系统驱动版本 12.6 \n[2022-10-25 13:11:59] [src&#x2F;renderer&#x2F;App.vue] [22] [22] [info] - 用户名 11111111\n\n不足vue 文件中的行号不是对应 script 标签中的行号，需要减去前面 template 占有的行号，基本可以满足对日志定位的需求\n","slug":"webpack","date":"2022-10-25T16:00:00.000Z","categories_index":"前端","tags_index":"VUE,ELECTRON,WEBPACK","author_index":"SKY"},{"id":"135e69e6df7330d17285ee6191cf1397","title":"前端问题记录","content":"前端问题记录Mixed Content问题描述：\nMixed Content: The page at &#39;https:&#x2F;&#x2F;xxx.com&#x2F;xxx&#39; was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint &#39;http:&#x2F;&#x2F;xxx.aliyuncs.com&#x2F;&#39;. This request has been blocked; the content must be served over HTTPS.\n\n解决办法：\n在 head 中加入一个 meta 信息，把 http 的请求强制改为 https 的请求，前提该链接需要支持 https 的请求\n&lt;meta http-equiv&#x3D;&quot;Content-Security-Policy&quot; content&#x3D;&quot;upgrade-insecure-requests&quot;&gt;\n\n\n","slug":"frontendProblemLog","date":"2022-07-25T16:00:00.000Z","categories_index":"FRONTEND","tags_index":"PROBLEM_LOG","author_index":"SKY"},{"id":"219378987043e4797346b5005bf2e4a1","title":"monorepo pnpm 打开方式","content":"使用 pnpm workspace 管理 monorepo 项目安装 pnpmpnpm 中文文档\n什么是 monorepoMonorepo 是项目管理代码的方式之一，指的是一个大项目中包含了需要小项目或者模块，大概的样子\n├── packages\n|   ├── pkg1\n|   |   ├── package.json\n|   ├── pkg2\n|   |   ├── package.json\n├── package.json\n\n初始化项目pnpm init\n\n初始化一个项目，创建 package.json \n.\n└── package.json\n\n在根目录中创建 pnpm-workspace.yaml\npackages:\n  - &#39;packages&#x2F;**&#39;\n\n在根目录中创建 packages 文件夹，并且在 packages 中创建子项目\nmkdir packages\nmkdir packages&#x2F;core\nmkdir packages&#x2F;browser\n\n.\n├── package.json\n└── packages\n    ├── browser\n    └── core\n\n安装全局依赖-D 表示安装到开发依赖，即 devDependencies, -w 表示在根目录安装\npnpm install typescript -Dw\n\n.\n├── node_modules\n│   └── typescript -&gt; .pnpm&#x2F;typescript@4.7.4&#x2F;node_modules&#x2F;typescript\n├── package.json\n├── packages\n│   ├── browser\n│   └── core\n├── pnpm-lock.yaml\n└── pnpm-workspace.yaml\n\n\n局部依赖首选在每个子项目中初始化 package.json\n.\n├── node_modules\n│   └── typescript -&gt; .pnpm&#x2F;typescript@4.7.4&#x2F;node_modules&#x2F;typescript\n├── package.json\n├── packages\n│   ├── browser\n│   │   └── package.json\n│   └── core\n│       └── package.json\n├── pnpm-lock.yaml\n└── pnpm-workspace.yaml\n\n\npackages/browser 中的 package.json\n&#123;\n  &quot;name&quot;: &quot;@test&#x2F;browser&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;\n&#125;\n\npackages/core 中的 package.json\n&#123;\n  &quot;name&quot;: &quot;@test&#x2F;core&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;\n&#125;\n\n这里需要给每个子项目指定命名空间和包名，即 @test/core\n通过 filter 可以给指定的包安装依赖\npnpm install loadsh -r --filter @test&#x2F;core\n\n&#123;\n  &quot;name&quot;: &quot;@test&#x2F;core&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;dependencies&quot;: &#123;\n    &quot;lodash&quot;: &quot;^4.17.21&quot;\n  &#125;\n&#125;\n\n两个包之间相互依赖browser 依赖 core\npnpm i @test&#x2F;core -r --filter @test&#x2F;browser\n\nbrowser 中就依赖上了 core，版本前面有 workspace 字样，表示本地引用，发布的时候就会被剔除掉\n&#123;\n  &quot;name&quot;: &quot;@test&#x2F;browser&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;dependencies&quot;: &#123;\n    &quot;@test&#x2F;core&quot;: &quot;workspace:^1.0.0&quot;\n  &#125;\n&#125;\n\n\n运行子包命令根目录 package.json\n使用 pnpm -r --filter=@test/* run test 来批量执行子包中的 test 脚本\n&#123;\n  &quot;name&quot;: &quot;test&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;pnpm -r --filter&#x3D;@test&#x2F;* run test&quot;\n  &#125;,\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;typescript&quot;: &quot;^4.7.4&quot;\n  &#125;\n&#125;\n\n\n@test/browser 中的 package.json\n&#123;\n  &quot;name&quot;: &quot;@test&#x2F;browser&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;test browser\\&quot;&quot;\n  &#125;,\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;dependencies&quot;: &#123;\n    &quot;@test&#x2F;core&quot;: &quot;workspace:^1.0.0&quot;\n  &#125;\n&#125;\n\n\n@test/core 中的 package.json\n&#123;\n  &quot;name&quot;: &quot;@test&#x2F;core&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;test core\\&quot;&quot;\n  &#125;,\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;dependencies&quot;: &#123;\n    &quot;lodash&quot;: &quot;^4.17.21&quot;\n  &#125;\n&#125;\n\n\n执行 pnpm test，即可得到输出结果\n&gt; pnpm -r --filter&#x3D;@test&#x2F;* run test\n\nScope: 2 of 3 workspace projects\npackages&#x2F;core test$ echo &quot;test core&quot;\n│ test core\n└─ Done in 13ms\npackages&#x2F;browser test$ echo &quot;test browser&quot;\n│ test browser\n└─ Done in 8ms\n\n","slug":"monorepo","date":"2022-07-19T16:00:00.000Z","categories_index":"JavaScript","tags_index":"JAVASCRIPT","author_index":"SKY"},{"id":"bc3e26c008b79bc9d58c7c60987d0cdd","title":"git merge 原理","content":"GIT 合并基本原理二路合并二路合并就是逐行对比，如果行内容不同这报冲突。\n本地提交\nconsole.log(&#39;hello world&#39;)\n\n其他提交\nconsole.log(&#39;world hello&#39;)\n\n假设这是修改了同一个文件，进行合并时，发现这一行不一致，git 没有理由去丢弃本地提交或者其他提交，只能人为处理\n三路合并三路合并就是先找一个 base，如果两个文件相对于 base 都有修改，那就会报冲突，则需要人工修改，否则，git 将相当于 base 变化来决定最终结果\n&#x2F;&#x2F; base\nconsole.log(&#39;hello world&#39;)\n\n&#x2F;&#x2F; mine\nconsole.log(&#39;hello world&#39;)\n\n&#x2F;&#x2F; theirs\nconsole.log(&#39;world hello&#39;)\n\nbase: 代表 mine 和 theirs 的公共祖先 mine: 代表本地修改 theirs: 代表合并其他人修改\n当前的情况表示代码其他人有修改，但是本地没有修改，则 git 会自动把结果合并为 theirs 的代码\nconsole.log(&#39;world hello&#39;)\n\n\n如果本地文件被修改，合并的分支也有修改\n&#x2F;&#x2F; base\nconsole.log(&#39;hello world&#39;)\n\n&#x2F;&#x2F; mine\nconsole.log(&#39;hello world 1111&#39;)\n\n&#x2F;&#x2F; theirs\nconsole.log(&#39;world hello&#39;)\n\ngit 无法合并，需要人为进行合并\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; Mine\nconsole.log(&#39;hello world 1111&#39;)\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nconsole.log(&#39;world hello&#39;)\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; Theirs\n\n\n简单示例\n1-9 表示每个修改后的 commit 以及一个唯一的 hash 值。\n2 开始分出了一个 dev 分支， 4 7 是 master 上的提交，3 5 8 是 dev 上的提交\n现在要合并 7 和 8，可以把 git 提交记录看成一个有向无环图，这样就可以找到 2 为他们的 base 节点，就可以用来对比文件是否有修改\n递归三路合并原理\n\n0: 的位置创建了 a.js\n\nconsole.log(&#39;a&#39;)\n\ngit add .\ngit commit -m &quot;0&quot;\n\n\n1: 的位置从 master 上创建了一个新的分支 test1，并且创建了一个提交，没有修改 a.js\n\ngit checkout -b test1\n# 用于创建提交\ntouch test1.js\ngit add .\ngit commit -m &quot;1&quot;\n\n\n2: 的位置在 master 中创建了一个提交，没有修改 a.js\n\ngit checkout master\n# 用于创建提交\ngit touch test2.js\ngit add .\ngit commit -m &quot;2&quot;\n\n\n3: 的位置在 test1 中创建了一个提交，没有修改 a.js\n\ngit checkout test1\ngit touch test3.js\ngit add .\ngit commit -m &quot;3&quot;\n\n\n4: 的位置在 master 中修改了 a.js，并且创建了一个提交\n\nconsole.log(&#39;b&#39;)\n\ngit checkout master\ngit add .\ngit commit -m &quot;4&quot;\n\n\n5: 的位置从 master 上创建了一个新的分支 test2，并且合并了 test1 的代码，即合并 4 和 3 的代码，从前面可知，4 修改了 a.js 的代码，test1 分支中没有修改 a.js，他们的公共祖先是 0\n\ngit checkout -b test2\ngit merge test1\n\n&#x2F;&#x2F; 0\nconsole.log(&#39;a&#39;)\n\n&#x2F;&#x2F; 3\nconsole.log(&#39;a&#39;)\n\n&#x2F;&#x2F; 4\nconsole.log(&#39;b&#39;)\n\n由此对比出，合并后的为 4 中的内容，因为 3 没有修改该文件\nconsole.log(&#39;b&#39;)\n\n\n6: 的位置切换到了 master 分支，并且合并了 test1 的代码，即合并 3 和 4 的代码，原理和 5 一致\n\ngit checkout master\ngit merge test1\n\n\n7: 的位置切换到了 test2 分支，并且修改 a.js 的代码，创建了一个提交\n\nconsole.log(&#39;c&#39;)\n\ngit checkout test2\ngit add .\ngit commit -m &quot;7&quot;\n\n\n8: 的位置切换到了 master ，合并 test2 的代码，即合并6 和 7 此时，\n\ngit checkout master\ngit merge test2\n\n6 和 7 有两个公共的祖先，4 和 3， 这时候会递归的去找 4 和 3 的祖先，则是 0，先合并 4 和 3，生成临时的节点，假设为 x ，根据上面的结论，x 中 a.js 为\nconsole.log(&#39;b&#39;)\n\n然后把 x 当作 6 和 7 的祖先，进行合并\n&#x2F;&#x2F; x\nconsole.log(&#39;b&#39;)\n\n&#x2F;&#x2F; 6\nconsole.log(&#39;b&#39;)\n\n&#x2F;&#x2F; 7 \nconsole.log(&#39;c&#39;)\n\n所以合并结果为\nconsole.log(&#39;c&#39;)\n","slug":"gitMerge","date":"2022-05-18T16:00:00.000Z","categories_index":"原理","tags_index":"GIT","author_index":"SKY"},{"id":"df69bf2a71d2ba449a532d953647cc2a","title":"TypeScript 类型","content":"TypeScript 类型基本类型js 运行时类型\nnumber\nboolean\nstring\nobject\nbigint\nsymbol\nundefined\nnull\n\nts 中的包装类型\nNumber\nBoolean\nString\nObject\nSymbol\n\n复合类型JS 中的 class Array TypeScript 都支持，新增了三种类型：元组（Tuple）、接口（interface）、枚举（Enum）\n元组元组（Tuple）就是元素个数和类型固定的数组类型\ntype Tuple &#x3D; [number, string]\n\n接口接口（interface）可以描述函数、对象、构造器的结构\n对象interface IPerson &#123;\n  name: string\n  age: number\n&#125;\n\nclass Person extends IPerson &#123;\n  name: string\n  age: number\n&#125;\n\nconst obj: IPerson &#x3D; &#123;\n  name: &#39;sky&#39;,\n  age: 18\n&#125;\n\n对象类型、class 类型在 TypeScript 中也叫做索引类型，可以索引多个元素类型的意思。对象可以动态添加属性，如果不知道属性名，可以用索引签名：\ninterface IPerson &#123;\n  [prop: string]: string | number\n&#125;\n\nconst obj: IPerson &#x3D; &#123;&#125;\nobj.name &#x3D; &#39;sky&#39;\nobj.age &#x3D; 18\n\n函数\n普通函数\n\ninterface SayHi &#123;\n  (name: string): string\n&#125;\n\nconst func: SayHi &#x3D; function (name: string) &#123;\n  return &#39;hello &#39; + name\n&#125;\n\n\n构造器函数\n\ninterface IPerson &#123;\n  name: string\n  age: number\n&#125;\n\ninterface PersonConstructor &#123;\n  new(name: string, age: number): IPerson\n&#125;\n\nfunction createPerson(ctor: PersonConstructor): IPerson &#123;\n  return new ctor(&#39;sky&#39;, 18)\n&#125;\n\n总之，接口可以用来描述函数、构造器、索引类型（对象、class、数组）等复合类型。\n枚举枚举（Enum）是一系列值的复合：\nenum Week &#123;\n  MONDAY &#x3D; &#39;monday&#39;,\n  TUESDAY &#x3D; &#39;tuesday&#39;,\n  WEDNESDAY &#x3D; &#39;wednesday&#39;,\n  THURSDAY &#x3D; &#39;thursday&#39;,\n  FRIDAY &#x3D; &#39;friday&#39;,\n  SATURDAY &#x3D; &#39;saturday&#39;,\n  SUNDAY &#x3D; &#39;sunday&#39;\n&#125;\n\nconst week &#x3D; Week.MONDAY\n\n字面量类型typescript 还支持字面量类型，也就是类似下面的类型。\ntype A1 &#x3D; 11\ntype A2 &#x3D; &#39;a2&#39;\ntype A3 &#x3D; &#123; a: 1 &#125;\n\n字符串的字面量类型有两种\n\n普通的字符串字面量，比如 ‘aaa’\n模板字面量，比如下面的情况，表示该字符串只能以 aaa 开头\n\ntype A4 &#x3D; &#96;aaa&#123;string&#125;&#96;\n\nconst a: A4 &#x3D; &#39;aaa1&#39;\n\n其他类型\nvoid 代表空，可以是 null 或者 undefined，一般用于函数返回值。\nany 是任意类型，任何类型都可以赋值给它，它也可以赋值给任何类型（除了 never）。\nunknown 是未知类型，任务类型都可以赋值给它，但是它不可以赋值给其他类型。\nnever 代表不可达，比如函数抛异常的时候，返回值就是 never。\n\n类型的装饰除了描述类型的结构外，TypeScript 还支持描述类型的属性，比如是否可选，是否只读等：\ninterface IPerson &#123;\n  readonly name: string\n  age?: number\n&#125;\n\ntype tuple &#x3D; [string, number?]\n\nTypeScript 类型系统中的类型运算条件 extends ? :TypeScript 条件判断是 extends ? :，叫做条件类型（Conditional Type），比如：\ntype res &#x3D; 1 extends 2 ? true : false\n\n等价于\ntype res &#x3D; false\n\n类似与 JavaScript 中的 if - else\n静态类型运算是没有什么太多的意义，可以用动态类型来运算，也就是对类型参数的运算。\ntype isTwo&lt;T&gt; &#x3D; T extends 2 ? true : false\n\ntype res &#x3D; isTwo&lt;1&gt;\ntype res1 &#x3D; isTwo&lt;2&gt;\n\n等价于\ntype res &#x3D; false\ntype res1 &#x3D; true\n\n这类型也叫做高级类型，高级类型的特点是传入类型参数，经过一系列类型运算逻辑后，返回的新的类型\n推导 inferinfer 用于提取类型的一部分，比如提取元组类型的第一个元素：\ntype First&lt;Tuple extends unknown[]&gt; &#x3D; Tuple extends [infer T, ...infer R] ? T : never\n\ntype res &#x3D; First&lt;1, 2, 3&gt;\n\n等价于\ntype res &#x3D; 1\n\n注意：第一个 extends 不是条件，条件类型是 extends ? :，这里的 extends 是约束的意思，也就是约束 Tuple 只能是数组类型，因为不知道数组的具体类型，所以用 unknown\n联合 |联合类型（Union）类似 js 里的或运算符 |，但是作用于类型，代表类型可以是这几个类型之一。\ntype Union &#x3D; 1 | 2 | 3\n\n交叉 &amp;交叉类型（Intersection）类似 js 中的与运算符 &amp;，但是作用于类型，代表对类型的合并。\ntype ObjType &#x3D; &#123; a: number &#125; &amp; &#123; b: boolean &#125;\n\n等价于\ntype ObjType &#x3D; &#123;\n  a: number\n  b: boolean\n&#125;\n\n注意，同一类型可以合并，不同的类型没法合并，会被舍弃：\ntype res &#x3D; &#39;aaa&#39; &amp; 2222\n\n等价于\ntype res &#x3D; never\n\n映射类型对象、class 在 TypeScript 对应的类型是索引类型（Index Type，如何对索引类型作修改？\n那就是映射类型\ntype MapType&lt;T&gt; &#x3D; &#123;\n  [Key in keyof T]?: T[Key]\n&#125;\n\nkeyof T 是查询索引类型中的所有索引，叫做索引查询T[Key] 是取索引类型某个索引的值，叫做索引访问\nin 是用于遍历联合类型的运算符。\n比如把一个索引类型的值变为 3 个元素的数组：\ntype MapType&lt;T&gt; &#x3D; &#123;\n  [Key in keyof T]: [T[Key], T[Key], T[Key]]\n&#125;\n\ntype res &#x3D; MapType&lt;&#123;\n  a: 1\n  b: 2\n&#125;&gt;\n\n等价于\ntype res &#x3D; &#123;\n  a: [1, 1, 1]\n  b: [2, 2, 2]\n&#125;\n\n映射类型相当于把一个集合映射到了另一个集合\n\n除了值可以变化，索引也可以做变化，用 as 运算符，叫做重映射\ntype MapType&lt;T&gt; &#x3D; &#123;\n  [key in keyof T as &#96;$&#123;key &amp; string&#125;$&#123;key &amp; string&#125;$&#123;key &amp; string&#125;&#96;]: [T[key], T[key], T[key]]\n&#125;\ntype res &#x3D; MapType&lt;&#123; a: 1, b: 2 &#125;&gt;\n\n等价于\ntype res &#x3D; &#123;\n  aaa: [1, 1, 1],\n  bbb: [2, 2, 2],\n&#125;\n\n这里 &amp; string 解释一下： 因为索引类型（对象、class 等）可以用 string、number 和 symbol 作为 key， 这里 keyof T 取出来的索引就是 string|number|symbol的联合类型。 和 string 取交叉部分就只剩下 string 了。\n\n","slug":"typescriptType","date":"2022-05-17T16:00:00.000Z","categories_index":"编程","tags_index":"TYPESCRIPT","author_index":"SKY"},{"id":"9aecd670d0e041c4ae0eeba9f323dfdf","title":"TypeScript 系列","content":"TypeScript 系列TypeScript 类型TypeScriptType\n","slug":"typescriptSeries","date":"2022-05-17T16:00:00.000Z","categories_index":"编程","tags_index":"TYPESCRIPT","author_index":"SKY"},{"id":"f2b153f889628df8257fd406071bc211","title":"programming challenge","content":"编程挑战实现链式调用1&#x2F;&#x2F; 实现 arrange(&#39;William&#39;).wait(5).do(&#39;commit&#39;).wait(5).do(&#39;push&#39;).execute();\nclass Arrange &#123;\n  constructor(value) &#123;\n    this.value &#x3D; value\n  &#125;\n\n  wait(delay) &#123;\n    &#x2F;&#x2F; push 一个函数，返回 Promise 的一个定时器，使用 Promise 可以保证执行顺序\n    this.queue.push(() &#x3D;&gt; new Promise(resolve &#x3D;&gt; &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n        resolve(&#39;delay &#39; + delay)\n      &#125;, delay)\n    &#125;))\n\n    &#x2F;&#x2F; 返回实例对象\n    return this\n  &#125;\n\n  do(action) &#123;\n    &#x2F;&#x2F; push 一个函数，返回 Promise 的值\n    this.queue.push(() &#x3D;&gt; &#123;\n      return new Promise(resolve &#x3D;&gt; resolve(action))\n    &#125;)\n    &#x2F;&#x2F; 返回实例对象\n    return this\n  &#125;\n\n  &#x2F;**\n   * 同步调用，利用 async-await 进行等待\n   *&#x2F;\n  async execute() &#123;\n    for (const fn of this.queue) &#123;\n      const res &#x3D; await fn()\n      console.log(res)\n    &#125;\n    console.log(this.value)\n  &#125;\n\n  &#x2F;**\n   * 异步调用，利用 Promise.then 进行递归等待，保证顺序执行\n   *&#x2F;\n  syncExecute() &#123;\n    if (this.queue.length) &#123;\n      &#x2F;&#x2F; 推出数组第一个开始执行\n      this.queue.shift()()\n        .then(res &#x3D;&gt; &#123;\n          console.log(res)\n          &#x2F;&#x2F; 递归执行下一个指令\n          this.syncExecute()\n        &#125;)\n    &#125; else &#123;\n      console.log(this.value)\n    &#125;\n  &#125;\n&#125;\n\nfunction arrange(value): Arrange &#123;\n  return new Arrange(value)\n&#125;\n\narrange(&#39;William&#39;)\n  .wait(1000)\n  .do(&#39;commit&#39;)\n  .do(&#39;push2&#39;)\n  .wait(1000)\n  .do(&#39;push3&#39;)\n  .wait(1000)\n  .do(&#39;push4&#39;)\n  .wait(1000)\n  .do(&#39;push5&#39;)\n  .execute()\n&#x2F;&#x2F; .syncExecute()\n\n&#x2F;&#x2F; 结果\n&#x2F;&#x2F; delay 1000\n&#x2F;&#x2F; commit\n&#x2F;&#x2F; push2\n&#x2F;&#x2F; delay 1000\n&#x2F;&#x2F; push3\n&#x2F;&#x2F; delay 1000\n&#x2F;&#x2F; push4\n&#x2F;&#x2F; delay 1000\n&#x2F;&#x2F; push5\n&#x2F;&#x2F; William\n\n实现链式调用2实现变量 u 以满足以下条件：\n\n支持链式调用；\n执行 setTimeout 后，代码将会阻塞停滞，在指定时间以后继续执行。\n\nu.console(&#39;breakfast&#39;) &#x2F;&#x2F; 在控制台输出 &#39;breakfast&#39;\n  .setTimeout(3000)    &#x2F;&#x2F; 延迟 3s\n  .console(&#39;lunch&#39;)    &#x2F;&#x2F; 在控制台输出 &#39;lunch&#39;\n  .setTimeout(3000)    &#x2F;&#x2F; 延迟 3s\n  .console(&#39;dinner&#39;)   &#x2F;&#x2F; 在控制台输出 &#39;dinner&#39;\n\nclass U &#123;\n  constructor() &#123;\n    this.tasks &#x3D; []\n    this.next()\n  &#125;\n\n  console(data) &#123;\n    this.tasks.push(() &#x3D;&gt; &#123;\n      console.log(data)\n      this.next()\n    &#125;)\n    return this\n  &#125;\n\n  setTimeout(time) &#123;\n    this.tasks.push(() &#x3D;&gt; &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n        this.next()\n      &#125;, time)\n    &#125;)\n\n    return this\n  &#125;\n\n  next() &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      const fn &#x3D; this.tasks.shift()\n      fn &amp;&amp; fn()\n    &#125;, 0)\n  &#125;\n&#125;\n\n\nnew U().console(&#39;breakfast&#39;)\n  .setTimeout(3000)\n  .console(&#39;lunch&#39;)\n  .setTimeout(3000)\n  .console(&#39;dinner&#39;)\n\n\n实现柯里化&#x2F;&#x2F; 实现函数柯里化\nfunction curry(fn) &#123;\n  &#x2F;&#x2F; 闭包缓存 fn\n  return function curryFn(...args) &#123;\n    &#x2F;&#x2F; 闭包缓存 args\n    if (fn.length &gt; args.length) &#123;\n      &#x2F;&#x2F; 如果参数小于函数参数，继续返回柯里化函数\n      return function () &#123;\n        &#x2F;&#x2F; 递归调用\n        return curryFn(...args.concat(Array.from(arguments)))\n      &#125;\n    &#125;\n    return fn(...args)\n  &#125;\n&#125;\n\nfunction add(a, b, c, d) &#123;\n  return a + b + c + d\n&#125;\n\nconst curried &#x3D; curry(add)\n\nconst fn1 &#x3D; curried(1)\nconst fn2 &#x3D; fn1(2)\nconst fn3 &#x3D; fn2(3)\nconsole.log(fn3(4))\nconsole.log(fn3(4, 5))\nconsole.log(fn3(4))\n\n&#x2F;&#x2F; 10\n&#x2F;&#x2F; 10\n&#x2F;&#x2F; 10\n\n实现 Scheduler 类实现 Scheduler 类，使得下面的输出成立\nconst timeout &#x3D; (time, value) &#x3D;&gt; new Promise(resolve &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; resolve(value), time)\n&#125;)\nconst scheduler &#x3D; new Scheduler(2)\nconst addTask &#x3D; (time, order, value?) &#x3D;&gt; &#123;\n  return scheduler.add(() &#x3D;&gt; timeout(time, value))\n    .then((value) &#x3D;&gt; &#123;\n      console.log(order)\n      return value\n    &#125;)\n&#125;\n\naddTask(1000, &#39;1&#39;, &#39;value111111&#39;).then(value &#x3D;&gt; console.log(value))\naddTask(500, &#39;2&#39;)\naddTask(300, &#39;3&#39;, &#39;311111&#39;).then(value &#x3D;&gt; console.log(value))\naddTask(400, &#39;4&#39;)\n&#x2F;&#x2F; output: 2 3 1 4\n\n\n使用 async-await 实现\n\nclass Scheduler &#123;\n  &#x2F;&#x2F; 并发数\n  concurrency: number\n  &#x2F;&#x2F; 当前运行数量\n  currentConcurrency: number &#x3D; 0\n  &#x2F;&#x2F; 阻塞队列\n  queue: Array&lt;any&gt; &#x3D; []\n\n  constructor(concurrency: number) &#123;\n    &#x2F;&#x2F; 最大并发数量\n    this.concurrency &#x3D; concurrency\n  &#125;\n\n  async add(callback: () &#x3D;&gt; any) &#123;\n    &#x2F;&#x2F; 如果超过了最大并发数量\n    if (this.currentConcurrency &gt;&#x3D; this.concurrency) &#123;\n      &#x2F;&#x2F; 阻塞在这里\n      await new Promise(resolve &#x3D;&gt; this.queue.push(resolve))\n    &#125;\n    &#x2F;&#x2F; 增加当前运行数\n    this.currentConcurrency++\n    &#x2F;&#x2F; 运行当前函数\n    const res &#x3D; await callback()\n    &#x2F;&#x2F; 减少当前运行数\n    this.currentConcurrency--\n\n    &#x2F;&#x2F; 判断队列中是否还有多余任务\n    if (this.queue.length) &#123;\n      &#x2F;&#x2F; 解除阻塞\n      this.queue.shift()()\n    &#125;\n    &#x2F;&#x2F; 返回执行结果\n    return res\n  &#125;\n&#125;\n\nconst timeout &#x3D; (time, value) &#x3D;&gt; new Promise(resolve &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; resolve(value), time)\n&#125;)\nconst scheduler &#x3D; new Scheduler(2)\nconst addTask &#x3D; (time, order, value?) &#x3D;&gt; &#123;\n  return scheduler.add(() &#x3D;&gt; timeout(time, value))\n    .then((value) &#x3D;&gt; &#123;\n      console.log(order)\n      return value\n    &#125;)\n&#125;\n\naddTask(1000, &#39;1&#39;, &#39;value111111&#39;).then(value &#x3D;&gt; console.log(value))\naddTask(500, &#39;2&#39;)\naddTask(300, &#39;3&#39;, &#39;311111&#39;).then(value &#x3D;&gt; console.log(value))\naddTask(400, &#39;4&#39;)\n&#x2F;&#x2F; output: 2 3 1 4\n\n\n使用 Promise 实现\n\nclass Scheduler &#123;\n  &#x2F;&#x2F; 并发数\n  concurrency: number\n  &#x2F;&#x2F; 当前运行数量\n  currentConcurrency: number &#x3D; 0\n  &#x2F;&#x2F; 阻塞队列\n  queue: Array&lt;any&gt; &#x3D; []\n\n  constructor(concurrency: number) &#123;\n    &#x2F;&#x2F; 最大并发数量\n    this.concurrency &#x3D; concurrency\n  &#125;\n\n  addSync(callback: () &#x3D;&gt; Promise&lt;any&gt;) &#123;\n    &#x2F;&#x2F; 返回一个 promise 对象\n    return new Promise(resolve &#x3D;&gt; &#123;\n      if (this.currentConcurrency &gt;&#x3D; this.concurrency) &#123;\n        &#x2F;&#x2F; 使用 promise 进行阻塞，因为没有调用 resolve1 方法\n        new Promise(resolve1 &#x3D;&gt; &#123;\n          this.queue.push(resolve1)\n        &#125;)\n          .then(() &#x3D;&gt; &#123;\n            &#x2F;&#x2F; 解除后则可以运行任务\n            this.runJob(resolve, callback)\n          &#125;)\n      &#125; else &#123;\n        &#x2F;&#x2F; 运行任务\n        this.runJob(resolve, callback)\n      &#125;\n    &#125;)\n  &#125;\n\n  runJob(resolve, callback: () &#x3D;&gt; Promise&lt;any&gt;) &#123;\n    &#x2F;&#x2F; 开始运行任务\n    this.currentConcurrency++\n    callback()\n      .then(res &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 任务执行完毕\n        this.currentConcurrency--\n        if (this.queue.length) &#123;\n          &#x2F;&#x2F; 解除后面的任务\n          this.queue.shift()()\n        &#125;\n        &#x2F;&#x2F; 返回结果\n        resolve(res)\n      &#125;)\n  &#125;\n&#125;\n\nconst timeout &#x3D; (time, value) &#x3D;&gt; new Promise(resolve &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; resolve(value), time)\n&#125;)\nconst scheduler &#x3D; new Scheduler(2)\n\nconst addTaskSync &#x3D; (time, order, value?) &#x3D;&gt; &#123;\n  return scheduler.addSync(() &#x3D;&gt; timeout(time, value))\n    .then((value) &#x3D;&gt; &#123;\n      console.log(order)\n      return value\n    &#125;)\n&#125;\n\naddTaskSync(1000, &#39;1&#39;, &#39;value111111&#39;).then(value &#x3D;&gt; console.log(value))\naddTaskSync(500, &#39;2&#39;)\naddTaskSync(300, &#39;3&#39;, &#39;311111&#39;).then(value &#x3D;&gt; console.log(value))\naddTaskSync(400, &#39;4&#39;)\n&#x2F;&#x2F; output: 2 3 1 4\n\n","slug":"programmingChallenge","date":"2022-05-14T16:00:00.000Z","categories_index":"教程","tags_index":"JAVASCRIPT","author_index":"SKY"},{"id":"c72fb498b1064492902648005ad6e6d9","title":"VueRouter 中重定向到动态的 path","content":"VueRouter背景在 vue-router 中，重定向到某个页面采用下面的配置\nconst routes &#x3D; [\n  &#123;\n    path: &#39;&#x2F;test&#39;,\n    redirect: &#39;&#x2F;aaa&#39;,\n  &#125;,\n]\n\n但是如果 redirect 中的路径需要动态生成，由于定义的时候是同步代码，无法直接给 redirect 赋值。\nasync function reqRedirectUrl() &#123;\n  return &#39;&#x2F;aaa&#39;\n&#125;\n\nconst routes &#x3D; [\n  &#123;\n    path: &#39;&#x2F;test&#39;,\n    redirect: &#39;***&#39;,\n  &#125;,\n]\n\n解决方案在定义路由是，使用 beforeEnter 进行拦截，该函数可以定义为 async 函数，里面就可以获取到了动态的路径，再把路径传入到 next 中，实现了动态的重定向\nasync function reqRedirectUrl() &#123;\n  return &#39;&#x2F;aaa&#39;\n&#125;\n\nconst routes &#x3D; [\n  &#123;\n    path: &#39;&#x2F;test&#39;,\n    &#x2F;&#x2F; vue 3 需要加上重定向字段，值随便写\n    &#x2F;&#x2F; redirect: &#39;&#39;,\n    async beforeEnter (to, from, next) &#123;\n      next(await reqRedirectUrl())\n    &#125;\n  &#125;,\n]\n\n","slug":"vueRouter","date":"2022-05-12T16:00:00.000Z","categories_index":"前端","tags_index":"VUE,VUE_ROUTER","author_index":"SKY"},{"id":"1b9460a162c49b16fb160e6d1e730cf3","title":"should 问题记录","content":"Should.js 使用问题记录should.extend 方法should 的基本原理就是在 Object.prototype 上定义一个 should 对象，拦截 get，进行特殊处理。\nshould$1.extend &#x3D; function (propertyName, proto) &#123;\n  propertyName &#x3D; propertyName || &quot;should&quot;;\n  proto &#x3D; proto || Object.prototype;\n\n  var prevDescriptor &#x3D; Object.getOwnPropertyDescriptor(proto, propertyName);\n\n  Object.defineProperty(proto, propertyName, &#123;\n    set: function () &#123;\n    &#125;,\n    get: function () &#123;\n      return should$1(isWrapperType(this) ? this.valueOf() : this);\n    &#125;,\n    configurable: true\n  &#125;);\n\n  return &#123;name: propertyName, descriptor: prevDescriptor, proto: proto&#125;;\n&#125;;\n\nshould.noConflict 方法删除掉对象中 proto 中的 should 对象，取消 should 对属性读取的拦截\nshould$1.noConflict &#x3D; function (desc) &#123;\n  desc &#x3D; desc || should$1._prevShould;\n\n  if (desc) &#123;\n    delete desc.proto[desc.name];\n\n    if (desc.descriptor) &#123;\n      Object.defineProperty(desc.proto, desc.name, desc.descriptor);\n    &#125;\n  &#125;\n  return should$1;\n&#125;;\n\n导致的问题如果代码中有一个对象中，想要额外增加一个 should 的属性，正好重名，那就永远访问也不能覆盖掉这个should。 这时就会导致代码中缺少了 should 中的对象，导致代码出错。\nrequire(&#39;should&#39;)\n\nconst a &#x3D; &#123;\n  a: 1,\n  b: 2,\n&#125;\n\n&#x2F;&#x2F; 此时的 should 是 should.Assertion 对象，无法重新赋值\na.should &#x3D; &#123;\n  a: 1,\n  b: 2\n&#125;\n\nconsole.log(a)\n&#x2F;&#x2F; 打印结果\n&#x2F;&#x2F; &#123;a: 1,b: 2&#125;\n\n解决办法const should &#x3D; require(&#39;should&#39;)\n\n&#x2F;&#x2F; 关闭 should 的拦截，保证这次测试可以使用\nshould.noConflict()\nconst a &#x3D; &#123;\n  a: 1,\n  b: 2,\n&#125;\n\na.should &#x3D; &#123;\n  a: 1,\n  b: 2\n&#125;\n\nconsole.log(a)\n&#x2F;&#x2F; &#123; a: 1, b: 2, should: &#123; a: 1, b: 2 &#125; &#125;\n\n&#x2F;&#x2F; 重新开启 should 的拦截，保证后续的测试可以继续使用 should\nshould.extend()\n\n","slug":"should","date":"2022-03-29T16:00:00.000Z","categories_index":"原理","tags_index":"JAVASCRIPT,TEST","author_index":"SKY"},{"id":"c20284a31a34295c2d86d295e5cf6162","title":"GITHUB Action","content":"GitHub action自动发布 NPM 包npm 配置 access token点击 npm 用户头像，选择 access tokens\n\n点击 generate new token\n\n选择 publish 点击 generate token\n\n复制 token\n\ngithub 项目中配置 npm access token 环境变量进入 github 项目，点击 settings，然后点击左侧 secrets，在右边点击 new repository secret\n\nName 输入想要的名字，这里设置为 NPM，value 则是在 npm 生成的 access token，点击 add secret\n\ntoken 配置完成\n\n项目创建 github action 执行文件项目中创建配置文件\n项目根目录：./github/workflows/publish.yml\nname: Public Npm\n\non:\n  push:\n    # 指定工作分支名，后续一般是 main，或者自定义\n    branches: [ master ]\n\njobs:\n  publish:\n    runs-on: ubuntu-latest\n\n    name: &#39;publish npm&#39;\n\n    environment: npm\n\n    steps:\n      - uses: actions&#x2F;checkout@master\n\n      - name: Install and Build\n        # 如果需要编译，需要在 package.json 中配置相应的编译命令 npm run build\n        run: |\n          npm install\n          npm run build\n\n      - name: &#39;Publish to the npm registry&#39;\n        uses: primer&#x2F;publish@3.0.0\n        env:\n          GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;\n          # secrets.NPM 这是在 github 项目中创建的环境变量名\n          NPM_AUTH_TOKEN: $&#123;&#123; secrets.NPM &#125;&#125;\n        with:\n          # 默认的分支\n          default_branch: &#39;master&#39;\n\n修改代码和版本提交代码即可代码修改后，执行定义版本即可，最后提交代码到 github 上即可自动运行。\n\n其他简单示例相关环境变量参考上文配置 npm access token\nNode 相关on:\n  push:\n    branches: [ main ]\n\njobs:\n  install:\n    runs-on: ubuntu-latest\n    name: &#39;install dependencies and build image&#39;\n    strategy:\n      matrix:\n        # 设置 node 版本\n        node-version: [ 14.x ]\n    steps:\n      - uses: actions&#x2F;checkout@v3\n        with:\n          ref: master\n      # 使用版本\n      - uses: actions&#x2F;setup-node@v2\n        with:\n          node-version: $&#123;&#123;matrix.node-version&#125;&#125;\n          cache: &#39;npm&#39;\n      # 安装依赖\n      - name: Build Project\n        run: |\n          npm install\n          npm run build、\n      # 镜像构造\n      - name: Build image and Push\n        run: |\n          docker build -t $&#123;&#123;secrets.HOST&#125;&#125;&#x2F;$&#123;&#123;secrets.NAMESPACE&#125;&#125;&#x2F;$&#123;&#123;secrets.REPO&#125;&#125;:$&#123;GITHUB_SHA:0:8&#125; .\n          docker save $&#123;&#123;secrets.HOST&#125;&#125;&#x2F;$&#123;&#123;secrets.NAMESPACE&#125;&#125;&#x2F;$&#123;&#123;secrets.REPO&#125;&#125;:$&#123;GITHUB_SHA:0:8&#125; &gt; image.tar\n      # 上传镜像文件到下一个任务使用\n      - uses: actions&#x2F;upload-artifact@v2\n        with:\n          name: image\n          path: image.tar\n\ndocker 打包on:\n  push:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    # 使用 docker 镜像\n    container: docker:18\n    name: &#39;Build docker image&#39;\n    # 表示在 install 任务后才会被执行\n    needs: [ install ]\n\n    steps:\n      # 下载上一个任务编译后的文件\n      - uses: actions&#x2F;download-artifact@v2\n        with:\n          name: skyfury-test\n          path: .\n      # 通过命令镜像 docker 打包和上传，tag 为 该次提交的 SHA 值前八位，镜像仓库可以国内云服务商申请，腾讯云个人免费\n      - name: Build image\n        run: |\n          docker login $HOST -u $USERNAME -p $PASSWORD\n          docker build -t $HOST&#x2F;$NAMESPACE&#x2F;$REPO:$&#123;GITHUB_SHA:0:8&#125; .\n          docker tag $HOST&#x2F;$NAMESPACE&#x2F;$REPO:$&#123;GITHUB_SHA:0:8&#125; $HOST&#x2F;$NAMESPACE&#x2F;$REPO:latest\n          docker push $HOST&#x2F;$NAMESPACE&#x2F;$REPO:$&#123;GITHUB_SHA:0:8&#125;\n          docker push $HOST&#x2F;$NAMESPACE&#x2F;$REPO:latest\n        env:\n          USERNAME: $&#123;&#123; secrets.USERNAME &#125;&#125;\n          PASSWORD: $&#123;&#123; secrets.PASSWORD &#125;&#125;\n          HOST: $&#123;&#123; secrets.HOST &#125;&#125;\n          NAMESPACE: $&#123;&#123; secrets.NAMESPACE &#125;&#125;\n          REPO: $&#123;&#123; secrets.REPO &#125;\n\n通过 ssh 部署简单的通过 ssh 的方式进行部署项目，DEPLOY_TOKEN 为服务器上的私钥，经过 base64 编码，然后通过 ssh 进行镜像下载和运行容器。\n如果需要回滚容器，可以通过 docker 的 service，\n需要提前在服务器上创建 servicedocker service create --with-registry-auth -p 7001:7001 --name $REPO $HOST/$NAMESPACE/$REPO:$&#123;GITHUB_SHA:0:8&#125;\n然后通过 action 进行更新docker service update --image $HOST/$NAMESPACE/$REPO:$&#123;GITHUB_SHA:0:8&#125; $REPO&quot;\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    # 可以部署到 k8s 的容器 kubectl，也包含 docker 命令\n    container: roffe&#x2F;kubectl\n    name: &#39;Deploy my blog&#39;\n    needs: [ install,build ]\n    steps:\n      - name: Deploy project\n        run: |\n          echo &quot;$DEPLOY_TOKEN&quot; | base64 -d &gt; id_rsa\n          chmod 700 id_rsa\n          apk add openssh\n          ssh -o StrictHostKeyChecking&#x3D;no -i id_rsa $SERVER_HOST &quot;\n          docker login $HOST -u $USERNAME -p $PASSWORD\n          docker pull $HOST&#x2F;$NAMESPACE&#x2F;$REPO:$&#123;GITHUB_SHA:0:8&#125;\n          docker stop $REPO\n          docker run -itd --rm --name $REPO -p 8001:80 $HOST&#x2F;$NAMESPACE&#x2F;$REPO:$&#123;GITHUB_SHA:0:8&#125;&quot;\n        env:\n          DEPLOY_TOKEN: $&#123;&#123; secrets.DEPLOY_TOKEN &#125;&#125;\n          USERNAME: $&#123;&#123; secrets.USERNAME &#125;&#125;\n          PASSWORD: $&#123;&#123; secrets.PASSWORD &#125;&#125;\n          HOST: $&#123;&#123; secrets.HOST &#125;&#125;\n          NAMESPACE: $&#123;&#123; secrets.NAMESPACE &#125;&#125;\n          REPO: $&#123;&#123; secrets.REPO &#125;&#125;\n          SERVER_HOST: $&#123;&#123; secrets.SERVER_HOST &#125;\n","slug":"githubActionPublishNpmPackage","date":"2022-03-17T16:00:00.000Z","categories_index":"教程","tags_index":"GITHUB,NPM","author_index":"SKY"},{"id":"411e38e243c7e138bbc30ef1fc032baa","title":"ES Module","content":"ES Module模块演变过程1. 基于文件的划分模块的方式将每个功能及其相关状态数据各自单独放到不同的文件中，约定每个文件就是一个独立的模块，使用某个模块就是将这个模块引入到页面中，然后直接调用模块中的成员（变量/函数）\n缺点： 所有的模块都直接在全局工作，没有私有的空间，所有成员都可以在模块外部被访问或者修改，而且模块一旦多了过后，容易产生命名冲突，另外无法管理模块与模块之间的依赖关系\n&#x2F;&#x2F; module-a.js\nvar name &#x3D; &#39;module-a&#39;\n\nfunction method1() &#123;\n  console.log(name + &#39;#method1&#39;)\n&#125;\n\nfunction method2() &#123;\n  console.log(name + &#39;#method2&#39;)\n&#125;\n\n&#x2F;&#x2F; module-b.js\nvar name &#x3D; &#39;module-b&#39;\n\nfunction method1() &#123;\n  console.log(name + &#39;#method1&#39;)\n&#125;\n\nfunction method2() &#123;\n  console.log(name + &#39;#method2&#39;)\n&#125;\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n    &lt;title&gt;Modular evolution stage 1&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;script src&#x3D;&quot;module-a.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;module-b.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\n    &#x2F;&#x2F; 命名冲突\n    method1()\n    &#x2F;&#x2F; 模块成员可以被修改\n    name &#x3D; &#39;foo&#39;\n&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n结果输出：只输出了 module-b 中的方法，而且 name 也被修改\n\n2. 挂载到每个模块的全局变量中在上一阶段的基础上，通过将每个模块【包裹】 为一个全局对象的形式实现，有点类似于为模块内的成员 添加了【命名空间】的感觉\n优点： 通过【命名空间】减少了命名冲突的可能\n缺点： 同样没有私有的空间，所有模块成员也可以在模块外部被访问或者修改，而且也无法管理模块之间的依赖关系\n&#x2F;&#x2F; module-a.js\nvar moduleA &#x3D; &#123;\n  name: &#39;module-a&#39;,\n\n  method1: function () &#123;\n    console.log(this.name + &#39;#method1&#39;)\n  &#125;,\n\n  method2: function () &#123;\n    console.log(this.name + &#39;#method2&#39;)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; module-b.js\n&#x2F;&#x2F; module b 相关状态数据和功能函数\n\nvar moduleB &#x3D; &#123;\n  name: &#39;module-b&#39;,\n\n  method1: function () &#123;\n    console.log(this.name + &#39;#method1&#39;)\n  &#125;,\n\n  method2: function () &#123;\n    console.log(this.name + &#39;#method2&#39;)\n  &#125;\n&#125;\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n    &lt;title&gt;Modular evolution stage 2&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;script src&#x3D;&quot;module-a.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;module-b.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\n    moduleA.method1()\n    moduleB.method1()\n    &#x2F;&#x2F; 模块成员可以被修改\n    moduleA.name &#x3D; &#39;foo&#39;\n&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\na b 两个模块命名没有冲突，但是模块内的成员还是可以被修改\n\n3. 立即执行函数表达式使用立即执行函数表达式（IIFE：Immediately-Invoked Function Expression）为模块提供私有空间\n具体做法就是将每个模块成员都放在一个函数提供的私有作用域中，对于需要暴露给外部的成员，通过挂载到全局对象上的方式实现，有了私有成员的概念，私有成员只能在模块成员内通过必报的形式访问\n&#x2F;&#x2F; module-a.js\n;(function () &#123;\n  var name &#x3D; &#39;module-a&#39;\n\n  function method1() &#123;\n    console.log(name + &#39;#method1&#39;)\n  &#125;\n\n  function method2() &#123;\n    console.log(name + &#39;#method2&#39;)\n  &#125;\n\n  window.moduleA &#x3D; &#123;\n    method1: method1,\n    mothod2: method2,\n  &#125;\n&#125;)()\n\n&#x2F;&#x2F; module-b.js\n;(function () &#123;\n  var name &#x3D; &#39;module-b&#39;\n\n  function method1() &#123;\n    console.log(name + &#39;#method1&#39;)\n  &#125;\n\n  function method2() &#123;\n    console.log(name + &#39;#method2&#39;)\n  &#125;\n\n  window.moduleB &#x3D; &#123;\n    method1: method1,\n    method2: method2\n  &#125;\n&#125;)()\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n    &lt;title&gt;Modular evolution stage 3&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;script src&#x3D;&quot;module-a.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;module-b.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\n    moduleA.method1()\n    moduleB.method1()\n    &#x2F;&#x2F; 模块私有成员无法访问\n    console.log(moduleA.name) &#x2F;&#x2F; &#x3D;&gt; undefined\n&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n只能访问到暴露出来的方法，无法访问模块内的私有成员\n\n4. 利用 IIFE 参数作为依赖声明使用在第三阶段的基础上，利用立即执行函数的参数传递模块依赖项，这使得每一个模块之间的关系变得更加明显\n&#x2F;&#x2F; module a 相关状态数据和功能函数\n;(function ($) &#123;\n  var name &#x3D; &#39;module-a&#39;\n\n  function method1() &#123;\n    console.log(name + &#39;#method1&#39;)\n    $(&#39;body&#39;).animate(&#123;margin: &#39;200px&#39;&#125;)\n  &#125;\n\n  function method2() &#123;\n    console.log(name + &#39;#method2&#39;)\n  &#125;\n\n  window.moduleA &#x3D; &#123;\n    method1: method1,\n    method2: method2\n  &#125;\n&#125;)(jQuery)\n\n&#x2F;&#x2F; module b 相关状态数据和功能函数\n\n;(function () &#123;\n  var name &#x3D; &#39;module-b&#39;\n\n  function method1() &#123;\n    console.log(name + &#39;#method1&#39;)\n  &#125;\n\n  function method2() &#123;\n    console.log(name + &#39;#method2&#39;)\n  &#125;\n\n  window.moduleB &#x3D; &#123;\n    method1: method1,\n    method2: method2\n  &#125;\n&#125;)()\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n    &lt;title&gt;Modular evolution stage 4&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;jquery&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;module-a.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;module-b.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\n    moduleA.method1()\n    moduleB.method1()\n&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\nAMD 模块化规范Require.js 提供了 AMD 模块化规范，以及一个自动化模块加载器\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n    &lt;title&gt;Modular evolution stage 5&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;h1&gt;模块化规范的出现&lt;&#x2F;h1&gt;\n&lt;h2&gt;Require.js 提供了 AMD 模块化规范，以及一个自动化模块加载器&lt;&#x2F;h2&gt;\n&lt;script src&#x3D;&quot;lib&#x2F;require.js&quot; data-main&#x3D;&quot;main&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n&#x2F;&#x2F; main.js\nrequire.config(&#123;\n  paths: &#123;\n    &#x2F;&#x2F; 因为 jQuery 中定义的是一个名为 jquery 的 AMD 模块\n    &#x2F;&#x2F; 所以使用时必须通过 &#39;jquery&#39; 这个名称获取这个模块\n    &#x2F;&#x2F; 但是 jQuery.js 并不一定在同级目录下，所以需要指定路径\n    jquery: &#39;.&#x2F;lib&#x2F;jquery&#39;\n  &#125;\n&#125;)\n\nrequire([&#39;.&#x2F;modules&#x2F;module1&#39;], function (module1) &#123;\n  console.log(module1, &#39;module 1&#39;)\n  module1.start()\n&#125;)\n\n&#x2F;&#x2F; .&#x2F;modules&#x2F;module1.js\n&#x2F;&#x2F; 因为 jQuery 中定义的是一个名为 jquery 的 AMD 模块\n&#x2F;&#x2F; 所以使用时必须通过 &#39;jquery&#39; 这个名称获取这个模块\n&#x2F;&#x2F; 但是 jQuery.js 并不在同级目录下，所以需要指定路径\ndefine(&#39;module1&#39;, [&#39;jquery&#39;, &#39;.&#x2F;module2&#39;], function ($, module2) &#123;\n  return &#123;\n    start: function () &#123;\n      $(&#39;body&#39;).animate(&#123;margin: &#39;200px&#39;&#125;)\n      module2()\n    &#125;\n  &#125;\n&#125;)\n\n&#x2F;&#x2F; .&#x2F;modules&#x2F;module2.js\n&#x2F;&#x2F; 兼容 CMD 规范（类似 CommonJS 规范）\ndefine(function (require, exports, module) &#123;\n  &#x2F;&#x2F; 通过 require 引入依赖\n  var $ &#x3D; require(&#39;jquery&#39;)\n  &#x2F;&#x2F; 通过 exports 或者 module.exports 对外暴露成员\n  module.exports &#x3D; function () &#123;\n    console.log(&#39;module 2~&#39;)\n    $(&#39;body&#39;).append(&#39;&lt;p&gt;module2&lt;&#x2F;p&gt;&#39;)\n  &#125;\n&#125;)\n\nES Module浏览器中使用html 中使用在 html 中 script 标签添加 type=&quot;module&quot;，表示可以以 ES Module 的标准执行其中的 JS 代码 ESM自动采用了严格模式，忽略 ‘use strict’ 每个 ES Module 都是运行在单独的私有作用域中 ESM 可以通过 CORS 的方式请求外部的 JS模块 ESM 的 script 可以添加 defer ，会延迟执行脚步，即页面加载完成后才会执行\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n    &lt;title&gt;ES Module - 模块的特性&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;!-- 通过给 script 添加 type &#x3D; module 的属性，就可以以 ES Module 的标准执行其中的 JS 代码了 --&gt;\n&lt;script type&#x3D;&quot;module&quot;&gt;\n    console.log(&#39;this is es module&#39;)\n&lt;&#x2F;script&gt;\n\n&lt;!-- 1. ESM 自动采用严格模式，忽略 &#39;use strict&#39; --&gt;\n&lt;script type&#x3D;&quot;module&quot;&gt;\n    console.log(this)\n&lt;&#x2F;script&gt;\n\n&lt;!-- 2. 每个 ES Module 都是运行在单独的私有作用域中 --&gt;\n&lt;script type&#x3D;&quot;module&quot;&gt;\n    var foo &#x3D; 100\n    console.log(foo)\n&lt;&#x2F;script&gt;\n&lt;script type&#x3D;&quot;module&quot;&gt;\n    console.log(foo)\n&lt;&#x2F;script&gt;\n\n&lt;!-- 3. ESM 是通过 CORS 的方式请求外部 JS 模块的 --&gt;\n&lt;!-- &lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;jquery@3.4.1&#x2F;dist&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt; --&gt;\n\n&lt;!-- 4. ESM 的 script 标签会延迟执行脚本 --&gt;\n&lt;script defer src&#x3D;&quot;demo.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;p&gt;需要显示的内容&lt;&#x2F;p&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n第二个 module 中 foo 无法获取到第一个 module 的值，表明作用域是分开的 script defer 标签下面有个 p 标签，页面显示了 p标签的值才弹出对话框，表明脚步延迟执行\n\njs 中导出\n通过 export 单个导出属性、函数和类\n\n&#x2F;&#x2F; module.js\n&#x2F;&#x2F; 导出\nexport var name &#x3D; &#39;foo module&#39;\n\nexport function hello() &#123;\n  console.log(&#39;hello&#39;)\n&#125;\n\nexport class Person &#123;\n&#125;\n\n&#x2F;&#x2F; app.js\n&#x2F;&#x2F; 导入\nimport &#123;name, hello, Person&#125; from &#39;.&#x2F;module.js&#39;\n\nconsole.log(name, hello, Person)\n\n\n通过 export 导出一组成员\n\n&#x2F;&#x2F; module.js\n&#x2F;&#x2F; 导出\nvar name &#x3D; &#39;foo module&#39;\n\nfunction hello() &#123;\n  console.log(&#39;hello&#39;)\n&#125;\n\nclass Person &#123;\n&#125;\n\n&#x2F;&#x2F; 这种方式不是对象的方式，只是 export 的语法\nexport &#123;name, hello, Person&#125;\n\n&#x2F;&#x2F; app.js\n&#x2F;&#x2F; 导入\nimport &#123;name, hello, Person&#125; from &#39;.&#x2F;module.js&#39;\n\nconsole.log(name, hello, Person)\n\n\n通过 export 导出默认值\n\n&#x2F;&#x2F; module.js\n&#x2F;&#x2F; 导出\nvar name &#x3D; &#39;foo module&#39;\nexport default name\n\n&#x2F;&#x2F; app.js\n&#x2F;&#x2F; 导入\n&#x2F;&#x2F; 通过默认值重命名\nimport &#123;default as fooName&#125; from &#39;.&#x2F;module.js&#39;\n\nconsole.log(fooName)\n\n&#x2F;&#x2F; 直接修改 default 的命名\nimport name1 from &#39;.&#x2F;module.js&#39;\n\nconsole.log(name1)\n\n\n通过 export 导出，并且重命名\n\n&#x2F;&#x2F; module.js\n&#x2F;&#x2F; 导出\nvar name &#x3D; &#39;foo module&#39;\n\nfunction hello() &#123;\n  console.log(&#39;hello&#39;)\n&#125;\n\nexport &#123;\n  &#x2F;&#x2F; 重命名默认导出\n  name as default,\n  &#x2F;&#x2F; 更换 hello 的命名\n  hello as fooHello\n&#125;\n\n&#x2F;&#x2F; app.js\n&#x2F;&#x2F; 导入\nimport name1, &#123;fooHello&#125; from &#39;.&#x2F;module.js&#39;\n\nconsole.log(name1, fooHello)\n\n注意在 CommonJS 中是先将整个模块导入为一个对象，然后从对象中解构出需要的成员const &#123; name, age &#125; = require(&#39;./module.js&#39;)\n在 ES Module 中 {} 是固定的语法，就是直接提取模块导出成员\nimport &#123; name, age &#125; from &#39;./module.js\n在 ES Module 中导入成员并不是复制一个副本，而是直接导入模块成员的引用地址，也就是说 import 得到的变量与 export导出的变量在内存中是同一块空间。一旦模块中成员修改了，导入的地方也会修改。\nimport &#123;name, age&#125; from &#39;.&#x2F;module.js&#39;\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(name, age)\n&#125;)\n\n导入模块变量是只读的\nimport &#123;name&#125; from &#39;.&#x2F;module.js&#39;\n\nname &#x3D; &#39;tom&#39; &#x2F;&#x2F; 报错\n\n如果导入的是一个对象，对象的属性读写不受影响name.xxx = xxx\nexport &#123;&#125; 不是一个对象字面量，只是语法上的规则而已\nvar name &#x3D; &#39;jack&#39;\nvar age &#x3D; 18\nexport &#123;name, age&#125;\n\n&#x2F;&#x2F; 错误用法\n&#x2F;&#x2F; export name\n&#x2F;&#x2F; export &#39;foo&#39; \n\njs 中导入&#x2F;&#x2F; &#x2F;test&#x2F;module.js\nvar name &#x3D; &#39;jack&#39;\nvar age &#x3D; 18\n\nexport &#123;name, age&#125;\n\nconsole.log(&#39;module action&#39;)\n\nexport default &#39;default export&#39;\n\n&#x2F;&#x2F; &#x2F;test&#x2F;utils&#x2F;index.js\nexport function lowercase(input) &#123;\n  return input.toLowerCase()\n&#125;\n\n\n后缀不能省略\n\n&#x2F;&#x2F; from 后面需要跟文件的后缀，不能去除\nimport &#123;name&#125; from &#39;.&#x2F;module&#39;\n\n&#x2F;&#x2F; 正确用法\nimport &#123;name&#125; from &#39;.&#x2F;module.js&#39;\n\nconsole.log(name)\n\n\nindex.js 也不能省略\n\n&#x2F;&#x2F; 错误导入\nimport &#123;lowercase&#125; from &#39;utils&#39;\n\n&#x2F;&#x2F; 正确导入\nimport &#123;lowercase&#125; from &#39;utils&#x2F;index.js&#39;\n\nconsole.log(lowercase(&#39;HHH&#39;))\n\n\nfrom 后面导入包内的文件不能省略 ./\n\n&#x2F;&#x2F; 这样导入会被认为是导入了第三方包，回去 node_modules 中找包\nimport &#123;name&#125; from &#39;module.js&#39;\n\n&#x2F;&#x2F; .&#x2F; 不能省略\nimport &#123;name&#125; from &#39;.&#x2F;module.js&#39;\n\n&#x2F;&#x2F; 或者使用项目为绝对路径的方式导入\nimport &#123;name&#125; from &#39;&#x2F;test&#x2F;module.js&#39;\n\n&#x2F;&#x2F; 也可以通过网络的方式导入包\nimport &#123;name&#125; from &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;test&#x2F;module.js&#39;\n\nconsole.log(name)\n\n\n只导包，不使用\n\nimport &#123;&#125; from &#39;.&#x2F;module.js&#39;\n\nimport &#39;.&#x2F;module.js&#39;\n\n\n导出包中所有的内容\n\nimport * as mod from &#39;.&#x2F;module.js&#39;\n\nconsole.log(mod)\n\n\n不能通过变量或者条件判断的方式导入包\n\n错误导包\nconst modulePath &#x3D; &#39;.&#x2F;module.js&#39;\nimport &#123;name&#125; from &#39;modulePaht&#39;\n\n\nif (true) &#123;\n  &#x2F;&#x2F; 错误导入方式\n  &#x2F;&#x2F; import &#123;name&#125; from &#39;.&#x2F;module.js&#39;\n&#125;\n\n\n通过 import() 函数动态导入包\n\nimport()，函数返回了一个 Promise，可以在 then 中接受到这个模块对象\nimport(&#39;.&#x2F;module.js&#39;).then(module &#x3D;&gt; &#123;\n  console.log(module)\n&#125;)\n\n\n提取包中的值和默认的值\n\nimport &#123;name, age, default as title&#125; from &#39;.&#x2F;module.js&#39;\nimport abc, &#123;name, age&#125; from &#39;.&#x2F;module.js&#39;\n\n&#x2F;&#x2F; abc 和 title 都是 default 的值\n\n导入与导出&#x2F;&#x2F; components&#x2F;avatar.js\nexport var Avatar &#x3D; &#39;Avatar Component&#39;\n\n&#x2F;&#x2F; components&#x2F;button.js\nvar Button &#x3D; &#39;Button Component&#39;\n\nexport default Button\n\n把两个组件合并到一个文件中进行导出\n&#x2F;&#x2F; components&#x2F;index.js\nimport Button from &#39;.&#x2F;button.js&#39;\nimport &#123;Avatar&#125; from &#39;.&#x2F;avatar.js&#39;\n\nexport &#123;Button, Avatar&#125;\n\n或者可以通过 export 直接导出\nexport &#123;default as Button&#125; from &#39;.&#x2F;button.js&#39;\nexport &#123;Avatar&#125; from &#39;.&#x2F;avatar.js&#39;\n\nnode 中使用node 使用 ESM在 node 中使用 esModule 需要将扩展名由 .js 改为 .mjs启动的时候需要额外添加 --experimental-modules 参数可以通过 ESM 的方式导入 node 的内置模块，内置模块兼容了 ESM 的提取成员的方式\nimport &#123;foo, bar&#125; from &#39;.&#x2F;module.mjs&#39;\n\nconsole.log(foo, bar)\n\n&#x2F;&#x2F; 可以通过 esm 加载内置模块\nimport fs from &#39;fs&#39;\n\nfs.writeFileSync(&#39;.&#x2F;foo.txt&#39;, &#39;es module working&#39;)\n\n&#x2F;&#x2F; 也可以直接提取模块内的成员，内置模块兼容了 ESM 的提取成员的方式\nimport &#123;writeFileSync&#125; from &#39;fs&#39;\n\nwriteFileSync(&#39;.&#x2F;bar.txt&#39;, &#39;es module working&#39;)\n\n&#x2F;&#x2F; 对于第三方的 NPM 模块也可以通过 ESM 加载\nimport _ from &#39;lodash&#39;\n\nconsole.log(_.camelCase(&#39;ES Module&#39;))\n\n&#x2F;&#x2F; 不支持，第三方模块都是导出默认成员\n&#x2F;&#x2F; import &#123;camelCase&#125; from &#39;lodash&#39;\n\n&#x2F;&#x2F; console.log(camelCase(&#39;ES Module&#39;))\n\nesModule 中使用 commonJS&#x2F;&#x2F; es-module.mjs\nimport mod from &#39;.&#x2F;commonjs.js&#39;\n\nconsole.log(mod)\n&#x2F;&#x2F; &#123; foo: &#39;commonjs exports value&#39; &#125;\n\n&#x2F;&#x2F; 不能从 CommonJS 中直接提取成员，import 不是解构导出对象\n&#x2F;&#x2F; 错误导出方式\nimport &#123;foo&#125; from &#39;.&#x2F;commonjs.js&#39;\n\nconsole.log(foo)\n\n&#x2F;&#x2F; commonjs.js\n&#x2F;&#x2F; CommonJS 模块始终只会导出一个默认值\nmodule.exports &#x3D; &#123;\n  foo: &#39;commonjs exports value&#39;\n&#125;\n\ncommonJS 中不能使用 esModule&#x2F;&#x2F; es-module.mjs\nexport const foo &#x3D; &#39;es module export value&#39;\n\n&#x2F;&#x2F; commonjs.js\n\n&#x2F;&#x2F; 报错，不能在 CommonJS 模块中通过 require 载入 ES Module\nconst mod &#x3D; require(&#39;.&#x2F;es-module.mjs&#39;)\nconsole.log(mod)\n\nesModule 和 commonJS 的区别ESM 中没有模块全局成员，以下变量全部报错\n&#x2F;&#x2F; esm.mjs\n&#x2F;&#x2F; 加载模块函数\nconsole.log(require)\n\n&#x2F;&#x2F; 模块对象\nconsole.log(module)\n\n&#x2F;&#x2F; 导出对象别名\nconsole.log(exports)\n\n&#x2F;&#x2F; 当前文件夹的绝对路径\nconsole.log(__filename)\n\n&#x2F;&#x2F; 当前文件所在的目录\nconsole.log(__dirname)\n\nESM 中获取 __filename 和 __dirname\nimport.meta.url 中为 url 形式的文件路径，需要转为当前的绝对路径\nimport &#123;fileURLToPath&#125; from &#39;url&#39;\nimport &#123;dirname&#125; from &#39;path&#39;\n\nconst __filename &#x3D; fileURLToPath(import.meta.url)\nconst __dirname &#x3D; dirname(__filename)\nconsole.log(__filename)\nconsole.log(__dirname)\n\n定义该项目为 ES Module将 package.json 的 type 改为 module，这该项目所有的 js 文件都遵循 ES Module，不再需要 .mjs 后缀CommonJS 的使用这需要改后缀为 .cjs\n&#123;\n  &quot;type&quot;: &quot;module&quot;\n&#125;\n\n&#x2F;&#x2F; module.js\nexport const foo &#x3D; &#39;hello&#39;\nexport const bar &#x3D; &#39;world&#39;\n\n&#x2F;&#x2F; index.js\nimport &#123;foo, bar&#125; from &#39;.&#x2F;module.js&#39;\nimport * as mod from &#39;.&#x2F;common.cjs&#39;\n\nconsole.log(mod)\nconsole.log(foo, bar)\n\n&#x2F;&#x2F; common.cjs\nconst path &#x3D; require(&#39;path&#39;)\nconsole.log(path.join(__dirname, &#39;foo&#39;))\n\nmodule.exports &#x3D; &#123;\n  foo: &#39;hhh&#39;\n&#125;\n\n\n","slug":"esModule","date":"2022-01-14T16:00:00.000Z","categories_index":"JavaScript","tags_index":"JAVASCRIPT,ECMASCRIPT","author_index":"SKY"},{"id":"a0878e81d0c7b86746b25d401f215469","title":"ECMAScript 2016 新特性","content":"ECMAScript 2016 新特性Array.prototype.includes查找元素\nconst arr &#x3D; [&#39;foo&#39;, 1, NaN, false]\n&#x2F;&#x2F; 找到返回元素下标\nconsole.log(arr.indexOf(&#39;foo&#39;))\n&#x2F;&#x2F; 0\n\n&#x2F;&#x2F; 找不到返回 -1\nconsole.log(arr.indexOf(&#39;bar&#39;))\n&#x2F;&#x2F; -1\n\n&#x2F;&#x2F; 无法找到数组中的 NaN\nconsole.log(arr.indexOf(NaN))\n&#x2F;&#x2F; -1\n\nconsole.log(arr.indexOf(false))\n&#x2F;&#x2F; 3\n\n新增 includes 方法，直接返回布尔值表示否是存在\nconst arr &#x3D; [&#39;foo&#39;, 1, NaN, false]\n\nconsole.log(arr.includes(&#39;foo&#39;))\n&#x2F;&#x2F; true\n\nconsole.log(arr.includes(&#39;bar&#39;))\n&#x2F;&#x2F; false\n\n&#x2F;&#x2F; 可以查找 NaN\nconsole.log(arr.includes(NaN))\n&#x2F;&#x2F; true\n\n指数运算法console.log(Math.pow(2, 10))\n&#x2F;&#x2F; 1024\n\n&#x2F;&#x2F; 新增指数运算符\nconsole.log(2 ** 10)\n&#x2F;&#x2F; 1024\n","slug":"ecmascript2016","date":"2022-01-04T16:00:00.000Z","categories_index":"JavaScript","tags_index":"JAVASCRIPT,ECMASCRIPT","author_index":"SKY"},{"id":"d318e18e99918ad61da8e565bf7bdfdc","title":"ECMAScript 2017 新特性","content":"ECMAScript 2017 新特性Object.values输出对象的值\nconst obj &#x3D; &#123;\n  foo: &#39;value1&#39;,\n  bar: &#39;value2&#39;,\n&#125;\n\nconsole.log(Object.values(obj))\n&#x2F;&#x2F; [ &#39;value1&#39;, &#39;value2&#39; ]\n\nObject.entries以数组的方式输出对象\nconst obj &#x3D; &#123;\n  foo: &#39;value1&#39;,\n  bar: &#39;value2&#39;,\n&#125;\n\nconsole.log(Object.entries(obj))\n&#x2F;&#x2F; [ [ &#39;foo&#39;, &#39;value1&#39; ], [ &#39;bar&#39;, &#39;value2&#39; ] ]\n\n&#x2F;&#x2F; 配合数组解构，可以直接遍历对象\nfor(const [key,value] of Object.entries(obj)) &#123;\n  console.log(key, value)\n&#125;\n&#x2F;&#x2F; foo value1\n&#x2F;&#x2F; bar value2\n\nObject.getOwnPropertyDescriptors使用 assign 复制对象\nconst p1 &#x3D; &#123;\n  firstName: &#39;Lei&#39;,\n  lastName: &#39;Wang&#39;,\n\n  get fullName() &#123;\n    return this.firstName + &#39; &#39; + this.lastName\n  &#125;\n&#125;\nconsole.log(p1.fullName)\n&#x2F;&#x2F; Lei Wang\n\n&#x2F;&#x2F; 通过 assign 复制对象，不会把 get 方法复制，最后打印的 fullName 还是之前的 fullName\nconst p2 &#x3D; Object.assign(&#123;&#125;, p1)\np2.firstName &#x3D; &#39;hhh&#39;\nconsole.log(p2)\n&#x2F;&#x2F; &#123; firstName: &#39;hhh&#39;, lastName: &#39;Wang&#39;, fullName: &#39;Lei Wang&#39; &#125;\n\n使用 getOwnPropertyDescriptors + defineProperties 复制对象getOwnPropertyDescriptors: 所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象\nconst p1 &#x3D; &#123;\n  firstName: &#39;Lei&#39;,\n  lastName: &#39;Wang&#39;,\n\n  get fullName() &#123;\n    return this.firstName + &#39; &#39; + this.lastName\n  &#125;\n&#125;\nconsole.log(p1.fullName)\n&#x2F;&#x2F; Lei Wang\n\nconst descriptors &#x3D; Object.getOwnPropertyDescriptors(p1)\nconsole.log(descriptors)\n&#x2F;&#x2F; &#123;\n&#x2F;&#x2F;   firstName: &#123;\n&#x2F;&#x2F;     value: &#39;Lei&#39;,\n&#x2F;&#x2F;       writable: true,\n&#x2F;&#x2F;       enumerable: true,\n&#x2F;&#x2F;       configurable: true\n&#x2F;&#x2F;   &#125;,\n&#x2F;&#x2F;   lastName: &#123;\n&#x2F;&#x2F;     value: &#39;Wang&#39;,\n&#x2F;&#x2F;       writable: true,\n&#x2F;&#x2F;       enumerable: true,\n&#x2F;&#x2F;       configurable: true\n&#x2F;&#x2F;   &#125;,\n&#x2F;&#x2F;   fullName: &#123;\n&#x2F;&#x2F;     get: [Function: get fullName],\n&#x2F;&#x2F;     set: undefined,\n&#x2F;&#x2F;       enumerable: true,\n&#x2F;&#x2F;       configurable: true\n&#x2F;&#x2F;   &#125;\n&#x2F;&#x2F; &#125;\n\nconst p2 &#x3D; Object.defineProperties(&#123;&#125;, descriptors)\np2.firstName &#x3D; &#39;hhh&#39;\nconsole.log(p2.fullName)\n&#x2F;&#x2F; hhh Wang\n\nString.prototype.padStart / String.prototype.padEndString.prototype.padStart: 方法用另一个字符串填充当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串的左侧开始填充。\nString.prototype.padEnd: 方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。\nconst books &#x3D; &#123;\n  html: 5,\n  css: 16,\n  javascript: 128\n&#125;\n\nfor (const [name,count] of Object.entries(books)) &#123;\n  console.log(&#96;$&#123;name.padEnd(16, &#39;-&#39;)&#125;, $&#123;count.toString().padStart(3, 0)&#125;&#96;)\n&#125;\n\n在函数参数中添加尾逗号function foo(\n  bar,\n  baz,\n) &#123;\n  \n&#125;\n\nconst a &#x3D; [\n  1,\n  2,\n]\n\nconst obj &#x3D; &#123;\n  a: 1,\n  b: 2,\n&#125;\n","slug":"ecmascript2017","date":"2022-01-04T16:00:00.000Z","categories_index":"JavaScript","tags_index":"JAVASCRIPT,ECMASCRIPT","author_index":"SKY"},{"id":"511aed350b5ec3b2d451257538725c66","title":"ECMAScript 2015 新特性","content":"ECMAScript 2015 新特性let\nlet 声明的成员只会在所声明的块中生效\n\n如果使用 var 声明变量，可以正常输出，var 关键字有变量提升的过程\nif (true) &#123;\n  var foo &#x3D; &#39;foo&#39;\n  console.log(foo)\n&#125;\n\nconsole.log(foo)\n\n如果使用 let 声明变量，外层调用就会报错\nif (true) &#123;\n  let foo &#x3D; &#39;foo&#39;\n  console.log(foo)\n&#125;\n\n&#x2F;&#x2F; ReferenceError: foo is not defined\nconsole.log(foo)\n\n\nlet 在 for 循环中的表现\n\n如果使用 var 声明\nfor (var i &#x3D; 0; i &lt; 3; i++) &#123;\n  for (var i &#x3D; 0; i &lt; 3; i++) &#123;\n    console.log(i)\n  &#125;\n  console.log(&#39;内层结束 i &#x3D; &#39; + i)\n&#125;\n\n&#x2F;&#x2F; 0\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 内层结束 i &#x3D; 3\n\n如果使用 let 声明，能正常的得到想要的 9 次输出\nfor (let i &#x3D; 0; i &lt; 3; i++) &#123;\n  for (let i &#x3D; 0; i &lt; 3; i++) &#123;\n    console.log(i)\n  &#125;\n  console.log(&#39;内层结束 i &#x3D; &#39; + i)\n&#125;\n\n&#x2F;&#x2F; 0\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 内层结束 i &#x3D; 0\n&#x2F;&#x2F; 0\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 内层结束 i &#x3D; 1\n&#x2F;&#x2F; 0\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 内层结束 i &#x3D; 2\n\n\nlet 应用场景：循环绑定事件，事件处理函数中获取正确索引\n\n使用 var 作为循环声明\nvar elements &#x3D; [&#123;&#125;, &#123;&#125;, &#123;&#125;]\n\nfor (var i &#x3D; 0; i &lt; elements.length; i++) &#123;\n  elements[i].onclick &#x3D; function () &#123;\n    console.log(i)\n  &#125;\n&#125;\n\nelements[1].onclick()\n&#x2F;&#x2F; 不管调用哪一个事件，输出都是3\n\n使用闭包来解决变量提升的问题\nvar elements &#x3D; [&#123;&#125;, &#123;&#125;, &#123;&#125;]\n\nfor (var i &#x3D; 0; i &lt; elements.length; i++) &#123;\n  elements[i].onclick &#x3D; (function (i) &#123;\n    return function () &#123;\n      console.log(i)\n    &#125;\n  &#125;)(i)\n&#125;\n\nelements[1].onclick()\n\n使用 let 可以避免这种问题\nvar elements &#x3D; [&#123;&#125;, &#123;&#125;, &#123;&#125;]\n\nfor (let i &#x3D; 0; i &lt; elements.length; i++) &#123;\n  elements[i].onclick &#x3D; function () &#123;\n    console.log(i)\n  &#125;\n&#125;\n\nelements[1].onclick()\n\n\nfor 循环中有两层作用域\n\nfor (let i &#x3D; 0; i &lt; 3; i++) &#123;\n  let i &#x3D; &#39;foo&#39;\n  console.log(i)\n&#125;\n\n&#x2F;&#x2F; foo\n&#x2F;&#x2F; foo\n&#x2F;&#x2F; foo\n\n&#x2F;&#x2F; for 循环类似代码\nlet i &#x3D; 0\nif (i &lt; 3) &#123;\n  let i &#x3D; &#39;foo&#39;\n  console.log(i)\n&#125;\ni++\nif (i &lt; 3) &#123;\n  let i &#x3D; &#39;foo&#39;\n  console.log(i)\n&#125;\ni++\nif (i &lt; 3) &#123;\n  let i &#x3D; &#39;foo&#39;\n  console.log(i)\n&#125;\ni++\n\n\nlet 修复了变量声明提升现象\n\nconsole.log(foo)\nvar foo &#x3D; &#39;foo&#39;\n\nconsole.log(foo1)\nlet foo1 &#x3D; &#39;foo1&#39;\n\n&#x2F;&#x2F; var 输出\n&#x2F;&#x2F; undefined\n\n&#x2F;&#x2F; let 输出\n&#x2F;&#x2F; ReferenceError: Cannot access &#39;foo1&#39; before initialization\n\nconstconst 声明的变量不允许重新赋值\nconst name &#x3D; &#39;name&#39;\n\nname &#x3D; &#39;name1&#39;\n\n&#x2F;&#x2F; TypeError: Assignment to constant variable.\n\nconst 声明的变量要求声明并且同时赋值\nconst name\nname &#x3D; &#39;name&#39;\n\n&#x2F;&#x2F; SyntaxError: Missing initializer in const declaration\n\nconst 声明只是要求指向不允许被改变，但是可以修改数据内成员\nconst obj &#x3D; &#123;&#125;\nobj.name &#x3D; &#39;name&#39;\nconsole.log(obj)\nobj &#x3D; &#123;&#125;\n\n&#x2F;&#x2F; &#123; name: &#39;name&#39; &#125;\n&#x2F;&#x2F; TypeError: Assignment to constant variable.\n\nlet 和 const 注意\nlet 和 const 声明的变量，在全局作用域下不会被挂在到全局对象中，浏览器为 window，node 为 global\n\n\n\nReferenceError 引用错误与暂存死区\n\nlet 和 const 一致\nconsole.log(b) &#x2F;&#x2F; Uncaught ReferenceError: b is not defined\n\n&#x2F;&#x2F; 以上的区域为暂存死区\nlet b &#x3D; 1\n\nArray 解构\n获取每一样，单独定义变量\n\nconst arr &#x3D; [100, 200, 300]\n\nconst foo &#x3D; arr[0]\nconst bar &#x3D; arr[1]\nconst baz &#x3D; arr[2]\nconsole.log(foo, bar, baz)\n&#x2F;&#x2F; 100 200 300\n\n\n可以使用解构的方式获取每一项的值\n\nconst arr &#x3D; [100, 200, 300]\n\n&#x2F;&#x2F; 解构\nconst [foo, bar, baz] &#x3D; arr\nconsole.log(foo, bar, baz)\n\n&#x2F;&#x2F; 100 200 300\n\n\n可以只获取某一个位置的值\n\nconst arr &#x3D; [100, 200, 300]\n\nconst [, , baz] &#x3D; arr\nconsole.log(baz)\n\n&#x2F;&#x2F; 300\n\n\n剩余参数\n\nconst arr &#x3D; [100, 200, 300]\n\nconst [foo, ...rest] &#x3D; arr\nconsole.log(rest)\n\n&#x2F;&#x2F; [ 200, 300 ]\n\n\n如果超过了数组返回这是 undefined\n\nconst arr &#x3D; [100, 200, 300]\n\nconst [foo, bar, baz, more] &#x3D; arr\nconsole.log(more)\n&#x2F;&#x2F; undefined\n\n\n添加默认值\n\nconst arr &#x3D; [100, 200, 300]\n\nconst [foo, bar, baz &#x3D; 123, more &#x3D; &#39;default value&#39;] &#x3D; arr\nconsole.log(baz, more)\n&#x2F;&#x2F; 300 default value\n\n\n应用\n\nconst path &#x3D; &#39;&#x2F;foo&#x2F;bar&#x2F;baz&#39;\nconst [, rootdir] &#x3D; path.split(&#39;&#x2F;&#39;)\nconsole.log(rootdir)\n\n&#x2F;&#x2F; foo\n\nobjectobject 解构\n对象解构\n\nconst obj &#x3D; &#123;name: &#39;sky&#39;, age: 18&#125;\nconst &#123;name&#125; &#x3D; obj\nconsole.log(name)\n&#x2F;&#x2F; sky\n\n\n对象解构重命名\n\nconst obj &#x3D; &#123;name: &#39;sky&#39;, age: 18&#125;\nconst &#123;name: objName&#125; &#x3D; obj\nconsole.log(objName)\n&#x2F;&#x2F; sky\n\n\n默认值\n\nconst obj &#x3D; &#123;name: &#39;sky&#39;, age: 18&#125;\nconst &#123;name: objName &#x3D; &#39;jack&#39;, name1: objName1 &#x3D; &#39;jack1&#39;&#125; &#x3D; obj\nconsole.log(objName, objName1)\n&#x2F;&#x2F; sky jack1\n\n\n应用\n\nconst &#123;log&#125; &#x3D; console\nlog(&#39;foo&#39;)\nlog(&#39;bar&#39;)\nlog(&#39;123&#39;)\n&#x2F;&#x2F; foo\n&#x2F;&#x2F; bar\n&#x2F;&#x2F; 123\n\n对象字面量const bar &#x3D; &#39;345&#39;\n\nconst obj &#x3D; &#123;\n  foo: 123,\n\n  &#x2F;&#x2F; bar: bar\n  &#x2F;&#x2F; 属性名与变量名相同，可以省略 : bar\n  bar,\n\n  &#x2F;&#x2F; 方法可以省略 : funtion\n  method1: function () &#123;\n    consle.log(&#39;method1&#39;)\n    &#x2F;&#x2F; 这种方法就是普通的函数，同样影响 this 指向，指向当前对象\n    console.log(this, &#39;method1&#39;)\n  &#125;,\n\n  method2() &#123;\n    console.log(&#39;method2&#39;)\n    &#x2F;&#x2F; 这种方法就是普通的函数，同样影响 this 指向，指向当前对象\n    conosle.log(this, &#39;method2&#39;)\n  &#125;,\n\n  &#x2F;&#x2F; 123: 12 不允许\n  &#x2F;&#x2F; 允许键是一个变量，但是只能是字符串\n  [bar]: 123,\n&#125;\n\nobj.method1()\nobj.method2()\nconsole.log(obj)\n\nObject.assign 方法Object.assign(target, …args)将 target 后面多个对象合并到 target 中，相同的属性将会被覆盖\nconst source1 &#x3D; &#123;\n  a: 123,\n  b: 123,\n&#125;\n\nconst source2 &#x3D; &#123;\n  b: 789,\n  c: 789\n&#125;\n\nconst target &#x3D; &#123;\n  a: 456,\n  c: 456\n&#125;\n\nconst result &#x3D; Object.assign(target, source1, source2)\nconsole.log(result)\nconsole.log(result &#x3D;&#x3D;&#x3D; target)\n&#x2F;&#x2F; &#123; a: 123, c: 789, b: 789 &#125;\n&#x2F;&#x2F; true\n\n应用：\nfunction fun(obj) &#123;\n  &#x2F;&#x2F; 这种方法会更改外面传入的对象\n  &#x2F;&#x2F; obj.name &#x3D; &#39;func obj&#39;\n  &#x2F;&#x2F; console.log(obj)\n\n  &#x2F;&#x2F; 达到复制对象的目的\n  const funcObj &#x3D; Object.assign(&#123;&#125;, obj)\n  funcObj.name &#x3D; &#39;func obj&#39;\n  console.log(funcObj)\n&#125;\n\nconst obj &#x3D; &#123;name: &#39;global obj&#39;&#125;\nfunc(obj)\nconsole.log(obj)\n&#x2F;&#x2F; &#123; name: &#39;func obj&#39; &#125;\n&#x2F;&#x2F; &#123; name: &#39;global obj&#39; &#125;\n\nObject.isObject.is 可以判断 +0 和 -0 NaN\nconsole.log(0 &#x3D;&#x3D; false)\nconsole.log(0 &#x3D;&#x3D;&#x3D; false)\nconsole.log(+0 &#x3D;&#x3D;&#x3D; -0)\nconsole.log(NaN &#x3D;&#x3D;&#x3D; NaN)\nconsole.log(Object.is(+0, -0))\nconsole.log(Object.is(NaN, NaN))\n\n&#x2F;&#x2F; true\n&#x2F;&#x2F; false\n&#x2F;&#x2F; true\n&#x2F;&#x2F; false\n&#x2F;&#x2F; false\n&#x2F;&#x2F; true\n\nstring模版字符串const str &#x3D; &#96;hello es2015&#96;\nconsole.log(str)\n&#x2F;&#x2F; hello es2015\n\n&#x2F;&#x2F; 允许换行\nconst str1 &#x3D; &#96;\nhello es2015,\nhello\nthis is a \\&#96;string\\&#96;\n&#96;\nconsole.log(str1)\n&#x2F;&#x2F; hello es2015,\n&#x2F;&#x2F; hello\n&#x2F;&#x2F; this is a &#96;string&#96;\n\nconst name &#x3D; &#39;tom&#39;\n&#x2F;&#x2F; 可以通过 $&#123;&#125; 插入表达式，表达式执行的结果将会输出到对应的位置\nconst msg &#x3D; &#96;hey, $&#123;name&#125; --- $&#123;1 + 3&#125; --- $&#123;Math.random()&#125;&#96;\nconsole.log(msg)\n&#x2F;&#x2F; hey, tom --- 4 --- 0.7121610722271636\n\n带标签的模版字符串模版字符串的标签就是一个特殊的函数，使用这个标签就是调用这个函数\n&#x2F;&#x2F; const str &#x3D; console.log&#96;hello world&#96;\n\nconst name &#x3D; &#39;tom&#39;\nconst gender &#x3D; false\n\nfunction myTagFunc(strings, name, gender) &#123;\n  &#x2F;&#x2F; strings 是以 $&#123;&#125; 为间隔分割字符串的值，可以自定义处理字符串的返回\n  console.log(strings, name, gender)\n  const sex &#x3D; gender ? &#39;man&#39; : &#39;woman&#39;\n  return strings[0] + name + strings[1] + sex + strings[2]\n&#125;\n\nconst result &#x3D; myTagFunc&#96;hey, $&#123;name&#125; is a $&#123;gender&#125;&#96;\nconsole.log(result)\n&#x2F;&#x2F; [ &#39;hey, &#39;, &#39; is a &#39;, &#39;&#39; ] tom false\n&#x2F;&#x2F; hey, tom is a woman\n\n扩展方法\nincludes\n\nconst message &#x3D; &#39;Error: foo is not defined.&#39;\nconsole.log(message.startsWith(&#39;Error&#39;))\nconsole.log(message.endsWith(&#39;.&#39;))\nconsole.log(message.includes(&#39;foo&#39;))\n&#x2F;&#x2F; true\n&#x2F;&#x2F; true\n&#x2F;&#x2F; true\n\nFunction默认值function foo(enable) &#123;\n  enable &#x3D; enable &#x3D;&#x3D;&#x3D; undefined ? true : false\n  console.log(&#39;foo invoked - enable: &#39;, enable)\n&#125;\n\nfoo()\nfoo(true)\n&#x2F;&#x2F; foo invoked - enable:  true\n&#x2F;&#x2F; foo invoked - enable:  false\n\n&#x2F;&#x2F; 默认值参数一定要在形参列表的最后\nfunction foo1(enable &#x3D; true) &#123;\n  console.log(&#39;foo invoked - enable: &#39;, enable)\n&#125;\n\nfoo1()\nfoo1(false)\n&#x2F;&#x2F; foo invoked - enable:  true\n&#x2F;&#x2F; foo invoked - enable:  false\n\n剩余参数function foo() &#123;\n  console.log(arguments)\n&#125;\n\nfunction foo1(first, ...args) &#123;\n  console.log(first, args)\n&#125;\n\nfoo(1, 2, 3)\nfoo1(1, 2, 3, 4)\n&#x2F;&#x2F; [arguments] &#123; &#39;0&#39;: 1, &#39;1&#39;: 2, &#39;2&#39;: 3 &#125;\n&#x2F;&#x2F; 1 [ 2, 3, 4 ]\n\n展开数组参数const arr &#x3D; [1, 2, 3]\nconsole.log(arr[0], arr[1], arr[2])\nconsole.log.apply(console, arr)\nconsole.log(...arr)\n&#x2F;&#x2F; 1 2 3\n&#x2F;&#x2F; 1 2 3\n&#x2F;&#x2F; 1 2 3\n\n箭头函数function inc(num) &#123;\n  return num + 1\n&#125;\n\nconst inc1 &#x3D; n &#x3D;&gt; n + 1\n\nconsole.log(inc(1))\nconsole.log(inc1(2))\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 3\n\n&#x2F;&#x2F; 完成参数列表，函数体多条语句，返回值仍需 return\n\nconst add &#x3D; (n1, n2) &#x3D;&gt; &#123;\n  console.log(n1, n2)\n  return n1 + n2\n&#125;\n\nconsole.log(add(1, 3))\n&#x2F;&#x2F; 1 3\n&#x2F;&#x2F; 4\n\n&#x2F;&#x2F; 应用\n\nconst arr &#x3D; [1, 2, 3, 4, 5]\nconsole.log(arr.filter(i &#x3D;&gt; i % 2))\n&#x2F;&#x2F; [ 1, 3, 5 ]\n\n箭头函数与 thisconst person &#x3D; &#123;\n  name: &#39;tom&#39;,\n\n  sayHi: function () &#123;\n    console.log(&#39;hi, my name is &#39;, this.name)\n  &#125;,\n\n  sayHi1: () &#x3D;&gt; &#123;\n    console.log(&#39;hi, my name is &#39;, this.name)\n  &#125;,\n\n  sayHiAsync: function () &#123;\n    const _this &#x3D; this\n    setTimeout(function () &#123;\n      console.log(this.name, &#39;setTimeout&#39;)\n      console.log(_this.name, &#39;setTimeout1&#39;)\n    &#125;, 1000)\n\n    console.log(this.name, &#39;sayHiAsync&#39;)\n\n    setTimeout(() &#x3D;&gt; &#123;\n      console.log(this.name, &#39;setTimeout2&#39;)\n    &#125;, 1000)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; sayHi 是由 person 调用，而且不是箭头函数，所以 this 指向了调用者\nperson.sayHi()\n&#x2F;&#x2F; hi, my name is  tom\n\n&#x2F;&#x2F; sayHi1 是由 person 调用，但是是箭头函数，this 指向了父级作用域，则是 window，window 中没有 name 属性，所以打印 undefined\nperson.sayHi1()\n&#x2F;&#x2F; hi, my name is  undefined\n\n&#x2F;&#x2F; 第一个 setTimeout 中的 this，由于不是箭头函数，这个回调函数是在 setTimeout 中执行，则 this 指向了 Timeout 对象，这里可以理解为 setTimeout 中是由 Timeout 对象调用了 callback 函数\n&#x2F;&#x2F; 第二个 this，指向了 sayHiAsync 调用者，即 person\n&#x2F;&#x2F; 第三个 setTimeout 中的 this，由于是箭头函数，则 this 指向上一层作用域，则也是 person 对象\nperson.sayHiAsync()\n&#x2F;&#x2F; tom sayHiAsync\n&#x2F;&#x2F; undefined setTimeout\n&#x2F;&#x2F; tom setTimeout1\n&#x2F;&#x2F; tom setTimeout2\n\nProxy 对象const p = new Proxy(target, handler)\ntarget: 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理） handler:一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。\n\n\n\nhandler ⽅法\n触发方法\n\n\n\nget\n读取某个属性\n\n\nset\n写入某个属性\n\n\nhas\nin 操作符\n\n\ndeleteProperty\ndelete 操作符\n\n\ngetProperty\nObject.getPrototypeOf()\n\n\nsetProperty\nObject.setPrototypeOf()\n\n\nisExtensible\nObject.isExtensible()\n\n\npreventExtensions\nObject.preventExtensions()\n\n\ngetOwnPropertyDescriptor\nObject.getOwnPropertyDescriptor()\n\n\ndefineProperty\nObject.defineProperty()\n\n\nownKeys\nObject.keys(), Object.getOwnPropertyNames(), Object.getOwnPropertySymbols()\n\n\napply\n调用一个函数\n\n\nconstruct\n用 new 调用一个函数\n\n\nconst person &#x3D; &#123;\n  name: &#39;name&#39;,\n  age: 20\n&#125;\n\nconst personProxy &#x3D; new Proxy(person, &#123;\n  &#x2F;&#x2F; 监视属性读取\n  get(target, property) &#123;\n    console.log(target, property)\n    return property in target ? target[property] : &#39;default&#39;\n  &#125;,\n\n  &#x2F;&#x2F; 监听属性设置 \n  set(target, property, value) &#123;\n    if (property &#x3D;&#x3D;&#x3D; &#39;age&#39;) &#123;\n      if (!Number.isInteger(value)) &#123;\n        throw new TypeError(&#96;$&#123;value&#125; is not an int number&#96;)\n      &#125;\n    &#125;\n\n    target[property] &#x3D; value\n  &#125;,\n&#125;)\n\nconsole.log(personProxy.name)\npersonProxy.age &#x3D; 30\nconsole.log(personProxy)\nconsole.log(person)\n&#x2F;&#x2F; &#123; name: &#39;name&#39;, age: 20 &#125; name\n&#x2F;&#x2F; name\n&#x2F;&#x2F; &#123; name: &#39;name&#39;, age: 30 &#125;\n&#x2F;&#x2F; &#123; name: &#39;name&#39;, age: 30 &#125;\n\n对比 Proxy 与 Object.defineProperty()\n\n优势1：Proxy 可以监听读写以外的操作\n\nconst person &#x3D; &#123;\n  name: &#39;name&#39;,\n  age: 10\n&#125;\n\nconst personProxy &#x3D; new Proxy(person, &#123;\n  deleteProperty(target, property) &#123;\n    console.log(&#39;delete&#39;, property)\n    delete target[property]\n  &#125;\n&#125;)\n\ndelete personProxy.age\nconsole.log(person)\n&#x2F;&#x2F; delete age\n&#x2F;&#x2F; &#123; name: &#39;name&#39; &#125;\n\n\n优势2： Proxy 可以很方便的监听数组操作\n\nconst list &#x3D; []\n\nconst listProxy &#x3D; new Proxy(list, &#123;\n  &#x2F;&#x2F; 数组也可以理解为一个对象，下标就是对应键，还有一个 length 属性的键\n  &#x2F;&#x2F; &#123;\n  &#x2F;&#x2F;   0: 1\n  &#x2F;&#x2F;   1: 2\n  &#x2F;&#x2F;   length: 2\n  &#x2F;&#x2F; &#125;\n  set(target, property, value) &#123;\n    console.log(&#39;set&#39;, property, value)\n    target[property] &#x3D; value\n    &#x2F;&#x2F; 表示设置成功，否则会报错\n    return true\n  &#125;\n&#125;)\n\nlistProxy.push(1)\nlistProxy.push(2)\n&#x2F;&#x2F; set 0 1\n&#x2F;&#x2F; set length 1\n&#x2F;&#x2F; set 1 2\n&#x2F;&#x2F; set length 2\n\n\n优势3： Proxy 不需要侵入对象\n\nObject.defineProperty 用法\nconst person &#x3D; &#123;&#125;\n\nObject.defineProperty(person, &#39;name&#39;, &#123;\n  get() &#123;\n    console.log(&#39;get name&#39;)\n    return person._name\n  &#125;,\n  set(value) &#123;\n    console.log(&#39;set name&#39;)\n    person._name &#x3D; value\n  &#125;\n&#125;)\n\nObject.defineProperty(person, &#39;age&#39;, &#123;\n  get() &#123;\n    console.log(&#39;get age&#39;)\n    return person._age\n  &#125;,\n  set(value) &#123;\n    console.log(&#39;set age&#39;)\n    person._age &#x3D; value\n  &#125;\n&#125;)\n\nperson.name &#x3D; &#39;name&#39;\nperson.age &#x3D; 20\nconsole.log(person)\n&#x2F;&#x2F; set name\n&#x2F;&#x2F; set age\n&#x2F;&#x2F; &#123; _name: &#39;name&#39;, _age: 20 &#125;\n\nProxy 用法\nconst person &#x3D; &#123;&#125;\nconst personProxy &#x3D; new Proxy(person, &#123;\n  get(target, property) &#123;\n    console.log(&#39;get&#39;, property)\n    return target[property]\n  &#125;,\n  set(target, property, value) &#123;\n    console.log(&#39;set&#39;, property, value)\n    target[property] &#x3D; value\n  &#125;\n&#125;)\n\npersonProxy.name &#x3D; &#39;name&#39;\npersonProxy.age &#x3D; 18\nconsole.log(person)\n&#x2F;&#x2F; set name name\n&#x2F;&#x2F; set age 18\n&#x2F;&#x2F; &#123; name: &#39;name&#39;, age: 18 &#125;\n\nReflect 对象Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handlers 的方法相同。Reflect不是一个函数对象，因此它是不可构造的。 Reflect 对象提供了以下静态方法，这些方法与proxy handler methods的命名相同.\n\n\n\nProxy handler ⽅法\n默认调用\n\n\n\nget\nReflect.get()\n\n\nset\nReflect.set()\n\n\nhas\nReflect.has()\n\n\ndeleteProperty\nReflect.delete()\n\n\ngetProperty\nReflect.getPrototypeOf()\n\n\nsetProperty\nReflect.setPrototypeOf()\n\n\nisExtensible\nReflect.isExtensible()\n\n\npreventExtensions\nReflect.preventExtensions()\n\n\ngetOwnPropertyDescriptor\nReflect.getOwnPropertyDescriptor()\n\n\ndefineProperty\nReflect.defineProperty()\n\n\nownKeys\nReflect.ownKeys()\n\n\napply\nReflect.apply()\n\n\nconstruct\nReflect.construct()\n\n\n\n结合 Proxy 使用\n\nconst obj &#x3D; &#123;\n  foo: &#39;123&#39;,\n  bar: &#39;456&#39;,\n&#125;\n\nconst proxy &#x3D; new Proxy(obj, &#123;\n  get(target, property) &#123;\n    console.log(&#39;watch logic ~&#39;)\n    &#x2F;&#x2F; Proxy 默认实现\n    return Reflect.get(target, property)\n  &#125;\n&#125;)\n\nconsole.log(proxy)\nconsole.log(proxy.foo)\n&#x2F;&#x2F; &#123; foo: &#39;123&#39;, bar: &#39;456&#39; &#125;\n&#x2F;&#x2F; watch logic ~\n&#x2F;&#x2F; 123\n\n\n独立使用\n\nconst obj &#x3D; &#123;\n  name: &#39;name&#39;,\n  age: 18\n&#125;\n\nconsole.log(Reflect.has(obj, &#39;name&#39;))\nconsole.log(Reflect.deleteProperty(obj, &#39;age&#39;))\nconsole.log(Reflect.ownKeys(obj))\n&#x2F;&#x2F; true\n&#x2F;&#x2F; true\n&#x2F;&#x2F; [ &#39;name&#39; ]\n\nclass新增 class 关键字来定义类class Person &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name\n  &#125;\n\n  say() &#123;\n    console.log(&#39;hi, my name is&#39;, this.name)\n  &#125;\n&#125;\n\nconst p &#x3D; new Person(&#39;tom&#39;)\np.say()\n\n&#x2F;&#x2F; hi, my name is tom\n\nstatic 静态方法class Person &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name\n  &#125;\n\n  say() &#123;\n    console.log(&#39;hi, my name is&#39;, this.name)\n  &#125;\n\n  static create(name) &#123;\n    return new Person(name)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 可以使用类名直接调用\nconst p &#x3D; Person.create(&#39;tom&#39;)\np.say()\n&#x2F;&#x2F; hi, my name is tom\n\nextends 类继承class Person &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name\n  &#125;\n\n  say() &#123;\n    console.log(&#39;hi, my name is&#39;, this.name)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 通过 extends 继承 Person 的属性和方法\nclass Student extends Person &#123;\n  constructor(name, number) &#123;\n    &#x2F;&#x2F; 通过 super 调用父类的构造方法\n    super(name)\n    this.number &#x3D; number\n  &#125;\n\n  hello() &#123;\n    &#x2F;&#x2F; 通过 super 调用父类的 方法\n    super.say()\n    console.log(&#39;my school number is&#39;, this.number)\n  &#125;\n&#125;\n\nconst s &#x3D; new Student(&#39;jack&#39;, 100)\ns.hello()\n&#x2F;&#x2F; hi, my name is jack\n&#x2F;&#x2F; my school number is 100\n\nSet\n基本用法\n\nSet 数据结构，保存唯一的数据，对象类型无法去重相同的值，对象类型是根据地址判断是否重复\nconst s &#x3D; new Set()\n\ns.add(1).add(2).add(3).add(4).add(2)\nconsole.log(s)\n&#x2F;&#x2F; Set(3) &#123; 1, 2, 3 &#125;\n\n&#x2F;&#x2F; 遍历\ns.forEach(i &#x3D;&gt; console.log(i))\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 3\n&#x2F;&#x2F; 4\nfor (let i of s) &#123;\n  console.log(i)\n&#125;\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 3\n&#x2F;&#x2F; 4\n\nconsole.log(s.size)\n&#x2F;&#x2F; 输出 set 中的长度 4\n\nconsole.log(s.has(100))\nconsole.log(s.has(2))\n&#x2F;&#x2F; 判断是否有值\n&#x2F;&#x2F; false\n&#x2F;&#x2F; true\n\nconsole.log(s.delete(2))\n&#x2F;&#x2F; 删除一个值，成功返回 true\nconsole.log(s)\n&#x2F;&#x2F; Set(3) &#123; 1, 3, 4 &#125;\n\n&#x2F;&#x2F; 清空 set\ns.clear()\nconsole.log(s)\n&#x2F;&#x2F;  Set(0) &#123;&#125;\n\n\n\n使用场景\n\n数组去重\nconst arr &#x3D; [1, 2, 1, 3, 4, 1]\nconsole.log(Array.from(new Set(arr)))\nconsole.log([...new Set(arr)])\n\n\nWeakSet 和 Set\n\nWeakSet\n\n弱引用版本 WeakSet\n差异就是 Set 中会对使用到的数据产生引用\n即便这是数据在外面被消耗，但是由于 Set 引用了这个数据，所以依然不会回收\n而 WeakSet 的特点就是不产生引用\n一旦数据摧毁，就可以被回收，所以不会产生内存泄漏的问题。\n\nMap\nMap 和 Object 区别\n\nconst obj &#x3D; &#123;&#125;\nobj[true] &#x3D; &#39;value&#39;\nobj[123] &#x3D; &#39;value&#39;\nobj[&#123;a: 1&#125;] &#x3D; &#39;value1&#39;\nobj[&#123;a: 2&#125;] &#x3D; &#39;value2&#39;\nconsole.log(obj)\nconsole.log(Object.keys(obj))\n\n&#x2F;&#x2F; 对象类型会把所有的 key 变为 字符串\n&#x2F;&#x2F; &#123; &#39;123&#39;: &#39;value&#39;, true: &#39;value&#39;, &#39;[object Object]&#39;: &#39;value2&#39; &#125;\n&#x2F;&#x2F; [ &#39;123&#39;, &#39;true&#39;, &#39;[object Object]&#39; ]\n\nMap 可以设置任意类型的 key，不会被转为 字符串\n\nconst m &#x3D; new Map()\n\nconst tom &#x3D; &#123;name: &#39;tom&#39;&#125;\nm.set(tom, 90)\nm.set(tom, 91)\nm.set(&#123;name: &#39;tom&#39;&#125;, 92)\nconsole.log(m)\n&#x2F;&#x2F; Map(2) &#123; &#123; name: &#39;tom&#39; &#125; &#x3D;&gt; 91, &#123; name: &#39;tom&#39; &#125; &#x3D;&gt; 92 &#125;\n\nconsole.log(m.get(tom))\n&#x2F;&#x2F; 91\n\nconsole.log(m.get(&#123;name: &#39;tom&#39;&#125;))\n&#x2F;&#x2F; undefined\n\nconsole.log(m.has(tom))\n&#x2F;&#x2F; true\n\nconsole.log(m.delete(tom))\n&#x2F;&#x2F; true\n\nconsole.log(m.clear())\n&#x2F;&#x2F; undefined\n\nconsole.log(m)\n&#x2F;&#x2F; Map(0) &#123;&#125;\n\nm.set(1, 1)\nm.set(true, true)\nm.set(&#39;key&#39;, &#39;value&#39;)\n&#x2F;&#x2F; Map(3) &#123; 1 &#x3D;&gt; 1, true &#x3D;&gt; true, &#39;key&#39; &#x3D;&gt; &#39;value&#39; &#125;\n\n&#x2F;&#x2F; Map 遍历\nm.forEach((value, key) &#x3D;&gt;&#123;\n  console.log(value, key)\n&#125;)\n&#x2F;&#x2F; 1 1\n&#x2F;&#x2F; true true\n&#x2F;&#x2F; value key\n\n\n\nWeakMap 和 Map\n\nWeakMap\n\n弱引用版本 WeakMap\n差异就是 Map 中会对所使用到的数据产生引用\n即便这个数据在外面被消耗，但是由于 Map 引用了这个数据，所以依然不会回收\n而 WeakMap 的特点就是不会产生引用，\n一旦数据销毁，就可以被回收，所以不会产生内存泄漏问题。\n\nSymbolSymbol 是一个基本类型，创建出来的对象永远不会相等\nconst s &#x3D; Symbol()\n\nconsole.log(s)\nconsole.log(typeof s)\n\n&#x2F;&#x2F; Symbol()\n&#x2F;&#x2F; symbol\n\nconsole.log(Symbol() &#x3D;&#x3D;&#x3D; Symbol())\n&#x2F;&#x2F; false\n\n&#x2F;&#x2F; 添加文字描述\nconsole.log(Symbol(&#39;foo&#39;))\nconsole.log(Symbol(&#39;bar&#39;))\nconsole.log(Symbol(&#39;baz&#39;))\n\n&#x2F;&#x2F; Symbol(foo)\n&#x2F;&#x2F; Symbol(bar)\n&#x2F;&#x2F; Symbol(baz)\n\n&#x2F;&#x2F; 使用 Symbol 为对象添加不重复的键\n\nconst obj &#x3D; &#123;&#125;\nobj[Symbol()] &#x3D; &#39;123&#39;\nobj[Symbol()] &#x3D; &#39;456&#39;\nconsole.log(obj)\n&#x2F;&#x2F; &#123; [Symbol()]: &#39;123&#39;, [Symbol()]: &#39;456&#39; &#125;\n\n&#x2F;&#x2F; 使用计算属性名添加\n\nconst obj &#x3D; &#123;\n  [Symbol()]: 123\n&#125;\n\nconsole.log(obj)\n&#x2F;&#x2F; &#123; [Symbol()]: 123 &#125;\n\n\n案例 Symbol 模拟实现私有成员\n\n&#x2F;&#x2F; a.js &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nconst name &#x3D; Symbol()\nconst person  &#x3D; &#123;\n  [name]: &#39;name&#39;,\n  say () &#123;\n    console.log(this[name])\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 只对外暴露 person\n&#x2F;&#x2F; b.js &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&#x2F;**\n * 由于无法创建出一样的 Symbol 值\n * 所以无法直接访问到 person 中的 [私有] 成员\n * person[Symbol()]\n *&#x2F;\nperson.say()\n\n\nSymbol 补充\n\nconsole.log(Symbol() &#x3D;&#x3D;&#x3D; Symbol())\nconsole.log(Symbol(&#39;foo&#39;) &#x3D;&#x3D;&#x3D; Symbol(&#39;foo&#39;))\n&#x2F;&#x2F; false\n&#x2F;&#x2F; false\n\n\nSymbol 全局注册表\n\n可以根据 Symbol.for 注册一个 Symbol 对象，这样通过 Symbol.for 得到的对象就是同一个对象\nconst s1 &#x3D; Symbol.for(&#39;foo&#39;)\nconst s2 &#x3D; Symbol.for(&#39;foo&#39;)\nconsole.log(s1 &#x3D;&#x3D;&#x3D; s2)\nconsole.log(Symbol.for(true) &#x3D;&#x3D;&#x3D; Symbol.for(true))\n&#x2F;&#x2F; true\n&#x2F;&#x2F; true\n\n\nSymbol 内置常量\n\nconsole.log(Symbol.iterator)\n&#x2F;&#x2F; Symbol(Symbol.iterator)\n\nconsole.log(Symbol.hasInstance)\n&#x2F;&#x2F; Symbol(Symbol.hasInstance)\n\nconst obj &#x3D; &#123;\n  [Symbol.toStringTag]: &#39;xObject&#39;\n&#125;\nconsole.log(obj.toString())\n&#x2F;&#x2F; [object xObject]\n\n\nSymbol 属性名获取\n\n使用 for JSON.stringify 或者 Object.keys 都无法获取到 Symbol 的 key 和 value，Symbol 的 key 只能通过 Object.getOwnPropertySymbols() 获取\nconst obj &#x3D; &#123;\n  [Symbol()]: &#39;symbol value&#39;,\n  foo: &#39;normal value&#39;\n&#125;\n\nfor( const key in obj) &#123;\n  console.log(key)\n&#125;\n&#x2F;&#x2F; foo\n\nconsole.log(Object.keys(obj))\n&#x2F;&#x2F; [ &#39;foo&#39; ]\n\nconsole.log(JSON.stringify(obj))\n&#x2F;&#x2F; &#123;&quot;foo&quot;:&quot;normal value&quot;&#125;\n\nconsole.log(Object.getOwnPropertySymbols(obj))\n&#x2F;&#x2F; [ Symbol() ]\n\n\nfor of 循环const arr &#x3D; [100, 200, 300, 400]\nfor (const item of arr) &#123;\n  console.log(item)\n&#125;\n&#x2F;&#x2F; 100\n&#x2F;&#x2F; 200\n&#x2F;&#x2F; 300\n&#x2F;&#x2F; 400\n\n&#x2F;&#x2F; for ... of  循环可以替代数组对象的 forEach 方法\narr.forEach(item &#x3D;&gt; &#123;\n  console.log(item)\n&#125;)\n&#x2F;&#x2F; 100\n&#x2F;&#x2F; 200\n&#x2F;&#x2F; 300\n&#x2F;&#x2F; 400\n\n&#x2F;&#x2F; forEach 无法跳出循环，必须使用 some 或者 every 方法\n&#x2F;&#x2F; for ... of 可以使用 break\n\nfor(const item of arr) &#123;\n  console.log(item)\n  if (item &gt; 100) &#123;\n    break\n  &#125;\n&#125;\n&#x2F;&#x2F; 100\n&#x2F;&#x2F; 200\n\n&#x2F;&#x2F; forEach 不能跳出循环\narr.forEach()\narr.some()\narr.every()\n\n&#x2F;&#x2F; 遍历 set 和遍历数组相同\nconst s &#x3D; new Set([&#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;])\nfor (const item of s) &#123;\n  console.log(item)\n&#125;\n&#x2F;&#x2F; foo\n&#x2F;&#x2F; bar\n\n&#x2F;&#x2F; 遍历 Map 可以配合数组解构语法，直接获取键值对\nconst m &#x3D; new Map()\nm.set(&#39;foo&#39;, &#39;123&#39;)\nm.set(&#39;bar&#39;, &#39;345&#39;)\nfor(const [key, value] of m) &#123;\n  console.log(key, value)\n&#125;\n&#x2F;&#x2F; foo 123\n&#x2F;&#x2F; bar 345\n\n&#x2F;&#x2F; 普通对象不能直接被 for ... of 遍历\nconst obj &#x3D; &#123;foo: 123, bar: 456&#125;\nfor (const item of obj) &#123;\n  console.log(item)\n&#125;\n&#x2F;&#x2F; for(const item of obj) &#123;\n&#x2F;&#x2F; ^\n&#x2F;&#x2F;\n&#x2F;&#x2F; TypeError: obj is not iterable\n\n\nIterator 迭代器const set &#x3D; new Set([&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;])\n\n&#x2F;&#x2F; 获取 Set 中的迭代器\nconst iterator &#x3D; set[Symbol.iterator]()\nwhile(true) &#123;\n  &#x2F;&#x2F; 获取当前元素\n  const current &#x3D; iterator.next()\n  &#x2F;&#x2F; 判断是否遍历完成\n  if (current.done) &#123;\n    break\n  &#125;\n  &#x2F;&#x2F; 打印结果\n  console.log(current.value)\n&#125;\n&#x2F;&#x2F; foo\n&#x2F;&#x2F; bar\n&#x2F;&#x2F; baz\n\nIterable 实现可迭代接口实现 Iterable 接口，需要在对象中新增 Symbol.iterator 属性\nconst obj &#x3D; &#123;\n  &#x2F;&#x2F; 新增 Symbol.iterator key，返回 next 对象\n  [Symbol.iterator]: function () &#123;\n    return &#123;\n      next: function () &#123;\n        return &#123;\n          &#x2F;&#x2F; next 返回值 包含 value 和 done\n          value: &#39;name&#39;,\n          done: true\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\nconsole.log(obj)\n\n\n案例\n\nconst obj &#x3D; &#123;\n  store: [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;],\n  &#x2F;&#x2F; 实现 Iterable 接口\n  [Symbol.iterator]: function () &#123;\n    let index &#x3D; 0\n    &#x2F;&#x2F; 这里的 this 指向 当前对象\n    const self &#x3D; this\n    return &#123;\n      &#x2F;&#x2F; 返回 next()\n      next: function () &#123;\n        &#x2F;&#x2F; 这里的 this 指向 Symbol.iterator 中 return 的对象\n        const result &#x3D; &#123;\n          &#x2F;&#x2F; next() 返回 value 和 done\n          value: self.store[index],\n          done: index &gt;&#x3D; self.store.length\n        &#125;\n        index++\n        return result\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\nfor (const item of obj) &#123;\n  console.log(item)\n&#125;\n&#x2F;&#x2F; foo\n&#x2F;&#x2F; bar\n&#x2F;&#x2F; baz\n\nIterator-pattern 迭代器模式&#x2F;&#x2F; 场景：遍历多个任务清单\nconst todo &#x3D; &#123;\n  life: [&#39;eating&#39;, &#39;sleeping&#39;, &#39;hitting Bean&#39;],\n  learn: [&#39;chinese&#39;, &#39;math&#39;, &#39;english&#39;],\n  work: [&#39;tea&#39;],\n\n  &#x2F;&#x2F; 提供一个统一遍历的方法\n  each: function (callback) &#123;\n    const all &#x3D; [].concat(this.life, this.learn, this.work)\n    for (const item of all) &#123;\n      callback(item)\n    &#125;\n  &#125;,\n\n  &#x2F;&#x2F; 或者使用迭代器模式 （ES2015 统一遍历访问接口）\n  [Symbol.iterator]: function () &#123;\n    const all &#x3D; [...this.life, ...this.learn, ...this.work]\n    let index &#x3D; 0\n    return &#123;\n      next: function () &#123;\n        return &#123;\n          value: all[index],\n          done: index++ &gt;&#x3D; all.length\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\ntodo.each(i &#x3D;&gt; console.log(i))\n\nfor(const item of todo) &#123;\n  console.log(item)\n&#125;\n\n\nGeneratorfunction * foo () &#123;\n  console.log(&#39;111&#39;)\n  yield 100\n  console.log(&#39;222&#39;)\n  yield 200\n  console.log(&#39;333&#39;)\n  yield 300\n&#125;\n\nconst generator &#x3D; foo()\n\n&#x2F;&#x2F; 第一次调用， 函数题开始执行，遇到第一个 yield 暂停\nconsole.log(generator.next())\n&#x2F;&#x2F; 第二次调用，从暂停位置继续，知道遇到下一个 yield 再次暂停\nconsole.log(generator.next())\n&#x2F;&#x2F; 。。。\nconsole.log(generator.next())\n&#x2F;&#x2F; 第四次调用，已经没有需要执行的内容，所以 value 得到了 undefined\nconsole.log(generator.next())\n&#x2F;&#x2F; &#123; value: 100, done: false &#125;\n&#x2F;&#x2F; 222\n&#x2F;&#x2F; &#123; value: 200, done: false &#125;\n&#x2F;&#x2F; 333\n&#x2F;&#x2F; &#123; value: 300, done: false &#125;\n&#x2F;&#x2F; &#123; value: undefined, done: true &#125;\n\n\n案例一：发号器\n\nfunction* createId() &#123;\n  let id &#x3D; 1\n  while (true) &#123;\n    yield id++\n  &#125;\n&#125;\n\nconst idMaker &#x3D; createId()\n\nconsole.log(idMaker.next().value)\nconsole.log(idMaker.next().value)\nconsole.log(idMaker.next().value)\nconsole.log(idMaker.next().value)\nconsole.log(idMaker.next().value)\n&#x2F;&#x2F; 1\n&#x2F;&#x2F; 2\n&#x2F;&#x2F; 3\n&#x2F;&#x2F; 4\n&#x2F;&#x2F; 5\n\n\n案例二：使用 generator 实现 iterator 方法\n\nconst todo &#x3D; &#123;\n  life: [&#39;eating&#39;, &#39;sleeping&#39;, &#39;hitting Bean&#39;],\n  learn: [&#39;chinese&#39;, &#39;math&#39;, &#39;english&#39;],\n  work: [&#39;tea&#39;],\n\n  &#x2F;&#x2F; Generator 正好返回 value 和 done 类型的值，正好符合迭代器\n  [Symbol.iterator]: function* () &#123;\n    const all &#x3D; [...this.life, ...this.learn, ...this.work]\n    for (const item of all) &#123;\n      yield item\n    &#125;\n  &#125;\n&#125;\n\nfor (const item of todo) &#123;\n  console.log(item)\n&#125;\n&#x2F;&#x2F; sleeping\n&#x2F;&#x2F; hitting Bean\n&#x2F;&#x2F; chinese\n&#x2F;&#x2F; math\n&#x2F;&#x2F; english\n&#x2F;&#x2F; tea\n","slug":"ecmascript2015","date":"2021-12-31T03:30:00.000Z","categories_index":"JavaScript","tags_index":"JAVASCRIPT,ECMASCRIPT,ES6","author_index":"SKY"},{"id":"076515ed99fa4d813b6007ee6d9ea2b4","title":"JavaScript 系列","content":"JavaScript 系列编程挑战ProgrammingChallenge\n函数式编程FunctionalProgramming\n简单 Promise 实现MyPromise\nES2015 新特性ES2015 新特性\nES2016 新特性ES2016 新特性\nES2017 新特性ES2017 新特性\nESModuleESModule 介绍\n","slug":"javascriptSeries","date":"2021-12-31T03:30:00.000Z","categories_index":"编程","tags_index":"JAVASCRIPT,ECMASCRIPT","author_index":"SKY"},{"id":"a0308f1b66e47c358aa4918dab10369a","title":"GRPC TypeScript Timestamp to Date","content":"GRPC TypeScript TimeStamp to Date修改原因protobufjs 社区中没有针对 google 的包做处理，已经有了多个 PR，如果独立维护 protobufjs 是有成本的，间接性修改源码，以减少维护成本，所以选取了一个改动较小的代码进行使用\n支持传入 Date 类型\n根据 PR 修改源代码\n\n需要把 protobufjs 中的 converter.js 提取出来，根据 protobufjs PR 修改源代码修改后的 converter.js\n\n加载 proto 文件\n\n核心思想是在加载 @grpc/proto-loader 之前，先把 protobufjs/src/converter 加载，然后修改 converter 中 toObject 和 fromObject 函数，再通过 import() 函数加载 @grpc/proto-loader ，这时就会使用修改后的 converter 进行对象转换。如果直接使用 import 无法在导入 @grpc/proto-loader 之前修改，因为 import 会被提前。而 import() 函数是一个异步函数，CommonJs 可以直接使用 require() 函数进行加载。\nproto 文件\nimport * as path from &#39;path&#39;\nimport * as grpc from &#39;@grpc&#x2F;grpc-js&#39;\n&#x2F;&#x2F; 先加载 converter 文件\nimport * as converter from &#39;protobufjs&#x2F;src&#x2F;converter&#39;\nimport * as  converterLib from &#39;.&#x2F;lib&#x2F;converter&#39;\n\n&#x2F;&#x2F; 重写 converter 文件\nconverter.toObject &#x3D; converterLib.toObject\nconverter.fromObject &#x3D; converterLib.fromObject\n\nexport async function load() &#123;\n  &#x2F;&#x2F; 通过 import() 导入 @grpc&#x2F;proto-loader 包\n  &#x2F;&#x2F; 这时里面的 converter 已经被重写，即使用的修改后的文件\n  const protoLoader &#x3D; await import(&#39;@grpc&#x2F;proto-loader&#39;)\n  const packageDefinition &#x3D; protoLoader.loadSync(\n    path.join(__dirname, &#39;..&#x2F;..&#x2F;proto&#x2F;hello&#x2F;test.proto&#39;), &#123;\n      keepCase: true,\n      longs: String,\n      enums: String,\n      defaults: true,\n      oneofs: true,\n    &#125;)\n  return grpc.loadPackageDefinition(packageDefinition) as any\n&#125;\n\n\nserver.ts\n\nserver 端示例代码，此时 Timestamp 类型可以直接使用 Date 类型，并且不能使用之前的 Timestamp 类型\nimport * as grpc from &#39;@grpc&#x2F;grpc-js&#39;\nimport &#123; load &#125; from &#39;.&#x2F;proto&#39;\n\nfunction SayHello(call, callback) &#123;\n  console.log(call.request, &#39;call&#39;)\n  callback(null, &#123;\n    message: &#39;hhh&#39;,\n\n    &#x2F;&#x2F; google.protobuf.Timestamp 类型可以直接通过 new Date() 进行赋值\n    updated_time: new Date(),\n    time3: new Date(),\n    a: &#123;\n      time1: new Date(),\n      b: &#123;\n        time2: new Date(),\n      &#125;,\n    &#125;,\n  &#125;)\n&#125;\n\nasync function main() &#123;\n  const server &#x3D; new grpc.Server()\n  const hello &#x3D; await load()\n\n  server.addService(hello.hello.Greeter.service, &#123; SayHello &#125;)\n\n  server.bindAsync(&#39;127.0.0.1:56789&#39;, grpc.ServerCredentials.createInsecure(), () &#x3D;&gt; &#123;\n    server.start()\n    console.log(&#39;grpc server started&#39;)\n  &#125;)\n&#125;\n\nmain().then(res &#x3D;&gt; console.log(res, &#39;res&#39;))\n\n\n\nclient.ts\n\nclient 端示例代码，此时 Timestamp 类型可以直接使用 Date 类型，并且不能使用之前的 Timestamp 类型\nimport * as grpc from &#39;@grpc&#x2F;grpc-js&#39;\nimport &#123; load &#125; from &#39;.&#x2F;proto&#39;\n\nconst deadline &#x3D; new Date()\ndeadline.setSeconds(deadline.getSeconds() + 50)\n\nasync function main() &#123;\n  const hello &#x3D; await load()\n  const client &#x3D; new hello.hello.Greeter(&#39;127.0.0.1:56789&#39;, grpc.credentials.createInsecure())\n\n  client.waitForReady(deadline, err &#x3D;&gt; &#123;\n    console.log(err, &#39;err&#39;)\n    console.log(&#39;client start ......&#39;)\n  &#125;)\n\n  client.SayHello(&#123;\n    message: &#39;Hello&#39;,\n    updated_time: new Date(),\n  &#125;, function (err, res) &#123;\n    if (err) &#123;\n      console.error(&#39;Error: &#39;, err)\n    &#125; else &#123;\n      console.log(res, &#39;response&#39;)\n    &#125;\n  &#125;)\n&#125;\n\nmain().then(res &#x3D;&gt; console.log(res,&#39;res&#39;))\n\n\n运行\n\nts-node server.ts\n#undefined res\n#grpc server started\n#&#123; message: &#39;Hello&#39;, updated_time: 2022-01-29T03:08:34.873Z &#125; call\nts-node client.ts\n#undefined res\n#undefined err\n#client start ......\n#&#123;\n#  message: &#39;hhh&#39;,\n#  updated_time: 2022-01-29T03:08:34.897Z,\n#  time3: 2022-01-29T03:08:34.897Z,\n#  a: &#123;\n#    time1: 2022-01-29T03:08:34.897Z,\n#    b: &#123; time2: 2022-01-29T03:08:34.897Z &#125;\n#  &#125;\n#&#125; response\n\n项目地址ts-grpc-demo\n提供了三种使用方式\n\n使用 Timestamp 类型\n\nnpm run servernpm run client\n\n使用 使用生成的 types  \n\nnpm run proto &amp;&amp; npm run timestampToDatenpm run serverTypenpm run clientType\n\n使用 Date 类型\n\nnpm run serverGTnpm run clientGT\n","slug":"grpcTimestampToDate","date":"2021-12-28T16:00:00.000Z","categories_index":"后端","tags_index":"TYPESCRIPT,GRPC","author_index":"SKY"},{"id":"985a6e9f306f90ab989025adc0137572","title":"egg-bull-board-adapter","content":"egg-bull-board-adapteregg-bull-board\n产生原因egg.js 中不能直接使用 @bull-board/koa 中的 KoaAdapter\n&#x2F;&#x2F; bull-board&#x2F;packages&#x2F;koa&#x2F;src&#x2F;KoaAdapter.ts&#x2F;registerPlugin()\n&#x2F;&#x2F; ......\nviewRoutes.forEach((path) &#x3D;&gt; &#123;\n  router[method](path, async (ctx) &#x3D;&gt; &#123;\n    const &#123; name &#125; &#x3D; handler();\n    \n    &#x2F;&#x2F; 在 eggjs 中回去调用 egg.views 中的 render 方法，会导致找不到 index.ejs 文件\n    &#x2F;&#x2F; 所以需要重写 ctx.render 方法，使其调用 koa-views 中的 render\n    await (ctx as any).render(name, &#123; basePath: this.basePath &#125;);\n  &#125;);\n&#125;);\n&#x2F;&#x2F; ......\n\n解决办法&#x2F;&#x2F; egg-bull-board&#x2F;src&#x2F;EggAdapter&#x2F;registerPlugin()\nimport views from &#39;koa-views&#39;\n&#x2F;&#x2F; ......\nviewRoutes.forEach((path) &#x3D;&gt; &#123;\n  router[method](path, async (ctx) &#x3D;&gt; &#123;\n    const &#123; name &#125; &#x3D; handler();\n\n    &#x2F;&#x2F; 调用 koa-views 中的方法覆盖 ctx.render 方法\n    (ctx as any).render &#x3D; views(this.staticPath, &#123;\n      extension: &#39;ejs&#39;,\n      map: &#39;ejs&#39;\n    &#125;)(null as any, null as any)\n    await (ctx as any).render(name, &#123; basePath: this.basePath &#125;)\n  &#125;)\n&#125;)\n&#x2F;&#x2F; ......\n\negg 中使用\n装包，附带了 @bull-board/ui 和 @bull-board/api\nnpm install @skyfury&#x2F;egg-bull-board -S\negg router.js\n\n\n&#39;use strict&#39;;\n\nconst Bull &#x3D; require(&#39;bull&#39;)\nconst &#123; EggAdapter &#125; &#x3D; require(&#39;@skyfury&#x2F;egg-bull-board&#39;)\nconst &#123; createBullBoard &#125; &#x3D; require(&#39;@bull-board&#x2F;api&#39;);\nconst &#123; BullAdapter &#125; &#x3D; require(&#39;@bull-board&#x2F;api&#x2F;bullAdapter&#39;);\n\nconst redisOptions &#x3D; &#123;\n  port: 6379,\n  host: &#39;localhost&#39;,\n  password: &#39;&#39;,\n  tls: false,\n&#125;;\n\nconst createQueue &#x3D; (name) &#x3D;&gt; new Bull(name, &#123; connection: redisOptions &#125;);\n\nmodule.exports &#x3D; app &#x3D;&gt; &#123;\n  const &#123; router, controller &#125; &#x3D; app;\n\n  const bullQueue &#x3D; createQueue(&#39;bull&#39;);\n  \n  &#x2F;&#x2F; 使用 EggAdapter\n  const serverAdapter &#x3D; new EggAdapter();\n  createBullBoard(&#123;\n    queues: [new BullAdapter(bullQueue)],\n    serverAdapter,\n  &#125;);\n  serverAdapter.setBasePath(&#39;&#x2F;ui&#39;);\n  app.use(serverAdapter.registerPlugin());\n  \n  router.get(&#39;&#x2F;add&#39;, async (ctx) &#x3D;&gt; &#123;\n    const opts &#x3D; ctx.query.opts || &#123;&#125;;\n\n    if (opts.delay) &#123;\n      opts.delay &#x3D; +opts.delay * 1000; &#x2F;&#x2F; delay must be a number\n    &#125;\n\n    await bullQueue.add(&#39;Add&#39;, &#123; title: ctx.query.title &#125;, opts);\n\n    ctx.body &#x3D; &#123;\n      ok: true,\n    &#125;;\n  &#125;);\n\n  console.log(&#96;For the UI of instance1, open http:&#x2F;&#x2F;localhost:$&#123;app.config.cluster.listen.port&#125;&#x2F;ui&#96;);\n  console.log(&#39;Make sure Redis is running on port 6379 by default&#39;);\n  console.log(&#39;To populate the queue, run:&#39;);\n  console.log(&#96;  curl http:&#x2F;&#x2F;localhost:$&#123;app.config.cluster.listen.port&#125;&#x2F;add?title&#x3D;Example&#96;);\n  console.log(&#39;To populate the queue with custom options (opts), run:&#39;);\n  console.log(&#96;  curl http:&#x2F;&#x2F;localhost:$&#123;app.config.cluster.listen.port&#125;&#x2F;add?title&#x3D;Test&amp;opts[delay]&#x3D;9&#96;);\n&#125;;\n\n","slug":"eggBullBoardAdapter","date":"2021-12-17T10:30:00.000Z","categories_index":"后端","tags_index":"JAVASCRIPT,TYPESCRIPT,EGGJS,BULL-BOARD,BULLJS","author_index":"SKY"},{"id":"8c7191ccbfefacf8736e1c2ac855bf1e","title":"gitlab-runner","content":"gitlab-runnermac下安装 gitlab-runner其他系统可以参照官方文档gitlab runner install\nbrew install gitlab-runner\n\nbrew services start gitlab-runner\n\n.gitlab-ci.ymlnode 项目示例\nimage: 3jbq95i3.mirror.aliyuncs.com&#x2F;library&#x2F;node:14-alpine\n\nstages:\n  - test\n\ntest:\n  stage: test\n  ## 环境变量，可以通过 process.env.变量名 获取\n  variables:\n    TZ: &#39;Asia&#x2F;Shanghai&#39;\n    # mongo 作为依赖的连接 host\n    MONGODB: &#39;mongodb:&#x2F;&#x2F;mongo&#x2F;test&#39;\n    # redis 作为依赖的连接的 host\n    REDIS_HOST: redis\n  services:\n    # 依赖 mongo\n    - mongo:4.2\n    # 依赖 redis\n    - redis:latest\n    # 或者可以使用别名\n    # - name: mongo:4.2\n    #   alias: mongo111\n\n  script:\n    - npm config set registry &#39;https:&#x2F;&#x2F;registry.npm.taobao.org&#39;\n    - npm install\n    # 项目中的测试命令\n    - npm run ci\n\n本地运行 CI# --docker-pull-policy&#x3D;never 可以在 .gitlab-ci.yml 中使用本地镜像，test 需要执行的名称\ngitlab-runner exec docker --docker-pull-policy&#x3D;never test\n","slug":"gitlabRunner","date":"2021-12-17T06:30:00.000Z","categories_index":"教程","tags_index":"GITLAB","author_index":"SKY"},{"id":"66f57e202e85c56083a0db8b6aa3f2f8","title":"Promise 简写","content":"MyPromise&#x2F;&#x2F; 状态状态\nconst PENDING &#x3D; &#39;PENDING&#39;\n\n&#x2F;&#x2F; 成功状态\nconst FULFILLED &#x3D; &#39;FULFILLED&#39;\n\n&#x2F;&#x2F; 失败状态\nconst REJECTED &#x3D; &#39;REJECTED&#39;\n\nclass MyPromise &#123;\n  constructor(executor) &#123;\n    try &#123;\n      &#x2F;&#x2F; 执行器，立即执行\n      executor(this.resolve, this.reject)\n    &#125; catch (e) &#123;\n      this.reject(e)\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 初始化状态为准备状态\n  status &#x3D; PENDING\n\n  &#x2F;&#x2F; resolve 的值\n  value &#x3D; undefined\n\n  &#x2F;&#x2F; reject 的值\n  error &#x3D; undefined\n\n  &#x2F;&#x2F; 成功的回调，主要用于异步的情况下多次调用 then 方法\n  successCallBack &#x3D; []\n\n  &#x2F;&#x2F; 失败的回调\n  errorCallBack &#x3D; []\n\n  &#x2F;**\n   * 成功调用，箭头函数里面没有 this，使用 this 时既是外部的 this\n   * @param value 成功后的返回值\n   *&#x2F;\n  resolve &#x3D; value &#x3D;&gt; &#123;\n\n    &#x2F;&#x2F; 状态更改后就不能再次修改，直接返回\n    if (this.status !&#x3D;&#x3D; PENDING) &#123;\n      return\n    &#125;\n\n    &#x2F;&#x2F; 更新状态为成功\n    this.status &#x3D; FULFILLED\n\n    &#x2F;&#x2F; 保存值\n    this.value &#x3D; value\n\n    &#x2F;&#x2F; 执行异步的多次回调\n    while (this.successCallBack.length) &#123;\n      this.successCallBack.shift()()\n    &#125;\n  &#125;\n  &#x2F;**\n   * 失败调用\n   * @param error 错误信息\n   *&#x2F;\n  reject &#x3D; error &#x3D;&gt; &#123;\n\n    &#x2F;&#x2F; 状态修改后就不能再次修改\n    if (this.status !&#x3D;&#x3D; PENDING) &#123;\n      return\n    &#125;\n\n    &#x2F;&#x2F; 更新状态为失败\n    this.status &#x3D; REJECTED\n\n    &#x2F;&#x2F; 保存失败原因\n    this.error &#x3D; error\n\n    &#x2F;&#x2F; 执行异步的多次回调\n    while (this.errorCallBack.length) &#123;\n      this.errorCallBack.shift()()\n    &#125;\n  &#125;\n\n  &#x2F;**\n   * then 方法\n   * @param successCallBack 成功的回调\n   * @param errorCallBack 失败的回调\n   * @return &#123;MyPromise&#125;\n   *&#x2F;\n  then(successCallBack, errorCallBack) &#123;\n    &#x2F;&#x2F; 如果没有传值，默认返回原有的值\n    successCallBack &#x3D; successCallBack || (value &#x3D;&gt; value)\n\n    &#x2F;&#x2F; 如果没有传值，默认抛出原有的错误\n    errorCallBack &#x3D; errorCallBack || (error &#x3D;&gt; &#123;\n      throw error\n    &#125;)\n\n    &#x2F;&#x2F; then 方法需要返回一个行的 MyPromise 对象\n    const promise &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;\n\n      if (this.status &#x3D;&#x3D;&#x3D; FULFILLED) &#123;\n\n        &#x2F;&#x2F; 状态为成功\n        &#x2F;&#x2F; setTimeout 可以保证 promise 中有值，即里面的语句跳过了当前的事件循环\n        setTimeout(() &#x3D;&gt; &#123;\n          try &#123;\n\n            &#x2F;&#x2F; 成功的回调，回调可能返回新的值\n            const x &#x3D; successCallBack(this.value)\n\n            &#x2F;&#x2F; 处理回调返回的值\n            resolvePromise(promise, x, resolve, reject)\n          &#125; catch (e) &#123;\n\n            &#x2F;&#x2F; 异常处理\n            reject(e)\n          &#125;\n        &#125;, 0)\n      &#125; else if (this.status &#x3D;&#x3D;&#x3D; REJECTED) &#123;\n\n        &#x2F;&#x2F; 状态为失败\n        setTimeout(() &#x3D;&gt; &#123;\n          try &#123;\n\n            &#x2F;&#x2F; 失败的回调，失败可能返回新的值\n            const x &#x3D; errorCallBack(this.error)\n\n            &#x2F;&#x2F; 处理回调的返回的值\n            resolvePromise(promise, x, resolve, reject)\n          &#125; catch (e) &#123;\n\n            &#x2F;&#x2F; 异常处理\n            reject(e)\n          &#125;\n        &#125;, 0)\n      &#125; else &#123;\n\n        &#x2F;&#x2F; 异步的情况，状态还没有更改\n        &#x2F;&#x2F; 同一个 promise 的 then 方法支持多次调用，回掉中的值保持不变\n        this.successCallBack.push(() &#x3D;&gt; &#123;\n          setTimeout(() &#x3D;&gt; &#123;\n            try &#123;\n              const x &#x3D; successCallBack(this.value)\n              resolvePromise(promise, x, resolve, reject)\n            &#125; catch (e) &#123;\n              reject(e)\n            &#125;\n          &#125;, 0)\n        &#125;)\n        this.errorCallBack.push(() &#x3D;&gt; &#123;\n          setTimeout(() &#x3D;&gt; &#123;\n            try &#123;\n              const x &#x3D; errorCallBack(this.error)\n              resolvePromise(promise, x, resolve, reject)\n            &#125; catch (e) &#123;\n              reject(e)\n            &#125;\n          &#125;, 0)\n        &#125;)\n      &#125;\n    &#125;)\n\n    &#x2F;&#x2F; then 返回一个新的 MyPromise 对象\n    return promise\n  &#125;\n\n  &#x2F;**\n   * 构造一个成功的 MyPromise 对象\n   * @param value 包装的值\n   * @return &#123;MyPromise&#125;\n   *&#x2F;\n  static resolve(value) &#123;\n\n    &#x2F;&#x2F; 如果值是一个 MyPromise 对象，则返回原有的值\n    if (value instanceof MyPromise) &#123;\n      return value\n    &#125;\n\n    &#x2F;&#x2F; 否则返回一个新的 MyPromise 对象\n    return new MyPromise(resolve &#x3D;&gt; resolve(value))\n  &#125;\n\n  &#x2F;**\n   * 失败回调的别名\n   * @param errorCallback 失败回调方法\n   * @return &#123;MyPromise&#125;\n   *&#x2F;\n  catch(errorCallback) &#123;\n\n    &#x2F;&#x2F; 成功回调设置为 undefined 即可\n    return this.then(undefined, errorCallback)\n  &#125;\n\n  &#x2F;**\n   * 无论什么状态，都会调用的方法，返回一个新的 MyPromise 对象\n   * @param callback 回调\n   * @return &#123;MyPromise&#125;\n   *&#x2F;\n  finally(callback) &#123;\n    return this.then(value &#x3D;&gt; &#123;\n      return MyPromise.resolve(callback()).then(() &#x3D;&gt; value)\n    &#125;, err &#x3D;&gt; &#123;\n      return MyPromise.resolve(callback()).then(() &#x3D;&gt; &#123;\n        throw err\n      &#125;)\n    &#125;)\n  &#125;\n\n  &#x2F;**\n   * 把一个数组中的每个值都转为 MyPromise 对象，并且执行，按照原有的顺序返回值\n   * @param arr 数组对象\n   * @return &#123;MyPromise&#125;\n   *&#x2F;\n  static all(arr) &#123;\n    const result &#x3D; []\n    let index &#x3D; 0\n\n    &#x2F;&#x2F; 返回一个新的 MyPromise 对象\n    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;\n\n      &#x2F;**\n       * 添加执转换后的值\n       * @param key\n       * @param value\n       *&#x2F;\n      function addData(key, value) &#123;\n        result[key] &#x3D; value\n        index++\n\n        &#x2F;&#x2F; 判断是否都已经执行完毕\n        if (index &#x3D;&#x3D;&#x3D; arr.length) &#123;\n          resolve(result)\n        &#125;\n      &#125;\n\n      for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n\n        &#x2F;&#x2F; 获取数组中的值\n        const current &#x3D; arr[i]\n        if (current instanceof MyPromise) &#123;\n\n          &#x2F;&#x2F; 如果是 MyPromise 对象\n          current.then(value &#x3D;&gt; addData(i, value), err &#x3D;&gt; reject(err))\n        &#125; else &#123;\n\n          &#x2F;&#x2F; 如果是普通的对象\n          addData(i, arr[i])\n        &#125;\n      &#125;\n    &#125;)\n  &#125;\n&#125;\n\n&#x2F;**\n * 处理回调的值\n * @param promise 新的 MyPromise 对象\n * @param x 回调的值\n * @param resolve 成功调用\n * @param reject 失败调用\n * @return &#123;*&#125;\n *&#x2F;\nfunction resolvePromise(promise, x, resolve, reject) &#123;\n\n  &#x2F;&#x2F; 判断新的 MyPromise 对象是否 和回调的 MyPromise 是同一个对象\n  if (promise &#x3D;&#x3D;&#x3D; x) &#123;\n    return reject(new TypeError(&#39;Chaining cycle detected for promise #&lt;Promise&gt;&#39;))\n  &#125;\n  if (x instanceof MyPromise) &#123;\n\n    &#x2F;&#x2F; 如果是一个新的 MyPromise 对象\n    x.then(resolve, reject)\n  &#125; else &#123;\n    resolve(x)\n  &#125;\n&#125;\n\nmodule.exports &#x3D; MyPromise\n\n\n使用方法const MyPromise &#x3D; require(&#39;MyPromise&#39;)\n\nconst pomise &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;\n  resolve(100)\n&#125;)\n\n&#x2F;&#x2F; 重复调用 then\npomise.then(res &#x3D;&gt; &#123;\n  console.log(res)\n&#125;)\n\n&#x2F;&#x2F; 链式调用\npromise.then(res &#x3D;&gt; &#123;\n  console.loe(res)\n  return 100\n&#125;)\n  .then(res &#x3D;&gt; &#123;\n    console.log(res)\n  &#125;)\n  .catch(err &#x3D;&gt; &#123;\n    console.log(err)\n  &#125;)\n\n&#x2F;&#x2F; all 方法\nMyPromise.all([1, 2, new MyPromise((r, j) &#x3D;&gt; r(100)), 3])\n  .then(res &#x3D;&gt; &#123;\n    console.log(res)\n  &#125;)\n\n","slug":"promise","date":"2021-12-15T15:00:00.000Z","categories_index":"JavaScript","tags_index":"JAVASCRIPT","author_index":"SKY"},{"id":"12f35e821d0385fb0185ca26a956309f","title":"javascript asynchronous(未完成)","content":"JavaScript AsynchronousJavaScript 执行方法同步模式和异步模式\nSynchronous （同步模式）\n\nconsole.log(&#39;global begin&#39;)\n\nfunction bar() &#123;\n  console.log(&#39;bar task&#39;)\n&#125;\n\nfunction foo() &#123;\n  console.log(&#39;foo task&#39;)\n  bar()\n&#125;\n\nfoo()\nconsole.log(&#39;global end&#39;)\n\n\nAsynchronous （异步模式）\n\nconsole.log(&#39;global begin&#39;)\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;timer1 invoke&#39;)\n&#125;, 1800)\n\nsetTimeout(() &#x3D;&gt; &#123;\n  consle.log(&#39;timer2 invoke&#39;)\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;inner invoke&#39;)\n  &#125;, 1000)\n&#125;, 1000)\n\nconsole.log(&#39;global end&#39;)\n\n事件循环与消息队列\n异步编程的几种方式回调函数function foo(callback) &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    callback()\n  &#125;, 3000)\n&#125;\n\nfoo(() &#x3D;&gt; &#123;\n  console.log(&#39;这就是一个回调函数&#39;)\n  console.log(&#39;调用者定义这个函数，执行者执行这个函数&#39;)\n  console.log(&#39;其实就是调用者告诉执行者异步任务结束后应该做什么&#39;)\n&#125;)\n\nPromise 异步方案、宏任务/微任务队列&#x2F;&#x2F; 回调地狱，只是示例，不能运行\n\n$.get(&#39;&#x2F;url1&#39;, function (data1) &#123;\n  $.get(&#39;&#x2F;url2&#39;, data1, function (data2) &#123;\n    $.get(&#39;&#x2F;url3&#39;, data2, function (data3) &#123;\n      $.get(&#39;&#x2F;url4&#39;, data3, function (data4) &#123;\n        $.get(&#39;&#x2F;url5&#39;, data4, function (data5) &#123;\n          $.get(&#39;&#x2F;url6&#39;, data5, function (data6) &#123;\n            $.get(&#39;&#x2F;url7&#39;, data6, function (data7) &#123;\n              &#x2F;&#x2F; 略微夸张了一点点\n            &#125;)\n          &#125;)\n        &#125;)\n      &#125;)\n    &#125;)\n  &#125;)\n&#125;)\n\n\nPromise 的状态不可变\n\n使用示例\n\nconst promise &#x3D; new Promise((function (resolve, reject) &#123;\n  &#x2F;&#x2F; 这里用于 &quot;兑现&quot; 承诺，两个回调只有一个能生效，以先执行的为准\n  &#x2F;&#x2F; resolve(100) &#x2F;&#x2F; 承诺达成\n  reject(new Error(&#39;promise rejected&#39;)) &#x2F;&#x2F; 承诺失败\n&#125;))\n\npromise.then(value &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 即便没有异步调用，then 方法中传入的回调仍然会被放入到队列，等待下一轮执行\n  console.log(value)\n&#125;, error &#x3D;&gt; &#123;\n  console.log(&#39;rejected&#39;, error)\n&#125;)\n\nconsole.log(&#39;end&#39;)\n\n\nPromise 方式的 AJAX\n\nfunction ajax(url) &#123;\n  return new Promise((function (resolve, reject) &#123;\n    const xhr &#x3D; new XMLHttpRequest()\n    xhr.open(&#39;GET&#39;, url)\n    xhr.responseType &#x3D; &#39;json&#39;\n    xhr.onload &#x3D; function () &#123;\n      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        resolve(this.response)\n      &#125; else &#123;\n        reject(new Error(this.statusText))\n      &#125;\n    &#125;\n    xhr.send()\n  &#125;))\n&#125;\n\najax(&#39;&#x2F;api&#x2F;urls.json&#39;)\n  .then(res &#x3D;&gt; &#123;\n    console.log(res)\n  &#125;, err &#x3D;&gt; &#123;\n    console.log(err)\n  &#125;)\n\n&#x2F;&#x2F; 嵌套使用 Promise 是常见的误区\najax(&#39;&#x2F;api&#x2F;urls.json&#39;).then(urls &#x3D;&gt; &#123;\n  ajax(urls.users).then(users &#x3D;&gt; &#123;\n    ajax(urls.users).then(users &#x3D;&gt; &#123;\n      ajax(urls.users).then(users &#x3D;&gt; &#123;\n        ajax(urls.users).then(users &#x3D;&gt; &#123;\n\n        &#125;)\n      &#125;)\n    &#125;)\n  &#125;)\n&#125;)\n\n&#x2F;&#x2F; then 中回到的 value 参数就是上一个 Promise 对象的返回值\najax(&#39;&#x2F;api&#x2F;users.json&#39;)\n  .then(value &#x3D;&gt; &#123;\n    console.log(111)\n    return ajax(&#39;&#x2F;api&#x2F;urls.json&#39;)\n  &#125;)\n  .then(value &#x3D;&gt; &#123;\n    console.log(value)\n    return ajax(&#39;&#x2F;api&#x2F;urls.json&#39;)\n  &#125;)\n  .then(value &#x3D;&gt; &#123;\n    console.log(value)\n    return ajax(&#39;&#x2F;api&#x2F;urls.json&#39;)\n  &#125;)\n  .then(value &#x3D;&gt; &#123;\n    throw new Error(&#39;test&#39;)\n    console.log(value)\n    return &#39;foo&#39;\n  &#125;)\n  .then(value &#x3D;&gt; &#123;\n    console.log(value)\n  &#125;)\n  .catch(e &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 如果链式调用中有一个抛出异常，错误会传递到最后一个 Promise 对象，并被 catch 捕获到\n    console.log(e)\n  &#125;)\n\n&#x2F;&#x2F; 全局异常捕获 window\nwindow.addEventListener(&#39;unhandledrejection&#39;, event &#x3D;&gt; &#123;\n  const &#123;reason, promise&#125; &#x3D; event\n  console.log(reason, promise)\n  &#x2F;&#x2F; reason &#x3D;&gt; Promise 失败的原因，一般是一个错误对象\n  &#x2F;&#x2F; promise &#x3D;&gt; 出现异常的 Promise 对象\n  event.preventDefault()\n&#125;, false)\n\n&#x2F;&#x2F; Node.js 使用以下的方式\nprocess.on(&#39;unhandledRejection&#39;, (reason, promise) &#x3D;&gt; &#123;\n  conosle.log(reason, promise)\n  &#x2F;&#x2F; reason &#x3D;&gt; Promise 失败原因，一把是一个错误对象\n  &#x2F;&#x2F; promise &#x3D;&gt; 出现异常的 Promise 对象\n&#125;)\n\n\nPromise 中的静态方法\n\n\nPromise.resolve()\n\nfunction ajax(url) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    &#x2F;&#x2F; foo()\n    &#x2F;&#x2F; throw new Error()\n    var xhr &#x3D; new XMLHttpRequest()\n    xhr.open(&#39;GET&#39;, url)\n    xhr.responseType &#x3D; &#39;json&#39;\n    xhr.onload &#x3D; function () &#123;\n      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        resolve(this.response)\n      &#125; else &#123;\n        reject(new Error(this.statusText))\n      &#125;\n    &#125;\n    xhr.send()\n  &#125;)\n&#125;\n\nPromise.resolve(&#39;foo&#39;)\n  .then(value &#x3D;&gt; console.log(value))\n&#x2F;&#x2F; 如何上面等效\nnew Promise((function (resolve, reject) &#123;\n  resolve(&#39;foo&#39;)\n&#125;))\n\nconst promise &#x3D; ajax(&#39;&#x2F;api&#x2F;users.json&#39;)\nconst promise2 &#x3D; Promise.resolve(promise)\nconsole.log(promise &#x3D;&#x3D;&#x3D; promise2)\n&#x2F;&#x2F; &#x3D;&gt; true\n\n&#x2F;&#x2F; 如果传入一个根 Promise 一样的 then 方法对象\n&#x2F;&#x2F; Promise.resolve 会将这个对象作为 Promise 执行\n\nPromise.resolve(&#123;\n  then: function (onfulfilled, onrejected) &#123;\n    onfulfilled(&#39;foo&#39;)\n  &#125;\n&#125;)\n  .then(value &#x3D;&gt; &#123;\n    console.log(value)\n  &#125;)\n\n\nPromise.reject()\n\n&#x2F;&#x2F; Promise.reject 传入任何值，都会作为这个 Promise失败的理由\nPromise.reject(new Error(&#39;rejected&#39;))\n  .catch(e &#x3D;&gt; &#123;\n    console.log(e)\n  &#125;)\n\nPromise.reject(&#39;anything&#39;)\n  .catch(e &#x3D;&gt; &#123;\n    console.log(e)\n  &#125;)\n\n\nPromise.all()\n\n&#x2F;&#x2F; 将多个 Promise 组合为一个新的 Promise, all() 需要全部都执行成功才算成功\nconst promise &#x3D; Promise.all([\n  ajax(&#39;&#x2F;api&#x2F;users.json&#39;),\n  ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)\n])\n\n&#x2F;&#x2F; value 返回的是一个数组，是每个 Promise 执行后的结果\npromise.then(value &#x3D;&gt; &#123;\n  console.log(value)\n&#125;)\n  .catch(e &#x3D;&gt; &#123;\n    console.log(e)\n  &#125;)\n\n\najax(&#39;&#x2F;api&#x2F;urls.json&#39;)\n  .then(value &#x3D;&gt; &#123;\n    const urls &#x3D; Object.values(value)\n    const tasks &#x3D; urls.map(url &#x3D;&gt; ajax(url))\n    return Promise.all(tasks)\n  &#125;)\n  .then(values &#x3D;&gt; console.log(values))\n\n\nPromise.race()\n\n只要有一个成功则 Promise 成功\nconst request &#x3D; ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)\nconst timeout &#x3D; new Promise((function (resolve, reject) &#123;\n  setTimeout(() &#x3D;&gt; reject(new Error(&#39;timeout&#39;), 500))\n&#125;))\n\nPromise.race([\n  request,\n  timeout\n])\n  .then(value &#x3D;&gt; &#123;\n    console.log(value)\n  &#125;)\n  .catch(err &#x3D;&gt; &#123;\n    console.log(err)\n  &#125;)\n\n\n宏任务和微任务\n\nconsole.log(&#39;global start&#39;)\n\n&#x2F;&#x2F; setTimeout 的回调是宏任务，进入回调队列排队\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;setTimeout&#39;)\n&#125;, 0)\n\n&#x2F;&#x2F; Promise 的回调是微任务，本来调用末尾直接执行\nPromise.resolve()\n  .then(() &#x3D;&gt; &#123;\n    console.log(&#39;promise&#39;)\n  &#125;)\n  .then(() &#x3D;&gt; &#123;\n    console.log(&#39;promise1&#39;)\n  &#125;)\nconsole.log(&#39;global end&#39;)\n\n\n回调和链式调用\n\nfunction ajax(url, callback) &#123;\n  const executor &#x3D; (resolve, reject) &#x3D;&gt; &#123;\n    const xhr &#x3D; new XMLHttpRequest()\n    xhr.open(&#39;GET&#39;, url)\n    xhr.responseType &#x3D; &#39;json&#39;\n    xhr.onload &#x3D; () &#x3D;&gt; &#123;\n      if (xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        resolve(xhr.response)\n      &#125; else &#123;\n        reject(new Error(xhr.statusText))\n      &#125;\n    &#125;\n    xhr.send()\n  &#125;\n  if (typeof callback &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n    executor(\n      res &#x3D;&gt; callback(null, res),\n      err &#x3D;&gt; callback(err)\n    )\n  &#125;\n  return new Promise(executor)\n&#125;\n\n&#x2F;&#x2F; Callback hell\najax(&#39;&#x2F;api&#x2F;url1&#39;, (error, value) &#x3D;&gt; &#123;\n  ajax(&#39;&#x2F;api&#x2F;url1&#39;, (error, value) &#x3D;&gt; &#123;\n    ajax(&#39;&#x2F;api&#x2F;url1&#39;, (error, value) &#x3D;&gt; &#123;\n      ajax(&#39;&#x2F;api&#x2F;url1&#39;, (error, value) &#x3D;&gt; &#123;\n\n      &#125;)\n    &#125;)\n  &#125;)\n&#125;)\n\n&#x2F;&#x2F; Promise chain\najax(&#39;&#x2F;api&#x2F;url1&#39;)\n  .then(value &#x3D;&gt; &#123;\n    return ajax(&#39;&#x2F;api&#x2F;url2&#39;)\n  &#125;)\n  .then(value &#x3D;&gt; &#123;\n    return ajax(&#39;&#x2F;api&#x2F;url2&#39;)\n  &#125;)\n  .then(value &#x3D;&gt; &#123;\n    return ajax(&#39;&#x2F;api&#x2F;url2&#39;)\n  &#125;)\n  .catch(err &#x3D;&gt; &#123;\n    console.log(err)\n  &#125;)\n\n&#x2F;&#x2F; sync mode code\ntry &#123;\n  const value1 &#x3D; ajax(&#39;&#x2F;api&#x2F;url1&#39;)\n  console.log(value1)\n  const value2 &#x3D; ajax(&#39;&#x2F;api&#x2F;url1&#39;)\n  console.log(value2)\n  const value3 &#x3D; ajax(&#39;&#x2F;api&#x2F;url1&#39;)\n  console.log(value3)\n&#125; catch (e) &#123;\n  console.error(e)\n&#125; \n\nGenerator 异步方案、Async/Await 语法糖\ngenerator\n\n&#x2F;&#x2F; Generator\nfunction* foo() &#123;\n  console.log(&#39;start&#39;)\n  try &#123;\n    &#x2F;&#x2F; yield 会暂停函数执行，直到外部调用 next\n    const res &#x3D; yield &#39;foo&#39;\n    console.log(res)\n  &#125; catch (e) &#123;\n    console.log(e)\n  &#125;\n&#125;\n\nconst generator &#x3D; foo()\n\n&#x2F;&#x2F; 获取 yield 的返回的值，即 foo 函数中的 &#39;foo&#39;\nconst result &#x3D; generator.next()\nconsole.log(result)\n\n&#x2F;&#x2F; next 的参数作为 yield 的返回值，即 foo 函数中的 res\ngenerator.next(&#39;bar&#39;)\n&#x2F;&#x2F; 或者可以抛出异常，foo 函数中可以捕获\ngenerator.throw(new Error(&#39;Generator error&#39;))\n\n\nGenerator 配合 Promise 的异步方案\n\nfunction ajax(url) &#123;\n  return new Promise((function (resolve, reject) &#123;\n    const xhr &#x3D; new XMLHttpRequest()\n    xhr.open(&#39;GET&#39;, url)\n    xhr.responseType &#x3D; &#39;json&#39;\n    xhr.onload &#x3D; () &#x3D;&gt; &#123;\n      if (xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        resolve(xhr.response)\n      &#125; else &#123;\n        reject(new Error(xhr.statusText))\n      &#125;\n    &#125;\n    xhr.send()\n  &#125;))\n&#125;\n\nfunction* main() &#123;\n  try &#123;\n    const users &#x3D; yield ajax(&#39;&#x2F;api&#x2F;users.json&#39;)\n    console.log(users)\n\n    const posts &#x3D; yield ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)\n    console.log(posts)\n\n    const urls &#x3D; yield ajax(&#39;&#x2F;api&#x2F;urls11.json&#39;)\n    console.log(urls)\n  &#125; catch (e) &#123;\n    console.log(e)\n  &#125;\n&#125;\n\nconst generator &#x3D; main()\n\nconst result &#x3D; generator.next()\n&#x2F;&#x2F; 可以采取递归的方式\nresult.value.then(data &#x3D;&gt; &#123;\n  const result2 &#x3D; generator.next(data)\n  if (result2.done) return\n  result2.value.then(data &#x3D;&gt; &#123;\n    const result3 &#x3D; generator.next()\n    if (result3.done) return\n    result3.value.then(data &#x3D;&gt; &#123;\n\n    &#125;)\n  &#125;)\n&#125;)\n\n&#x2F;&#x2F; 上面代码的递归形式\nfunction handleResult(result) &#123;\n  if (result.done) return\n  result.value.then(data &#x3D;&gt; &#123;\n    handleResult(generator.next(data))\n  &#125;, error &#x3D;&gt; &#123;\n    generator.throw(error)\n  &#125;)\n&#125;\n\nhandleResult(generator.next())\n\n&#x2F;&#x2F; 封装 co 函数\nfunction co(fn) &#123;\n  const g &#x3D; fn()\n\n  function handleResult(result) &#123;\n\n    &#x2F;&#x2F; 已经没有后续结果\n    if (result.done) return\n    result.value.then(data &#x3D;&gt; &#123;\n\n      &#x2F;&#x2F; 继续调用下一个 next\n      handleResult(g.next(data))\n    &#125;, error &#x3D;&gt; &#123;\n      g.throw(error)\n    &#125;)\n  &#125;\n\n  handleResult(g.next())\n&#125;\n\nco(main)\n\n\nAsync/Await 方案\n\nasync function main() &#123;\n  try &#123;\n    const users &#x3D; await ajax(&#39;&#x2F;api&#x2F;users.json&#39;)\n    console.log(users)\n\n    const posts &#x3D; await ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)\n    console.log(posts)\n\n    const urls &#x3D; await ajax(&#39;&#x2F;api&#x2F;urls11.json&#39;)\n    console.log(urls)\n  &#125; catch (e) &#123;\n    console.log(e)\n  &#125;\n&#125;\n\nconst promise &#x3D; main()\n\npromise.then(() &#x3D;&gt; &#123;\n  console.log(&#39;all completed&#39;)\n&#125;)\n","slug":"asynchronousJavascript","date":"2021-12-12T15:00:00.000Z","categories_index":"JavaScript","tags_index":"JAVASCRIPT","author_index":"SKY"},{"id":"f1c5db41d78c24c5668189654926ca28","title":"Functional Programming","content":"Functional Programming什么是函数式编程函数式编程的思维方式：把显示世界的事务和事物之间的联系抽象到程序世界（对运算过程进行抽象）\n\n函数式编程中的函数指的数学中的函数即映射关系，输入的值对应一个输出的值，例如 y = f(x)\n相同的输入始终得到相同的输出（纯函数）\n函数式编程用来描述数据（函数）之间的映射\n\n&#x2F;&#x2F; 非函数式\nconst num1 &#x3D; 2\nconst num2 &#x3D; 3\nconst sum &#x3D; num1 + num2\nconsole.log(sum)\n\n&#x2F;&#x2F; 函数式\nfunction add(n1, n2) &#123;\n  return n1 + n2\n&#125;\n\nconst sum &#x3D; add(2, 3)\nconsole.log(sum)\n\n前置知识函数式一等公民（头等函数）MDB First-class Function\n\n函数可以存储在变量中\n函数作为参数\n函数作为返回值\n\n在 javascript 中函数就是一个普通对象（可以通过 new Function()），可以把函数存储到变量或者数组中，还可以当成另外一个函数的参数和返回值，甚至可以在程序运行的时候通过new Function(&#39;alter(1)&#39;)来构造一个新的函数。\n\n把函数复制给变量\n\nconst fn &#x3D; function () &#123;\n  console.log(&#39;this is a function&#39;)\n&#125;\n\nfn()\n\n&#x2F;&#x2F; 一个示例\nconst BlogController &#x3D; &#123;\n  index(posts) &#123;\n    return Views.index(posts)\n  &#125;,\n  show(post) &#123;\n    return Views.show(post)\n  &#125;,\n  create(attrs) &#123;\n    return Db.create(attrs)\n  &#125;,\n  update(post, attrs) &#123;\n    return Db.update(post, attrs)\n  &#125;,\n  destroy(post) &#123;\n    return Db.destroy(post)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 优化\nconst BlogController &#x3D; &#123;\n  index: Views.index,\n  show: Views.show,\n  create: Db.create,\n  update: Db.update,\n  destroy: Db.destroy\n&#125;\n\n高阶函数什么是高阶函数\n高阶函数(Higher-order function)\n可以把函数作为参数传递给另一个函数\n可以把函数作为另一个函数的返回值\n\n\n函数作为参数\n\nfunction forEach(array, fn) &#123;\n  for (let i &#x3D; 0; i &lt; array.length; i++) &#123;\n    fn(array[i])\n  &#125;\n&#125;\n\nfunction filter(array, fn) &#123;\n  const result &#x3D; []\n  for (let i &#x3D; 0; i &lt; array.length; i++) &#123;\n    if (fn(array[i])) &#123;\n      result.push(array[i])\n    &#125;\n  &#125;\n  return result\n&#125;\n\nconst a &#x3D; [1, 2, 3, 4, 5]\n\n\nforEach(a, v &#x3D;&gt; &#123;\n  console.log(v)\n&#125;)\n\nconst result &#x3D; filter(a, v &#x3D;&gt; &#123;\n  return v % 2 &#x3D;&#x3D;&#x3D; 0\n&#125;)\nconsole.log(result)\n\n\n函数作为返回值\n\nfunction makeFn() &#123;\n  const msg &#x3D; &#39;Hello Function&#39;\n\n  return function () &#123;\n    console.log(msg)\n  &#125;\n&#125;\n\nconst fn &#x3D; makeFn()\nfn()\n&#x2F;&#x2F; 或者\nmakeFn()()\n\n&#x2F;&#x2F; once 函数\nfunction once(fn) &#123;\n  let done &#x3D; false\n  return function () &#123;\n    if (!done) &#123;\n      done &#x3D; true\n      return fn.apply(this, arguments)\n    &#125;\n  &#125;\n&#125;\n\nconst onceFn &#x3D; once(function (msg) &#123;\n  console.log(msg)\n&#125;)\n\nonceFn(&#39;run once&#39;)\nonceFn(&#39;run once&#39;)\nonceFn(&#39;run once&#39;)\nonceFn(&#39;run once&#39;)\n\n使用高阶函数的意义\n抽象可以屏蔽细节，只需要关注目标\n高阶函数式用来抽象通用问题\n\n\n&#x2F;&#x2F; 面向过程的方式\nconst arr &#x3D; [1, 2, 3, 4]\n\nfor (const i of arr) &#123;\n  console.log(i)\n&#125;\n\n&#x2F;&#x2F; 高阶函数\n\nconst arr &#x3D; [1, 2, 3, 4]\n\n&#x2F;&#x2F; 前面定义的函数\nforEach(arr, item &#x3D;&gt; &#123;\n  console.log(item)\n&#125;)\n\n常用的高阶函数\nforEach\nmap\nfilter\nevery\nsome\nfind/findIndex\nreduce\nsort\n……\n\nconst map &#x3D; (arr, fn) &#x3D;&gt; &#123;\n  const result &#x3D; []\n  for (const value of arr) &#123;\n    result.push(fn(value))\n  &#125;\n  return result\n&#125;\n\nconst every &#x3D; (arr, fn) &#x3D;&gt; &#123;\n  let result &#x3D; true\n  for (const value of arr) &#123;\n    result &#x3D; fn(value)\n    if (!result) &#123;\n      break\n    &#125;\n  &#125;\n  return result\n&#125;\n\nconst some &#x3D; (arr, fn) &#x3D;&gt; &#123;\n  let result &#x3D; false\n  for (const value of arr) &#123;\n    result &#x3D; fn(value)\n    if (result) &#123;\n      break\n    &#125;\n  &#125;\n  return result\n&#125;\n\n闭包\n闭包（Closure）：函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包。\n可以在另一个作用域中调用一个函数的内部函数并访问该函数的作用域中的成员\n\n\n闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员\n闭包案例\n\nfunction makePower(power) &#123;\n  return function (x) &#123;\n    return Math.pow(x, power)\n  &#125;\n&#125;\n\nconst power2 &#x3D; makePower(2)\nconst power3 &#x3D; makePower(3)\n\nconsole.log(power2(2))\nconsole.log(power2(3))\nconsole.log(power3(2))\n\n纯函数纯函数概念\n纯函数：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用\n纯函数类似数学中的函数（用来描述输入和输出之间的关系），y = f(x)\n\n\n数组的 slice 和 splice 分别是：纯函数和不纯的函数\nslice 返回数组中的指定部分，不会改变原数组\nsplice 对数组进行操作返回该数组，会改变原数组\n\n\n\nlet numbers &#x3D; [1, 2, 3, 4, 5]\n&#x2F;&#x2F; 纯函数\nnumbers.slice(0, 3)\n&#x2F;&#x2F; &#x3D;&gt; [1, 2, 3]\nnumbers.slice(0, 3)\n&#x2F;&#x2F; &#x3D;&gt; [1, 2, 3]\nnumbers.slice(0, 3)\n&#x2F;&#x2F; &#x3D;&gt; [1, 2, 3]\n\n&#x2F;&#x2F; 不纯的函数\nnumbers.splice(0, 3)\n&#x2F;&#x2F; &#x3D;&gt; [1, 2, 3]\nnumbers.splice(0, 3)\n&#x2F;&#x2F; &#x3D;&gt; [4, 5]\nnumbers.splice(0, 3)\n&#x2F;&#x2F; &#x3D;&gt; []\n\n\n函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的）\n可以把一个函数的执行结果交给另一个函数去处理\n\n纯函数的好处\n可缓存\n纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来\n\n\nlodash memoize\n\nconst _ &#x3D; require(&#39;lodash&#39;)\n\nfunction getArea(r) &#123;\n  console.log(&#39;running&#39;)\n  return Math.PI * r * r\n&#125;\n\nconst getAreaWithMemory &#x3D; _.memoize(getArea)\n\nconsole.log(getAreaWithMemory(4))\nconsole.log(getAreaWithMemory(4))\nconsole.log(getAreaWithMemory(4))\n\n\n手动模拟\n\nfunction memoize(fn) &#123;\n  const cache &#x3D; &#123;&#125;\n  return function () &#123;\n    const key &#x3D; JSON.stringify(arguments)\n    cache[key] &#x3D; cache[key] || fn.apply(fn, arguments)\n    return cache[key]\n  &#125;\n&#125;\n\n\n可测试\n纯函数测试更方便\n\n\n并行处理\n在多线程环境下并行操作共享的内存数据很有可能会出现意外情况\n纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数（Web Worker）\n\n\n\n副作用\n纯函数： 对于相同的输入永远会得到相同的输出，而且没有任何可观察的副作用\n\n&#x2F;&#x2F; 不纯的函数\nconst mini &#x3D; 18\n\nfunction checkAge(age) &#123;\n  return age &gt;&#x3D; mini\n&#125;\n\n&#x2F;&#x2F; 纯函数（但是有硬编码，不方便扩展）\nfunction checkAge(age) &#123;\n  const mini &#x3D; 18\n  return age &gt;&#x3D; mini\n&#125;\n\n如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用。 副作用来源：\n\n配置文件\n数据库\n用户输入\n……\n\n所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控 范围内发生。\n柯里化（Haskell Brooks Curry）\n柯里化（Currying）：\n当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）\n然后返回一个新的函数接受剩余的参数，返回结果\n\n\n\nfunction checkAge(age) &#123;\n  let min &#x3D; 18\n  return age &gt;&#x3D; min\n&#125;\n\n&#x2F;&#x2F; 普通纯函数\nfunction checkAge(min, age) &#123;\n  return age &gt;&#x3D; min\n&#125;\n\n&#x2F;&#x2F; 柯里化，函数闭包\nfunction checkAge(min) &#123;\n  return function (age) &#123;\n    return age &gt;&#x3D; min\n  &#125;\n&#125;\n\n&#x2F;&#x2F; ES6 写法\nconst checkAge &#x3D; min &#x3D;&gt; age &#x3D;&gt; age &gt;&#x3D; min\n\nconst checkAge18 &#x3D; checkAge(18)\nconst checkAge22 &#x3D; checkAge(22)\n\ncheckAge18(20)\ncheckAge22(20)\n\nlodash 中的柯里化函数\n_.curry(func)\n功能：创建一个函数，该函数接受一个或者多个 func 的参数，如果 func 所需要的参数都被提供 则执行 func并返回执行的结果。否则继续返回该函数并等待接受剩余的参数。\n参数：需要柯里化的函数\n返回值：柯里化后的函数\n\nconst _ &#x3D; require(&#39;lodash&#39;)\n\n&#x2F;&#x2F; 需要柯里化的函数\nfunction getSum(a, b, c) &#123;\n  return a + b + c\n&#125;\n\n&#x2F;&#x2F; 柯里化后的函数\nconst curried &#x3D; _.curry(getSum)\n\n&#x2F;&#x2F; 多种使用方式\ncurried(1, 2, 3)\ncurried(1, 2)(3)\ncurried(1)(2, 3)\ncurried(1)(2)(3)\n\n\n案例\n\n查找字符数组中带有空格的项\nconst _ &#x3D; require(&#39;lodash&#39;)\n\n&#x2F;&#x2F; 柯里化后的函数\nconst match &#x3D; _.curry(function (reg, str) &#123;\n  return str.match(reg)\n&#125;)\n\n&#x2F;&#x2F; 接受了一个参数\nconst haveSpace &#x3D; match(&#x2F;\\s+&#x2F;g)\nconst haveNumber &#x3D; match(&#x2F;\\d+&#x2F;g)\n\n&#x2F;&#x2F; 传入剩余参数\nconsole.log(haveSpace(&#39;hello world&#39;))\nconsole.log(haveNumber(&#39;23$&#39;))\n\n&#x2F;&#x2F; 柯里化后的函数\nconst filter &#x3D; _.curry(function (func, arr) &#123;\n  return arr.filter(func)\n&#125;)\n\n&#x2F;&#x2F; 传入全部的参数\nconsole.log(filter(haveSpace, [&#39;Hello World&#39;, &#39;hello_wordl&#39;]))\n\n&#x2F;&#x2F; 传入一个参数\nconst findSpace &#x3D; filter(haveSpace)\n\n&#x2F;&#x2F; 传入剩余的参数\nconsole.log(findSpace([&#39;hello world&#39;, &#39;hello_world&#39;]))\n\n\n模拟 _.curry() 的实现\n\n\n&#x2F;&#x2F; 参数为需要柯里化的函数\nfunction curry(fn) &#123;\n\n  &#x2F;&#x2F; 返回的函数需要接受剩余的参数\n  return function curryFn(...args) &#123;\n\n    &#x2F;&#x2F; 如果传入的参数和函数的参数长度不一致\n    if (fn.length &gt; args.length) &#123;\n\n      &#x2F;&#x2F; 继续返回一个函数，多次柯里化\n      return function () &#123;\n\n        &#x2F;&#x2F; 将闭包中的 args 和传入的参数合并，arguments\n        return curryFn(...args.concat(Array.from(arguments)))\n      &#125;\n    &#125;\n\n    &#x2F;&#x2F; 返回执行后的值\n    return fn(...args)\n  &#125;\n&#125;\n\n总结\n柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数\n这是一种对函数参数的缓存\n让函数变得更灵活，让函数的粒度更小\n可以把多元函数转为一元函数，可以组合使用函数产生强大的功能（一个参数的函数成为一元函数，类似数学的函数）\n\n函数组合\n纯函数和柯里化很容易写出洋葱代码h(g(f(x)))\n获取数组的最后一个元素再转成大写字母，_.toUpper(_.first(_.reverse(arr)))\n\n\n\n\n\n\n函数组合可以让我们把细粒度的函数重新组合生成一个新的函数\n\n管道下面这张图表示程序中使用函数处理数据的过程，给 fn 函数输入参数 a，返回结果 b。可以想想 a 数据 通过一个管道得到了 b 数据。\n\n当 fn 函数比较复杂的时候，我们可以把函数 fn 拆分成多个小函数，此时多了中间运算过程产生的 m 和 n。\n下面这张图中可以想象成把 fn 这个管道拆分成了3个管道 f1, f2, f3，数据 a 通过管道 f3 得到结果 m，m 再通过管道 f2 得到结果 n，n通过管道 f1 得到最终结果 b\n\nfn &#x3D; compose(f1, f2, f3)\nresult &#x3D; fn(value)\n\n函数组合\n函数组合(compose)：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间的过程的 函数合并成一个函数\n函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果\n函数组合默认是从右到左执行\n\n\n\n&#x2F;&#x2F; 基本函数组合\nfunction compose(f, g) &#123;\n  return function (x) &#123;\n    return f(g(x))\n  &#125;\n&#125;\n\nfunction first(arr) &#123;\n  return arr[0]\n&#125;\n\nfunction reverse(arr) &#123;\n  return arr.reverse()\n&#125;\n\nconst last &#x3D; compose(first, reverse)\n\nconsole.log(last([1, 2, 3, 4]))\n\n\nlodash 中的组合函数\nlodash 中阻焊函数 flow() 从左到右或者 flowRight() 从右到左\n\nconst _ &#x3D; require(&#39;lodash&#39;)\n\nconst toUpper &#x3D; s &#x3D;&gt; s.toUpperCase()\nconst reverse &#x3D; arr &#x3D;&gt; arr.reverse()\nconst first &#x3D; arr &#x3D;&gt; arr[0]\n\n&#x2F;&#x2F; 获取数组最后一个值，并转为大写\nconst f &#x3D; _.flowRight(toUpper, first, reverse)\nconsole.log(f([&#39;one&#39;, &#39;tow&#39;, &#39;three&#39;]))\n\n\n模拟 lodash 的 flowRight 方法\n\n&#x2F;&#x2F; 接受多个函数\nfunction compose(...fns) &#123;\n  &#x2F;&#x2F; 传入的值\n  return function (value) &#123;\n    &#x2F;&#x2F; 使用 reverse 将函数从右到左执行，使用 reduce 把执行结果进行累加\n    return fns.reverse().reduce(function (acc, fn) &#123;\n      return fn(acc)\n      &#x2F;&#x2F; 累加初始值为 value\n    &#125;, value)\n  &#125;\n&#125;\n\n&#x2F;&#x2F; ES6 写法\nconst compose &#x3D; (...fns) &#x3D;&gt; value &#x3D;&gt; fns.reverse().reduce((acc, fn) &#x3D;&gt; fn(acc), value)\n\n\n函数的组合要满足结合律（associativity）:\n可以把 g 和 h 组合，还可以把 f 和 g组合，结果都是一样的\n\n\n\n&#x2F;&#x2F; 结合律\nconst fn &#x3D; compose(f, g, h)\n\nconst fnAssociative &#x3D; compose(compose(f, g), h) &#x3D;&#x3D;&#x3D; compose(f, compose(g, h))\n\n\n所以代码可以这样结合\n\nconst _ &#x3D; require(&#39;lodash&#39;)\n\nconst f &#x3D; _.flowRight(_.toUpper, _.first, _.reverse)\nconst f &#x3D; _.flowRight(_.flowRight(_.toUpper, _.first), _.reverse)\nconst f &#x3D; _.flowRight(_.toUpper, _.flowRight(_.first, _.reverse))\nconsole.log(f([&#39;one&#39;, &#39;tow&#39;, &#39;three&#39;])) &#x2F;&#x2F; THREE\n\n函数组合打印日志const _ &#x3D; require(&#39;lodash&#39;)\n\nconst trace &#x3D; _.curry((tag, value) &#x3D;&gt; &#123;\n  console.log(value, tag)\n  return value\n&#125;)\n\n&#x2F;&#x2F; 使用柯里化，使得函数可以传递部分参数，加上函数组合为更强大的函数\n&#x2F;&#x2F; lodash 模块都是值在前，fn 在后的形式\nconst split &#x3D; _.curry((sep, str) &#x3D;&gt; _.split(str, sep))\nconst join &#x3D; _.curry((sep, arr) &#x3D;&gt; _.join(arr, sep))\nconst map &#x3D; _.curry((fn, arr) &#x3D;&gt; _.map(arr, fn))\n\nconst f &#x3D; _.flowRight(join(&#39;-&#39;), trace(&#39;map&#39;), map(_.toLower), trace(&#39;split&#39;), split(&#39; &#39;))\nconsole.log(f(&#39;NEVER SAY DIE&#39;)) &#x2F;&#x2F; never-say-die\n\n\nlodash/fp\nlodash 的 fp 模块提供了实用的对函数式编程友好的方法\n提供了不可变 auto-curried iteratee-first data-last 的方法\n\n\n\nconst _ &#x3D; require(&#39;lodash&#39;)\n_.map([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], _.toUpper)\n&#x2F;&#x2F; &#x3D;&gt; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]\n_.map([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])\n&#x2F;&#x2F; &#x3D;&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n\n_.split(&#39;hello world&#39;, &#39; &#39;)\n\nconst fp &#x3D; require(&#39;lodash&#x2F;fp&#39;)\n\n&#x2F;&#x2F; fp 模块下的函数都是柯里化后的函数\n&#x2F;&#x2F; 可以传递部分参数生成一个新的函数\n&#x2F;&#x2F; 获取全部参数可以得到返回结果\n&#x2F;&#x2F; 全部参数\nfp.map(fp.toUpper, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])\n&#x2F;&#x2F; 部分参数，生成了一个新的函数，再次调用\nfp.map(fp.toUpper)([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])\nfp.split(&#39; &#39;, &#39;hello world&#39;)\nfp.split(&#39; &#39;)(&#39;hello world&#39;)\n\nconst f &#x3D; fp.flowRight(fp.join(&#39;-&#39;), fp.map(fp.toLower), fp.split(&#39; &#39;))\nconsole.log(f(&#39;NEVER SAY DIE&#39;))\n\nPoint Free ProgrammingPoint Free: 可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。\n\n不需要知名处理的数据\n只需要合成运算的过程\n需要定义一些辅助的基本运算函数\n\nconst f &#x3D; fp.flowRight(fp.join(&#39;-&#39;), fp.map(fp.toLower), fp.split(&#39; &#39;))\n\n\n案例演示\n\n&#x2F;&#x2F; 非 Point Free 模式\n&#x2F;&#x2F; Hello World &#x3D;&gt; hello_world\nfunction f(word) &#123;\n  return word.toLowerCase().replace(&#x2F;\\s_&#x2F;g, &#39;_&#39;)\n&#125;\n\n&#x2F;&#x2F; Point Free\nconst fp &#x3D; require(&#39;lodash&#x2F;fp&#39;)\n\n&#x2F;&#x2F; 合成运算\nconst f &#x3D; fp.flowRight(fp.replace(&#x2F;\\s+&#x2F;g, &#39;_&#39;), fp.toLower)\n\nconsole.log(f(&#39;Hello World&#39;))\n\nFunctor(函子)why需要把函数式编程中的副作用控制在可控的范围内、异常处理和异步操作等。\nwhat\n容器：包含值和值的变形关系（这个变形关系就是函数）\n函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以运行一个 函数对值进行处理（变形关系）\n\nFunctor 函子&#x2F;&#x2F; 一个容器，包裹一个值\nclass Container &#123;\n  constructor(value) &#123;\n    this._value &#x3D; value\n  &#125;\n\n  &#x2F;&#x2F; 静态方法，可以屏蔽 new 关键字创建对象\n  static of(value) &#123;\n    return new Container(value)\n  &#125;\n\n  &#x2F;&#x2F; map 方法，传入变形关系，将容器里的值映射到另外一个容器\n  map(fn) &#123;\n    return new Container(fn(this._value))\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 链式调用\nContainer.of(3)\n  .map(v &#x3D;&gt; v + 1)\n  .map(v &#x3D;&gt; v ** 2)\n\n\n函数式编程的运算不直接操作值，而是由函子完成\n函子就是一个实现了 map 契约的对象\n可以把函子想象成一个盒子，这个盒子里封装了一个值\n想要处理盒子中的值，需要给盒子的 map 方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理\n最后 map 方法返回一个包含新值的盒子（函子）\n\n如果 Functor 中传入 null 或者 undefined\n&#x2F;&#x2F; 如果传入 null， 会报错\nContainer.of(null)\n  .map(x &#x3D;&gt; x.toUpperCase())\n&#x2F;&#x2F; TypeError: Cannot read property &#39;toUpperCase&#39; of null\n\nMayBe 函子\n编程的过程中可能会遇到很多错误，需要对这些错误做响应的处理\nMayBe 函子的作用就是可以对外部的控制情况做处理（控制副作用在允许的范围）\n\n&#x2F;&#x2F; 基本结果和上面一样\nclass MayBe &#123;\n  constructor(value) &#123;\n    this._value &#x3D; value\n  &#125;\n\n  static of(value) &#123;\n    return new MayBe(value)\n  &#125;\n\n  map(fn) &#123;\n    &#x2F;&#x2F; 新增对 _value 值的判断，判断不通过则返回 null\n    return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this._value))\n  &#125;\n\n  &#x2F;&#x2F; 新增对值的判断\n  isNothing() &#123;\n    return this._value &#x3D;&#x3D;&#x3D; null || this._value &#x3D;&#x3D;&#x3D; undefined\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 传入具体值 \nMayBe.of(&#39;Hello World&#39;)\n  .map(x &#x3D;&gt; x.toUpperCase())\n&#x2F;&#x2F; 传入 null 的情况 \nMayBe.of(null)\n  .map(x &#x3D;&gt; x.toUpperCase())\n&#x2F;&#x2F; &#x3D;&gt; MayBe &#123; _value: null &#125;\n\n\n在 MayBe 函子中，很难确定在哪一步产生的空值问题，如下：\n\nMayBe.of(&#39;hello&#39;)\n  .map(v &#x3D;&gt; v.toUpperCase())\n  .map(v &#x3D;&gt; null)\n  .map(v &#x3D;&gt; x.split(&#39; &#39;))\n&#x2F;&#x2F; &#x3D;&gt; MayBe &#123; _value: null &#125;\n\nEither 函子\nEither 两者中的任务一个，类似于 if … else … 的处理\n异常会让函数变得不纯， Either 函子可以用来做异常处理\n\nclass Left &#123;\n  constructor(value) &#123;\n    this._value &#x3D; value\n  &#125;\n\n  static of(value) &#123;\n    return new Left(value)\n  &#125;\n\n  map(fn) &#123;\n\n    &#x2F;&#x2F; Left 处理异常信息，不对值进行改变\n    return this\n  &#125;\n&#125;\n\nclass Right &#123;\n  constructor(value) &#123;\n    this._value &#x3D; value\n  &#125;\n\n  static of(value) &#123;\n    return new Right(value)\n  &#125;\n\n  map(fn) &#123;\n    return Right.of(fn(this._value))\n  &#125;\n&#125;\n\n\nEither 用来处理异常\n\nfunction parseJSON(str) &#123;\n  try &#123;\n    return Right.of(JSON.parse(str))\n  &#125; catch (e) &#123;\n    &#x2F;&#x2F; 异常会让函数不纯，使用 Left 来统一获取异常消息\n    return Left.of(&#123;error: e.message&#125;)\n  &#125;\n&#125;\n\nconst result &#x3D; parseJSON(&#39;&#123;&quot;age&quot;: 1&#125;&#39;).map(x &#x3D;&gt; x &gt;&#x3D; 18)\nconsole.log(result)\n\nIO 函子\nIO 函子中的 _value 是一个函数，这里把函数作为值来处理\nIO 函子可以把不纯的动作存储到 _value 中，延迟这个不纯的操作（惰性执行），保证当前的操作纯\n把不纯的操作交给调用者来处理\n\nconst fp &#x3D; require(&#39;lodash&#x2F;fp&#39;)\n\nclass IO &#123;\n\n  &#x2F;&#x2F; 构造函数传入一个函数\n  constructor(fn) &#123;\n    this._value &#x3D; fn\n  &#125;\n\n  static of(value) &#123;\n    return new IO(function () &#123;\n      return value\n    &#125;)\n  &#125;\n\n  map(fn) &#123;\n    &#x2F;&#x2F; 把当前的 _value 和传入的 fn 组合成一个新的函数\n    return new IO(fp.flowRight(fn, this._value))\n  &#125;\n&#125;\n\nconst io &#x3D; IO.of(process).map(p &#x3D;&gt; p.execPath)\nconsole.log(io._value())\n\nTask 异步执行\nfolktale(2.3.2)\n\nconst &#123;task&#125; &#x3D; require(&#39;folktale&#x2F;concurrency&#x2F;task&#39;)\n\n&#x2F;&#x2F; 类似后面的 Promise\nfunction readFile(filename) &#123;\n  return task(resolver &#x3D;&gt; &#123;\n    fs.readFile(filename, &#39;utf-8&#39;, (err, data) &#x3D;&gt; &#123;\n      if (err) &#123;\n        resolver.reject(err)\n      &#125;\n      resolver.resolve(data)\n    &#125;)\n  &#125;)\n&#125;\n\n&#x2F;&#x2F; 调用 run 执行\nreadFile(&#39;..&#x2F;package.json&#39;)\n  .map(split(&#39;\\n&#39;))\n  .map(find(x &#x3D;&gt; x.includes(&#39;version&#39;)))\n  .run()\n  .listen(&#123;\n    onRejected: err &#x3D;&gt; &#123;\n      console.log(err)\n    &#125;,\n    onResolved: value &#x3D;&gt; &#123;\n      console.log(value)\n    &#125;\n  &#125;)\n\nPointed 函子\nPointed 函子是实现了 of 静态方法的函子\nof 方法是为了避免使用 new 来创建对象，更深层次的含义是 of 方法用来把值放到上下文 Context （把值放到容器中，使用 map 来处理值）\n\n\nclass Container &#123;\n  static of(value) &#123;\n    return new Container(value)\n  &#125;\n\n&#x2F;&#x2F; ...\n&#125;\n\nContainer.of(2).map(x &#x3D;&gt; x + 5)\n\nMonad (单子)在使用 IO 函子的时候，如果写出如下代码：\nconst fs &#x3D; require(&#39;fs&#39;)\nconst fp &#x3D; require(&#39;lodash&#x2F;fp&#39;)\nconst readFile &#x3D; function (filename) &#123;\n  return new IO(() &#x3D;&gt; &#123;\n    return fs.readFileSync(filename, &#39;utf-8&#39;)\n  &#125;)\n&#125;\n\nconst print &#x3D; function (value) &#123;\n  return new IO(() &#x3D;&gt; &#123;\n    console.log(value)\n    return value\n  &#125;)\n&#125;\n\nconst cat &#x3D; fp.flowRight(print, readFile)\nconst r &#x3D; cat(&#39;..&#x2F;package.json&#39;)._value()._value()\nconsole.log(r)\n\n\nMonad 函子是可以变扁的 Pointed 函子， IO(IO(x))\n一个函子如果具有 join 和 of 两个方法并遵守一些定律就是一个 Monad\n\nconst fp &#x3D; require(&#39;lodash&#x2F;fp&#39;)\n\nclass IO &#123;\n  constructor(fn) &#123;\n    this._value &#x3D; fn\n  &#125;\n\n  static of(value) &#123;\n    return new IO(() &#x3D;&gt; &#123;\n      return value\n    &#125;)\n  &#125;\n\n  map(fn) &#123;\n    return new IO(fp.flowRight(fn, this._value))\n  &#125;\n\n  join() &#123;\n    return this._value()\n  &#125;\n\n  flatMap(fn) &#123;\n    return this.map(fn).join()\n  &#125;\n&#125;\n\nconst r &#x3D; readFile(&#39;..&#x2F;package.json&#39;)\n  .map(fp.toUpper)\n  .flatMap(print)\n  .join()\n","slug":"functionalProgramming","date":"2021-12-10T03:00:00.000Z","categories_index":"JavaScript","tags_index":"JAVASCRIPT","author_index":"SKY"},{"id":"6a10bf4989cdd89dde18ea8bad304bb7","title":"Deploy K8S","content":"三节点 k8s 部署1：机器准备这里我们准备三台虚拟机，一台master，二台node\n机器准备教程 ubuntu 搭建 kvm 安装虚拟机\n\n2：安装前的环境确认所有机器都需要执行：\n\na：三台机器都可以联网，uname -a查看内核是否大于等于3.1\n\nb：关闭三台机器的防火墙\n\n\nsystemctl stop firewalld\n\nsystemctl disable firewalld\n\n\nc：关闭selinux\n\nsed -i &#39;s&#x2F;enforcing&#x2F;disabled&#x2F;&#39; &#x2F;etc&#x2F;selinux&#x2F;config\n\n\nd：关闭swap\n\nswapoff -a\n\nvi &#x2F;etc&#x2F;fstab\n\n# 注释这一行：&#x2F;mnt&#x2F;swap swap swap defaults 0 0\n# 或者 &#x2F;dev&#x2F;mapper&#x2F;centos-swap swap swap defaults 0 0\n# 查看swap是否全为0\n\nfree -m\n              total        used        free      shared  buff&#x2F;cache   available\nMem:           3789         769        2123           9         895        2785\nSwap:             0           0           0\n\n\ne：配置三台机器的主机名,分别在三台机器上执行命令\n\n10.100.0.131上执行：hostnamectl set-hostname k8smaster\n10.100.0.196上执行：hostnamectl set-hostname k8snode1\n10.100.0.245上执行：hostnamectl set-hostname k8snode2\n\nf：在master的机器上添加hosts，在10.100.0.131上执行命令\n\ncat &gt;&gt; &#x2F;etc&#x2F;hosts &lt;&lt; EOF\n\n10.100.0.131 k8smaster\n\n10.100.0.196 k8snode1\n\n10.100.0.245 k8snode2\n\nEOF\n\n\ng：将桥接的IPV4流量传递到iptables的链，三台机器都执行命令\n\ncat &gt; &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf &lt;&lt; EOF\n\nnet.bridge.bridge-nf-call-ip6tables &#x3D; 1\n\nnet.bridge.bridge-nf-call-iptables &#x3D; 1\n\nEOF\n\n\nh：所有节点执行命令，生效\n\nsysctl --system\n\n\ni：同步每个服务器的时间和时区\n\n\nyum install ntpdate -y\n\nntpdate time.windows.com\n\ncp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime\n\n3：三台机器全部安装docker所有机器都需安装\n3.1：配置阿里云的镜像jswget\nhttp:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo -O &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo\n\n3.2：刷新yum源yum clean all\n\nyum makecache\n\nyum -y update\n\n3.3：安装dockeryum -y install docker-ce-18.06.1.ce-3.el7\n\n# 如果之前机器上有安装过，先删除，执行\nyum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-selinux docker-engine-selinux docker-engine\n\n3.4：启动docker,并设为开机自启动systemctl enable docker &amp;&amp; systemctl start docker\n\n4：配置kubeadm,kubelet,kubectl镜像所有机器都需要：\nkubelet：运行在集群所有节点上,负责启动POD和容器\nkubeadm：用于初始化集群\nkubectl：kubenetes命令行工具，通过kubectl可以部署和管理应用，查看各种资源，创建，删除和更新组件\n4.1：创建yum源的文件cat &gt; kubernetes.repo &lt;&lt; EOF\n\n[kubernetes]\n\nname&#x3D;Kubernetes\n\nbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-x86_64\n\nenabled&#x3D;1\n\ngpgcheck&#x3D;1\n\nrepo_gpgcheck&#x3D;1\n\ngpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg\n\nEOF\n\n4.2：将文件移到yum的目录mv kubernetes.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;\n\n5：安装kubeadm,kubelet,kubectl所有机器都需要：\nyum install -y kubelet-1.17.0 kubeadm-1.17.0 kubectl-1.17.0\n\nsystemctl enable kubelet\n\n6：初始化kubeadm(只在master机器上)只执行master机器10.100.0.131：\nkubeadm init \\\n\n--apiserver-advertise-address&#x3D;10.100.0.131 \\\n\n--image-repository registry.aliyuncs.com&#x2F;google_containers \\\n\n--kubernetes-version v1.17.0 \\\n\n--service-cidr&#x3D;10.96.0.0&#x2F;12 \\\n\n--pod-network-cidr&#x3D;10.244.0.0&#x2F;16\n\n7：将k8s生成的管理员连接k8s集群的配置文件考到它默认的工作目录只执行master机器10.100.0.131：\n这样就可以通过kubectl连接k8s集群了，执行命令：\nmkdir -p $HOME&#x2F;.kube\n\nsudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config\n\nsudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config\n\n# 测试：\n\nkubectl get node\n\n8：安装pod网络插件CNI\n只执行master机器10.100.0.131：\nkubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml\n\n装好之后执行\nkubectl get pods -n kube-system\n\n等待所有组件状态都为：Running\n9：将节点加入集群中9.1：执行命令（在master机器上）kubeadm token list # 查看现在有的token\n\nkubeadm token create # 生成一个新的token\n\nkubeadm token create --ttl 0 # 生成一个永远不过期的token\n\n9.2：获取ca证书sha256编码hash值（在master机器上运行）openssl x509 -pubkey -in &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.crt | openssl rsa -pubin -outform der 2&gt;&#x2F;dev&#x2F;null | openssl dgst -sha256 -hex | sed &#39;s&#x2F;^.* &#x2F;&#x2F;&#39;\n\n9.3：加入节点（在要加入的机器上）&lt;&gt;里面的内容替换掉，包括括号\nkubeadm join master机器Ip:6443 --token &lt;9.1步查到没过期的token&gt; --discovery-token-ca-cert-hash sha256:&lt;9.2中获取的字符串&gt;\n\n9.4：在master机器上执行命令，查看现在的节点情况kubectl get nodes\n\n可以看到，刚才加入的二个节点状态是NotReady,是因为它的网络还没有准备好,过几分钟再看，就会变成Read状态\n10：部署K8s的管理页面Dashboard10.1：在master中执行下列命令：kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v2.0.0-beta8&#x2F;aio&#x2F;deploy&#x2F;recommended.yaml\n\n10.2：默认Dashboard只能集群内部访问，需要修改service为nodePort类型，暴露到外部，执行命令将配置文件下载下来\nwget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v2.0.0-beta8&#x2F;aio&#x2F;deploy&#x2F;recommended.yaml\n\n10.3：修改这个文件vim recommended.yaml\n\n找到这段，增加红包部分，冒号后面有一个空格，千万要注意\nspec:\n  # 添加 type\n  type: NodePort\n  ports:\n    - port: 443\n      targetPort: 8443\n      # 添加nodePort，可以自定义\n      nodePort: 30001\n  selector:\n    k8s-app: kubernetes-dashboard\n\n10.4：重新加载运行配置文件kubectl apply -f recommended.yaml\n\n11：访问k8s管理页面https://master机器ip:30001\n注意：这里必须是https的方式，如果谷哥浏览器不能访问，谷哥有的版本没有添加信任的地方，无法访问，可使用firefox或者其它浏览器。\n12：创建默认service account并绑定默认cluster-admin管理员集群角色12.1：在master机器上执行命令：kubectl create serviceaccount dashboard-admin -n kube-system\n\nkubectl create clusterrolebinding dashboard-admin --clusterrole&#x3D;cluster-admin --serviceaccount&#x3D;kube-system:dashboard-admin\n\nkubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk &#39;&#x2F;dashboard-admin&#x2F;&#123;print $1&#125;&#39;)\n\n12.2：将生成的token复制到页面就可以登陆了注意事项注意一如果虚拟机重启，把第2点（安装前环境确认）中的 a，b，c，d 重新执行一遍，k8s集群会自动重启\nsystemctl stop firewalld\nsystemctl disable firewalld\nsed -i &#39;s&#x2F;enforcing&#x2F;disabled&#x2F;&#39; &#x2F;etc&#x2F;selinux&#x2F;config\nswapoff -a\nsysctl --system\nntpdate time.windows.com\ncp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime\n\n注意二Dashboard 在 Safari 无法打开，FireFox 可以打开。\nChrome 需要界面输入 thisisunsafe ，回车后可以强制打开。\n","slug":"k8s","date":"2021-11-28T15:00:00.000Z","categories_index":"教程","tags_index":"K8S","author_index":"SKY"},{"id":"d151387cde5693b6d054d4b81d0393bc","title":"ubuntu20.04搭建kvm_bridge网桥教程","content":"前提主机配置如下：\n\n电脑为笔记本\n\n处理器 intel i5-6300 HQ 2.30GHz * 4\n\n内存 16G\n\n硬盘 500G 固态\n\n系统 Ubuntu 20.04.3 LTS 64-bit\n\n\n检查检查CPU是否支持虚拟化$ grep -Eoc &#39;(vmx|svm)&#39; &#x2F;proc&#x2F;cpuinfo\n\n# 输出大于 0 即可\n8\n\n输出结果大于0表示支持虚拟化\n检查主板是否开启虚拟化$ sudo apt update &amp;&amp; sudo apt install cpu-checker -y\n$ kvm-ok\n\n# 以下输出结果可用\nINFO: &#x2F;dev&#x2F;kvm exists\nKVM acceleration can be used\n\n安装KVM套件安装相关包sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager -y\n\nqemu-kvm: 提供硬件底层虚拟化。libvirt-daemon-system: 为 libvirt作为系统服务的守护程序运行。libvirt-clients: 为不同的虚拟机提供长期稳定的C APIbridge-utils:提供网络桥接功能virtinst: 为libvirt创建虚拟机提供一系列的命令行工作virt-manager: KVM虚拟机管理图形界面，如果服务器没有安装图形化界面，没有必要安装它。\n检查 libvirtd$ sudo systemctl is-active libvirtd\n\n# 输出以下结果表示可用\nactive\n\n将当前用户加入到 libvirt 和 kvm 用户组USER 为当前用户\nsudo usermod -aG libvirt USER\nsudo usermod -aG kvm USER\n\n配置网桥\nsudo vim /etc/sysctl.d/bridge.conf\n\n内容如下：\nnet.bridge.bridge-nf-call-ip6tables&#x3D;0\nnet.bridge.bridge-nf-call-iptables&#x3D;0\nnet.bridge.bridge-nf-call-arptables&#x3D;0\n\n\nsudo vim /etc/udev/rules.d/99-bridge.rules\n\n内容如下：\nACTION&#x3D;&#x3D;&quot;add&quot;, SUBSYSTEM&#x3D;&#x3D;&quot;module&quot;, KERNEL&#x3D;&#x3D;&quot;br_netfilter&quot;, \\           RUN+&#x3D;&quot;&#x2F;sbin&#x2F;sysctl -p &#x2F;etc&#x2F;sysctl.d&#x2F;bridge.conf&quot;\n\n\nip link\n\nKVM 安装后，会有默认创建的接口，需要删除\n查看接口\n$ ip link\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\n    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000\n    link&#x2F;ether d4:be:d9:f3:1e:5f brd ff:ff:ff:ff:ff:ff\n6: virbr0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000\n    link&#x2F;ether 52:54:00:1d:5b:25 brd ff:ff:ff:ff:ff:ff\n7: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc fq_codel master virbr0 state DOWN mode DEFAULT group default qlen 1000\n    link&#x2F;ether 52:54:00:1d:5b:25 brd ff:ff:ff:ff:ff:ff\n\n删除默认的网口\n$ sudo virsh net-destroy default\n$ sudo virsh net-undefine default\n\n再次查看\n$ ip link\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\n    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000\n    link&#x2F;ether d4:be:d9:f3:1e:5f brd ff:ff:ff:ff:ff:ff\n\n如果还有，则需要手动删除\n$ ip link delete virbr0 type brigde \n$ ip link delete virbr0-nic\n\n\nsudo vim /etc/netplan/00-installer-config.yaml\n\n内容如下：\nnetwork:\n  ethernets:\n    eno1:\n      dhcp4: false\n      dhcp6: false\n  bridges:\n    br0:\n      interfaces: [ eno1 ]\n      addresses: [ 192.168.0.100&#x2F;24 ]\n      gateway4: 192.168.0.1\n      mtu: 1500\n      nameservers:\n        addresses: [ 8.8.8.8,8.8.4.4 ]\n      parameters:\n        stp: true\n        forward-delay: 4\n      dhcp4: no\n      dhcp6: no\n  version: 2\n\n注意自行更换：\neno1： 为笔记本有线网卡的网卡名，不能使用无线网卡\naddresses：里面的ip为可局域网中的真实 ip 地址和掩码\ngateway4：网关为局域网中的网关\n\nsudo netplan apply\n\n执行后则 br0 网桥就会被创建成功\n$ ip link\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\n    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel master br0 state UP mode DEFAULT group default qlen 1000\n    link&#x2F;ether c8:d3:ff:dd:74:f1 brd ff:ff:ff:ff:ff:ff\n    altname enp9s0\n3: wlo1: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000\n    link&#x2F;ether c8:21:58:17:5a:bb brd ff:ff:ff:ff:ff:ff\n    altname wlp8s0\n4: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000\n    link&#x2F;ether c8:d3:ff:dd:74:f1 brd ff:ff:ff:ff:ff:ff\n\n\nvim host-bridge.xml\n\n创建kvm网桥配置文件\n\n&lt;network&gt;\n    &lt;name&gt;host-bridge&lt;&#x2F;name&gt;\n    &lt;forward mode&#x3D;&quot;bridge&quot;&#x2F;&gt;\n    &lt;bridge name&#x3D;&quot;br0&quot;&#x2F;&gt;\n&lt;&#x2F;network&gt;\n\n\n创建 kvm 的网桥\n\n$ sudo virsh net-define host-bridge.xml\n$ sudo virsh net-start host-bridge\n$ sudo virsh net-autostart host-bridge\n\n\n查看是否创建成功\n\n$ virsh net-list --all\n Name          State    Autostart   Persistent\n------------------------------------------------\n host-bridge   active   yes         yes\n\n创建虚拟机sudo virt-install --name&#x3D;centos7_2003 --ram&#x3D;4096 --vcpus&#x3D;2 --virt-type&#x3D;kvm --os-type&#x3D;linux --os-variant&#x3D;centos7.0 --network default,model&#x3D;virtio --graphics&#x3D;vnc,password&#x3D;123123,port&#x3D;5911,listen&#x3D;0.0.0.0 --noautoconsole --accelerate --cdrom&#x3D;&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images&#x2F;CentOS-7-x86_64-Minimal-2003.iso --disk path&#x3D;&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images&#x2F;CentOS7.qcow2,device&#x3D;disk,format&#x3D;qcow2,bus&#x3D;virtio,cache&#x3D;writeback,size&#x3D;40\n\n可自行修改：\n--name=centos7_2003 为虚拟机名字\n--ram=4096 为虚拟机内存\n--vcpus=2 为cpu核数\npassword=123123 为访问虚拟机界面时需要的密码（可以删除掉）\n-cdrom=/var/lib/libvirt/images/CentOS-7-x86_64-Minimal-2003.iso为镜像路径，自行下载 阿里云centos7\n-disk path=/var/lib/libvirt/images/CentOS7.qcow2 disk存放路径\nsize=40 磁盘大小\n检查是否运行成功\n$ virsh list --all\n Id   Name           State\n------------------------------\n 1    centos7_2003   running\n\n配置虚拟机静态 ip$ vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0\n\n# 内容如下\nTYPE&#x3D;Ethernet\nPROXY_METHOD&#x3D;none\nBROWSER_ONLY&#x3D;no\nBOOTPROTO&#x3D;static # 需要改为 static\nDEFROUTE&#x3D;yes\nIPV4_FAILURE_FATAL&#x3D;no\nIPV6INIT&#x3D;yes\nIPV6_AUTOCONF&#x3D;yes\nIPV6_DEFROUTE&#x3D;yes\nIPV6_FAILURE_FATAL&#x3D;no\nIPV6_ADDR_GEN_MODE&#x3D;stable-privacy\nNAME&#x3D;eth0\nUUID&#x3D;c45492fe-bc6f-40f4-a799-e620660c5b61\nDEVICE&#x3D;eth0\nONBOOT&#x3D;yes # 需要改为 yes\n\nIPADDR&#x3D;192.168.0.100 # 和 br0 相同网络下的 ip\nMETMASK&#x3D;255.255.255.0 # 和 br0 相同的掩码\nDNS1&#x3D;114.114.114.114\nGATEWAY&#x3D;192.168.0.1 # 和 br0 相同的网关\nIPV6_PEERNDS&#x3D;yes\nIPV6_PEEROUTES&#x3D;yes\nIPV6_PRIVACY&#x3D;no\n# 内容结束\n\n查看是否连通\n#重启网络\n$ systemctl restart NetworkManager\n\n# 查看网络是否连通\n$ ping 114.114.114.114\nPING 114.114.114.114 (114.114.114.114) 56(84) bytes of data.\n64 bytes from 114.114.114.114: icmp_seq&#x3D;1 ttl&#x3D;94 time&#x3D;39.9 ms\n64 bytes from 114.114.114.114: icmp_seq&#x3D;2 ttl&#x3D;68 time&#x3D;39.7 ms\n$ ping www.baidu.com\nPING www.a.shifen.com (220.181.38.149) 56(84) bytes of data.\n64 bytes from 220.181.38.149 (220.181.38.149): icmp_seq&#x3D;1 ttl&#x3D;52 time&#x3D;43.6 ms\n64 bytes from 220.181.38.149 (220.181.38.149): icmp_seq&#x3D;2 ttl&#x3D;52 time&#x3D;43.7 ms\n\n总结宿主机重启后，所有相关网络都会自动创建，亲测有效\nkvm搭建\n网桥搭建，国外网站，不一定都能打开\n下一节搭建 k8s 集群\n","slug":"ubuntuKvmBridge","date":"2021-11-10T16:00:00.000Z","categories_index":"教程","tags_index":"UBUNTU,KVM,LINUX-BRIDGE","author_index":"SKY"},{"id":"f61a453c54e3d0e4c60345e60cadb326","title":"格式化表格","content":"格式化Markdown 表格这是一个可以对 Markdown 里面表格进行格式化的一个工具，还支持对多级文件和多个目录里面的内容同时格式化\n格式化Markdown表格\n内容展示\n原本内容\n\n## 标题\n\n| 姓名 | 电话 | 邮箱 |\n| --- | :---: | ---: |\n| 王顶 | 13582027613 | 408542507@qq.com |\n| 郭玉朝 | 13812347652 | baldy@163.com |\n|  | abc | def\n\n\n格式化后内容\n\n## 标题\n\n| 姓名   |     电话     |              邮箱 |\n|-------|:-----------:|-----------------:|\n| 王顶   | 13582027613 | 408542507@qq.com |\n| 郭玉朝 | 13812347652 |    baldy@163.com |\n|       |     abc     |              def |\n\n终端使用方法npm i @skyfury&#x2F;reformat-markdown-cn -g\n\nreformat-markdown-cn -h\n\nUsage: reformat-markdown-cn [options] &lt;files|directories|globs&gt;\n\nOptions:\n  -V, --version          output the version number\n  -R, --reformat [type]  check another rules and reformat markdown table, (default: &#123;&quot;0&quot;: 0, &quot;1&quot;: 2, &quot;2&quot;: 3, &quot;3&quot;: 5&#125;)\n  -C, --cat              only cat format markdown content (default: false)\n  -h, --help             display help for command\n\n#  1:2对应，合适等比字体\n#  &#39;&#123;&quot;0&quot;: 0, &quot;1&quot;: 2&#125;&#39;\n#  [默认] IDEA大致对应\n#  &#39;&#123;&quot;0&quot;: 0, &quot;1&quot;: 2, &quot;2&quot;: 3, &quot;3&quot;: 5&#125;&#39;\n#  自定义对应，按照需求自定义向后添加\n#  &#39;&#123;&quot;0&quot;: 0, &quot;1&quot;: 2, &quot;2&quot;: 3, &quot;3&quot;: 5, &quot;4&quot;: 7&#125;&#39;\n\n# 格式化一个文件\nreformat-markdown-cn .&#x2F;markdown&#x2F;example.md \n# 格式化多个文件\nreformat-markdown-cn .&#x2F;markdown&#x2F;**&#x2F;*.md\n# 自定义字符对应\nreformat-markdown-cn .&#x2F;markdown&#x2F;example.md -R &#39;&#123;&quot;0&quot;: 0, &quot;1&quot;: 2&#125;&#39;\nreformat-markdown-cn .&#x2F;markdown&#x2F;**&#x2F;*.md -R &#39;&#123;&quot;0&quot;: 0, &quot;1&quot;: 2&#125;&#39;\n# 终端输出内容，不会覆盖源文件\nreformat-markdown-cn .&#x2F;markdown&#x2F;example.md -R &#39;&#123;&quot;0&quot;: 0, &quot;1&quot;: 2&#125;&#39; -C\nreformat-markdown-cn .&#x2F;markdown&#x2F;**&#x2F;*.md -R &#39;&#123;&quot;0&quot;: 0, &quot;1&quot;: 2&#125;&#39; -C\n\n代码npm i reformat-markdown-cn -S\n\nconst &#123; reformat &#125; &#x3D; require(&#39;reformat-markdown-cn&#39;)\n\nconst content &#x3D; &#96;\n## 标题\n\n| 姓名 | 电话 | 邮箱 |\n| --- | :---: | ---: |\n| 王顶 | 13582027613 | 408542507@qq.com |\n| 郭玉朝 | 13812347652 | baldy@163.com |\n|  | abc | def\n&#96;\n\nconst result &#x3D; reformat(content, &#39;&#123;&quot;0&quot;: 0, &quot;1&quot;: 2&#125;&#39;)\n\n\nindex.d.ts\n\n&#x2F;**\n * Reformat markdown table in multiple file\n * formatString\n * &#39;&#123;&quot;0&quot;: 0, &quot;1&quot;: 2&#125;&#39; terminal\n * &#39;&#123;&quot;0&quot;: 0, &quot;1&quot;: 2, &quot;2&quot;: 3, &quot;3&quot;: 5&#125;&#39; IDEA\n *\n * @param str markdown content\n * @param formatString default &#39;&#123;&quot;0&quot;: 0, &quot;1&quot;: 2, &quot;2&quot;: 3, &quot;3&quot;: 5&#125;&#39;\n *&#x2F;\ndeclare function reformat(str: string, formatString: string): string\n","slug":"reformatMarkdownTable","date":"2021-08-24T23:34:08.164Z","categories_index":"工具","tags_index":"JAVASCRIPT,TYPESCRIPT,NPM,CMD","author_index":"SKY"}]